function ProjectedOverlay(a, b, c, d) {
    google.maps.OverlayView.call(this), this.map_ = a, this.url_ = b, this.bounds_ = c, this.addZ_ = d.addZoom || "", this.id_ = d.id || this.url_, this.percentOpacity_ = d.percentOpacity || 50, this.setMap(a)
}
function ProjectedOverlay(a, b, c, d) {
    google.maps.OverlayView.call(this), this.map_ = a, this.url_ = b, this.bounds_ = c, this.addZ_ = d.addZoom || "", this.id_ = d.id || this.url_, this.percentOpacity_ = d.percentOpacity || 50, this.setMap(a)
}
function ProjectedOverlay(a, b, c, d) {
    google.maps.OverlayView.call(this), this.map_ = a, this.url_ = b, this.bounds_ = c, this.addZ_ = d.addZoom || "", this.id_ = d.id || this.url_, this.percentOpacity_ = d.percentOpacity || 50, this.setMap(a)
}
function MultiGeometry(a) {
    function b(a, b) {
        var c = new google.maps.Polyline(a);
        return google.maps.event.addListener(c, "click", function (a) {
            google.maps.event.trigger(b, "click", a)
        }), google.maps.event.addListener(c, "dblclick", function (a) {
            google.maps.event.trigger(b, "dblclick", a)
        }), google.maps.event.addListener(c, "mousedown", function (a) {
            google.maps.event.trigger(b, "mousedown", a)
        }), google.maps.event.addListener(c, "mousemove", function (a) {
            google.maps.event.trigger(b, "mousemove", a)
        }), google.maps.event.addListener(c, "mouseout", function (a) {
            google.maps.event.trigger(b, "mouseout", a)
        }), google.maps.event.addListener(c, "mouseover", function (a) {
            google.maps.event.trigger(b, "mouseover", a)
        }), google.maps.event.addListener(c, "mouseup", function (a) {
            google.maps.event.trigger(b, "mouseup", a)
        }), google.maps.event.addListener(c, "rightclick", function (a) {
            google.maps.event.trigger(b, "rightclick", a)
        }), c
    }

    for (this.setValues(a), this.polylines = [], i = 0; i < this.paths.length; i++) {
        var c = a;
        c.path = this.paths[i];
        var d = b(c, this);
        this.polylines.push(d)
    }
}
function MultiGeometry(a) {
    function b(a, b) {
        var c = new google.maps.Polyline(a);
        return google.maps.event.addListener(c, "click", function (a) {
            google.maps.event.trigger(b, "click", a)
        }), google.maps.event.addListener(c, "dblclick", function (a) {
            google.maps.event.trigger(b, "dblclick", a)
        }), google.maps.event.addListener(c, "mousedown", function (a) {
            google.maps.event.trigger(b, "mousedown", a)
        }), google.maps.event.addListener(c, "mousemove", function (a) {
            google.maps.event.trigger(b, "mousemove", a)
        }), google.maps.event.addListener(c, "mouseout", function (a) {
            google.maps.event.trigger(b, "mouseout", a)
        }), google.maps.event.addListener(c, "mouseover", function (a) {
            google.maps.event.trigger(b, "mouseover", a)
        }), google.maps.event.addListener(c, "mouseup", function (a) {
            google.maps.event.trigger(b, "mouseup", a)
        }), google.maps.event.addListener(c, "rightclick", function (a) {
            google.maps.event.trigger(b, "rightclick", a)
        }), c
    }

    for (this.setValues(a), this.polylines = [], i = 0; i < this.paths.length; i++) {
        var c = a;
        c.path = this.paths[i];
        var d = b(c, this);
        this.polylines.push(d)
    }
}
function MultiGeometry(a) {
    function b(a, b) {
        var c = new google.maps.Polyline(a);
        return google.maps.event.addListener(c, "click", function (a) {
            google.maps.event.trigger(b, "click", a)
        }), google.maps.event.addListener(c, "dblclick", function (a) {
            google.maps.event.trigger(b, "dblclick", a)
        }), google.maps.event.addListener(c, "mousedown", function (a) {
            google.maps.event.trigger(b, "mousedown", a)
        }), google.maps.event.addListener(c, "mousemove", function (a) {
            google.maps.event.trigger(b, "mousemove", a)
        }), google.maps.event.addListener(c, "mouseout", function (a) {
            google.maps.event.trigger(b, "mouseout", a)
        }), google.maps.event.addListener(c, "mouseover", function (a) {
            google.maps.event.trigger(b, "mouseover", a)
        }), google.maps.event.addListener(c, "mouseup", function (a) {
            google.maps.event.trigger(b, "mouseup", a)
        }), google.maps.event.addListener(c, "rightclick", function (a) {
            google.maps.event.trigger(b, "rightclick", a)
        }), c
    }

    for (this.setValues(a), this.polylines = [], i = 0; i < this.paths.length; i++) {
        var c = a;
        c.path = this.paths[i];
        var d = b(c, this);
        this.polylines.push(d)
    }
}
ProjectedOverlay.prototype = new google.maps.OverlayView, ProjectedOverlay.prototype.createElement = function () {
    var a = this.getPanes(), b = this.div_;
    b || (b = this.div_ = document.createElement("div"), b.style.position = "absolute", b.setAttribute("id", this.id_), this.div_ = b, this.lastZoom_ = -1, this.percentOpacity_ && this.setOpacity(this.percentOpacity_), a.overlayLayer.appendChild(b))
}, ProjectedOverlay.prototype.remove = function () {
    this.div_ && (this.div_.parentNode.removeChild(this.div_), this.div_ = null, this.setMap(null))
}, ProjectedOverlay.prototype.draw = function (a) {
    if (this.createElement(), this.div_) {
        var b = this.get("projection").fromLatLngToDivPixel(this.bounds_.getSouthWest()), c = this.get("projection").fromLatLngToDivPixel(this.bounds_.getNorthEast());
        if (b && c && (this.div_.style.width = Math.abs(c.x - b.x) + "px", this.div_.style.height = Math.abs(c.y - b.y) + "px", this.div_.style.left = Math.min(c.x, b.x) + "px", this.div_.style.top = Math.min(c.y, b.y) + "px", this.lastZoom_ != this.map_.getZoom())) {
            this.lastZoom_ = this.map_.getZoom();
            var d = this.url_;
            this.addZ_ && (d += this.addZ_ + this.map_.getZoom()), this.div_.innerHTML = '<img src="' + d + '"  width=' + this.div_.style.width + " height=" + this.div_.style.height + " >"
        }
    }
}, ProjectedOverlay.prototype.setOpacity = function (a) {
    0 > a && (a = 0), a > 100 && (a = 100);
    var b = a / 100;
    "string" == typeof this.div_.style.filter && (this.div_.style.filter = "alpha(opacity:" + a + ")"), "string" == typeof this.div_.style.KHTMLOpacity && (this.div_.style.KHTMLOpacity = b), "string" == typeof this.div_.style.MozOpacity && (this.div_.style.MozOpacity = b), "string" == typeof this.div_.style.opacity && (this.div_.style.opacity = b)
}, function () {
    if ("object" == typeof JSIO) {
        var a = new Error("JSIO is already defined");
        throw a.source = "JSIO.core.js", a
    }
    JSIO = {}, JSIO.version = "2.0 2012Feb", JSIO.throwError = function (a, b, c) {
        var d = new Error("Error: " + a);
        throw d.source = (b || this._typename || "JSIO") + (c ? "." + c : ""), d
    }, JSIO.decimalToHexString = function (a, b) {
        0 > a && (a = 4294967295 + a + 1);
        var c = a.toString(16).toUpperCase();
        return b && (c = "00000000" + c, c = c.substring(c.length - b)), c
    }, JSIO.FileType = {Text: 0, Binary: 1, XML: 2, Unknown: 3}, JSIO.guessFileType = function (a) {
        if ("makefile" == a)return JSIO.FileType.Text;
        var b = a.lastIndexOf(".");
        if (0 >= b)return JSIO.FileType.Unknown;
        var c = a.substring(b);
        return ".zip" == c ? JSIO.FileType.Binary : ".xlsx" == c ? JSIO.FileType.Binary : ".docx" == c ? JSIO.FileType.Binary : ".dll" == c ? JSIO.FileType.Binary : ".obj" == c ? JSIO.FileType.Binary : ".pdb" == c ? JSIO.FileType.Binary : ".exe" == c ? JSIO.FileType.Binary : ".kmz" == c ? JSIO.FileType.Binary : ".xml" == c ? JSIO.FileType.XML : ".xsl" == c ? JSIO.FileType.XML : ".kml" == c ? JSIO.FileType.XML : ".csproj" == c ? JSIO.FileType.XML : ".vbproj" == c ? JSIO.FileType.XML : ".shfbproj" == c ? JSIO.FileType.XML : ".resx" == c ? JSIO.FileType.XML : ".xslt" == c ? JSIO.FileType.XML : ".sln" == c ? JSIO.FileType.Text : ".htm" == c ? JSIO.FileType.Text : ".html" == c ? JSIO.FileType.Text : ".js" == c ? JSIO.FileType.Text : ".vb" == c ? JSIO.FileType.Text : ".txt" == c ? JSIO.FileType.Text : ".rels" == c ? JSIO.FileType.Text : ".css" == c ? JSIO.FileType.Text : ".cs" == c ? JSIO.FileType.Text : ".asp" == c ? JSIO.FileType.Text : JSIO.FileType.Unknown
    }, JSIO.stringOfLength = function (a, b) {
        for (var c = "", d = 0; b > d; d++)c += String.fromCharCode(a);
        return c
    }, JSIO.formatByteArray = function (a) {
        for (var b = "0000  ", c = "", d = 0; d < a.length; d++)0 !== d && d % 16 === 0 && (b += "    " + c + "\n" + JSIO.decimalToHexString(d, 4) + "  ", c = ""), b += JSIO.decimalToHexString(a[d], 2) + " ", c += a[d] >= 32 && a[d] <= 126 ? String.fromCharCode(a[d]) : ".";
        return c.length > 0 && (b += JSIO.stringOfLength(32, (d % 16 > 0 ? 3 * (16 - d % 16) : 0) + 4) + c), b
    }, JSIO.htmlEscape = function (a) {
        return a.replace(new RegExp("&", "g"), "&amp;").replace(new RegExp("<", "g"), "&lt;").replace(new RegExp(">", "g"), "&gt;").replace(new RegExp("", "g"), "<br/>").replace(new RegExp("", "g"), "<br/>")
    }, JSIO.massApply = function (a, b, c, d) {
        var e = 65536;
        if (c.length < e)return a.apply(b, c);
        for (var f = b, g = 0, h = 65536; g < c.length;) {
            var i;
            c.subarray ? i = c.subarray(g, h) : c.slice && (i = c.slice(g, h)), d ? f += a.apply(f, i) : a.apply(b, i), g += e, h += e, h = Math.min(c.length, h)
        }
        return f
    }
}(), function () {
    var a = "2.0 2012Feb";
    "object" != typeof JSIO && (JSIO = {}), "string" != typeof JSIO.version ? JSIO.version = a : (JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && (JSIO.version += " " + a);
    var b = function () {
        this.position = 0
    };
    b.prototype._throwError = JSIO.throwError, b.prototype._limitCheck = function (a, b) {
        var c = {len: a, pos: b, end: b + a};
        return 0 === a ? {
            len: 0,
            pos: 0,
            end: 0
        } : (0 > a && this._throwError("Invalid read length"), this.length ? (!b >= 0 && (c.pos = this.position), this.length <= c.pos && this._throwError("EOF reached"), c.end = c.pos + a, this.length < c.end && (c.end = c.pos + (c.len = this.length - this.position)), c) : {
            len: a,
            pos: this.position,
            end: a + this.position
        })
    }, JSIO.SeekOrigin = {
        Begin: 0,
        Current: 1,
        End: 2,
        SEEK_SET: 0,
        SEEK_CUR: 1,
        SEEK_END: 2
    }, b.prototype.seek = function (a, b) {
        switch (b) {
            case JSIO.SeekOrigin.Begin:
                if (a == this.position)return this.position;
                if (this.length)this.length < a && this._throwError("Cannot seek past reader length", null, "seek"), this.position = a; else if (a < this.position)this._throwError("Uni-directional stream cannot seek backwards", null, "seek"); else if (a > this.position)return this.read(a - this.position);
                break;
            case JSIO.SeekOrigin.Current:
                return this.seek(this.position + a, JSIO.SeekOrigin.Begin);
            case JSIO.SeekOrigin.End:
                return this.length || this._throwError("Uni-directional stream has no known end length for seek", null, "seek"), this.seek(this.length - 1 + a, JSIO.SeekOrigin.Begin);
            default:
                this._throwError("Invalid seek method", null, "seek")
        }
        return this.position
    }, b.prototype.read = function (a, b) {
        var c = this._limitCheck(a, b);
        if (0 === c.len)return [];
        c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        var d = [];
        if (this.array && this.array.subarray)d = this.array.subarray(c.pos, c.end); else if (this.array && this.array.slice)d = this.array.slice(c.pos, c.end); else if (this.stream)d = this.stream.read(c.len, c.pos); else if (this.length)for (var e = c.pos; e < c.end; e++)d.push(this.readByteAt(e)); else for (var e = c.pos; e < c.end; e++) {
            var f = this.readByte();
            if (null === f || void 0 === f)break;
            d.push(f)
        }
        return this.position = c.end, d
    }, b.prototype.beginRead = function (a, b, c) {
        var d = this._limitCheck(a, b);
        if (0 === d.len)return setTimeout(function () {
            c([])
        }, 1);
        d.pos != this.position && this.seek(d.pos, JSIO.SeekOrigin.Begin);
        var e = [], f = this, g = d.len, h = function () {
            var a = 0, b = (f.position, g >= 32768 ? 32768 : g), d = f.read(b);
            JSIO.massApply(e.push, e, d), a += b, g -= b, d.length < b && (g = 0), g > 0 ? setTimeout(h, 1) : c(e)
        };
        return setTimeout(h, 1), null
    }, b.prototype.readToEnd = function () {
        return this.array && this.array.subarray ? this.array.subarray(this.position) : this.array && this.array.slice ? this.array.slice(this.position) : this.length ? this.read(this.length - this.position) : this.read(81e6)
    }, b.prototype.beginReadToEnd = function (a) {
        if (this.array && this.array.subarray)setTimeout(function () {
            a(this.array.subarray(this.position))
        }, 1); else {
            if (!this.array || !this.array.slice)return this.length ? this.beginRead(this.length - this.position, this.position, a) : this.beginRead(81e6, this.position, a);
            setTimeout(function () {
                a(this.array.slice(this.position))
            }, 1)
        }
    }, b.prototype.readByte = function () {
        if (this.length && this.position >= this.length)return null;
        var a;
        return a = this.array ? this.array[this.position++] : this.length ? this.readByteAt(this.position++) : this.stream ? this.stream.read(1)[0] : this.read(1)[0], null === a || void 0 === a ? null : a
    }, b.prototype.readByteAt = function (a) {
        var b = this.position;
        (null === a || void 0 === a) && (a = this.position);
        var c;
        return c = this.array ? this.array[a] : a === b ? this.readByte() : this.stream ? this.stream.read(1, a)[0] : this.read(1, a)[0], this.position = b, null === c || void 0 === c ? null : c
    }, b.prototype.readBytes = b.prototype.read, b.prototype.beginReadBytes = function (a, b) {
        return this.beginRead(a, this.position, b)
    }, b.prototype.readNumber = function (a, b) {
        var c = this._limitCheck(a, b);
        0 === c.len && (c.len = 1), c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        for (var d = 0, e = this.read(c.len, c.pos), f = e.length - 1; f >= 0; f--)d = 256 * d + e[f];
        return d
    }, b.prototype.readString = function (a, b) {
        var c = this._limitCheck(a, b);
        if (0 === c.len)return "";
        c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        for (var d = "", e = this.read(c.len, c.pos), f = 0; f < e.length; f++)d += String.fromCharCode(e[f]);
        return d
    }, b.prototype.readNullTerminatedString = function (a) {
        var b = a || this.position;
        this.length && this.length < b && this._throwError("EOF reached", null, "readNullTerminatedString"), b != this.position && this.seek(b, JSIO.SeekOrigin.Begin);
        var c = "", d = "", e = 0;
        if (this.array && this.array.indexOf) {
            var f = b - this.array.indexOf(0, b);
            if (f > 0)return this.readString(f, b)
        }
        for (var g; ;) {
            if (g = String.fromCharCode(this.readByteAt(b + e)), null === g)break;
            d += g, e++, e >= 32768 && (c += d, d = "", b += e, this.position += e, e = 0)
        }
        return this.position = b + e, c + d
    }, b.prototype.beginReadNullTerminatedString = function (a, b) {
        var c = b || this.position;
        this.length && this.length < c && this._throwError("EOF reached", null, "beginReadNullTerminatedString");
        var d = "", e = "", f = this, g = function () {
            for (var b, h = 0; ;) {
                if (b = String.fromCharCode(this.readByteAt(c + h)), null === b)break;
                e += b, h++, h >= 32768 && (d += e, e = "", c += h, this.position += h, h = 0)
            }
            f.position = c + h, null !== b ? setTimeout(g, 1) : a(d + e)
        };
        if (this.array && this.array.indexOf) {
            var h = c - this.array.indexOf(0, c);
            h > 0 && (readBatchASync = function () {
                a(f.readString(h, c))
            })
        }
        return setTimeout(g, 1), null
    }, JSIO._ByteReaderBase = b;
    var c = function (b) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.ArrayReader", "ctor"), this.position = 0, this.array = b, this.length = b.length, this._typename = "JSIO.ArrayReader", this._version = a, this
    };
    c.prototype = new JSIO._ByteReaderBase, c.prototype.readByte = function () {
        return this.position >= this.array.length ? null : this.array[this.position++]
    }, c.prototype.readByteAt = function (a) {
        return this.array[a]
    };
    var d = function (b, d, e) {
        if (this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.StreamSegmentReader", "ctor"), b || this._throwError("You must pass a non-null stream", "JSIO.StreamSegmentReader", "ctor"), d >= 1 || (d = 0), e >= 1 || (e = 0), this.stream = b, this.array = null, b.array) {
            var f = e ? d + e : null;
            b.array.subarray ? this.array = b.array.subarray(d, f) : b.array.slice && (this.array = b.array.slice(d, f))
        }
        return this.length = this.array ? this.array.length : b.length ? b.length - d : null, this.offset = d, this.limit = e, this.position = 0, this._typeName = "JSIO.StreamSegmentReader", this._version = a, this.array && (this.readByte = c.prototype.readByte, this.readByteAt = c.prototype.readByteAt), this
    };
    d.prototype = new JSIO._ByteReaderBase, d.prototype.readByte = function () {
        return this.limit && this.position >= this.limit ? null : (this.position++, this.stream.readByteAt(this.offset + this.position - 1))
    }, d.prototype.readByteAt = function (a) {
        return this.limit && a >= this.limit ? null : this.stream.readByteAt(this.offset + a)
    }, JSIO.ArrayReader = c, JSIO.StreamReader = d, JSIO.StreamSegmentReader = d
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.BinaryUrlStream";
    if (("object" != typeof JSIO || "string" != typeof JSIO.version || JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && JSIO.throwError("This extension requires JSIO.core.js v2.0", b), "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        var c = "<!-- IEBinaryToArray_ByteStr -->\r\n<script type='text/vbscript'>\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteAsc_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n      IEBinaryToArray_ByteAsc_Last = AscB( MidB( Binary, lastIndex, 1 ) )\r\n   Else\r\n      IEBinaryToArray_ByteAsc_Last = -1\r\n   End If\r\nEnd Function\r\n</script>\r\n";
        document.write(c)
    }
    JSIO.IEByteMapping = null;
    var d = function (c, d) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.BinaryUrlStream", "ctor"), this.callback = d, this.position = 0, this.length = null, this.readByte = JSIO.ArrayReader.prototype.readByte, this.readByteAt = JSIO.ArrayReader.prototype.readByteAt, this.req = null, this._typename = b, this._version = a, this.status = "-none-";
        var e = function (a) {
            var b = this, c = function (a) {
                var b = new Array;
                try {
                    b = new VBArray(a).toArray()
                } catch (c) {
                    if (!JSIO.IEByteMapping) {
                        JSIO.IEByteMapping = {};
                        for (var d = 0; 256 > d; d++)for (var e = 0; 256 > e; e++)JSIO.IEByteMapping[String.fromCharCode(d + 256 * e)] = [d, e]
                    }
                    for (var f = IEBinaryToArray_ByteStr(a), g = IEBinaryToArray_ByteAsc_Last(a), d = 0; d < f.length; d++)b.push.apply(b, JSIO.IEByteMapping[f.substr(d, 1)]);
                    g >= 0 && b.push(g)
                }
                return b
            };
            this.req = function () {
                if (window.XMLHttpRequest)return new window.XMLHttpRequest;
                if (window.ActiveXObject)for (var a = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP"], b = 0; b < a.length; b++)try {
                    return new ActiveXObject(a[b])
                } catch (c) {
                    continue
                }
                return null
            }(), this.req.open("GET", a, !0), this.req.setRequestHeader("Accept-Charset", "x-user-defined"), this.req.onreadystatechange = function (d) {
                4 == b.req.readyState && (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status ? (b.array = c(b.req.responseBody), b.length = b.array.length, b.length < 0 && this._throwError('Failed to load "' + a + '" after converting'), "function" == typeof b.callback && b.callback(b)) : b._throwError('Failed to load "' + a + '": HTTP ' + b.status))
            }, this.req.send()
        }, f = function (a) {
            var b = this;
            this.req = new XMLHttpRequest, this.req.open("GET", a, !0), this.req.onreadystatechange = function (c) {
                if (4 == b.req.readyState)if (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status) {
                    var d = b.req.responseText;
                    b.length = d.byteLength, b.array = d.split("");
                    for (var e = 0; e < b.array.length; e++)b.array[e] = 255 & b.array[e].charCodeAt(0);
                    "function" == typeof b.callback && b.callback(b)
                } else b._throwError('Failed to load "' + a + '": HTTP ' + b.status)
            }, this.req.overrideMimeType && this.req.overrideMimeType("text/plain; charset=x-user-defined"), this.req.send(null)
        }, g = function (a) {
            var b = this;
            this.req = new XMLHttpRequest, this.req.open("GET", a, !0), this.req.onreadystatechange = function (c) {
                if (4 == b.req.readyState)if (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status) {
                    var d = b.req.response;
                    b.length = d.byteLength, b.array = new Uint8Array(d), "function" == typeof b.callback && b.callback(b)
                } else b._throwError('Failed to load "' + a + '": HTTP ' + b.status)
            }, this.req.responseType = "arraybuffer", this.req.overrideMimeType && this.req.overrideMimeType("application/octet-stream; charset=x-user-defined"), this.req.send(null)
        };
        "undefined" != typeof ArrayBuffer ? g.apply(this, [c]) : /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? e.apply(this, [c]) : f.apply(this, [c])
    };
    d.prototype = new JSIO._ByteReaderBase, d.prototype.readByte = function () {
        var a = this.readByteAt(this.position++);
        return null === a || void 0 === a ? null : a
    }, JSIO.BinaryUrlStream = d
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.TextDecoder";
    ("object" != typeof JSIO || "string" != typeof JSIO.version || JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && JSIO.throwError("This extension requires JSIO.core.js v2.0", b), "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b);
    var c = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.ANSI", "ctor"), this.byteReader = c, this.charWidth = 1, this._version = a, this._typename = b + ".ANSI", this
    };
    c.prototype.readChar = function () {
        var a = this.byteReader.readByte();
        return 0 > a ? null : String.fromCharCode(a)
    }, c.prototype.parseChar = function (a) {
        return 0 > a ? null : String.fromCharCode(a)
    };
    var d = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.UTF16", "ctor"), this.byteReader = c, this.charWidth = 2, this.bomState = 0, this._version = a, this._typename = b + ".UTF16", this
    };
    d.prototype.readChar = function () {
        var a = this.byteReader.readByte();
        if (0 > a)return null;
        var b = this.byteReader.readByte();
        if (0 > b && this._throwError("Incomplete UTF16 character", null, "readChar"), 0 === this.bomState && a + b == 509) {
            if (this.bomState = 254 == b ? 1 : 2, a = this.byteReader.readByte(), 0 > a)return null;
            b = this.byteReader.readByte(), 0 > b && this._throwError("Incomplete UTF16 character", null, "readChar")
        } else this.bomState = 1;
        return this.parseChar(a, b)
    }, d.prototype.parseChar = function (a, b) {
        return String.fromCharCode(1 == this.bomState ? b << 8 | a : a << 8 | b)
    };
    var e = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.UTF8", "ctor"), this.byteReader = c, this.charWidth = null, this.waitBom = !0, this.strict = !1, this.pendingChar = null, this._version = a, this._typename = b + ".UTF8", this
    };
    e.prototype.readChar = function () {
        var a = null;
        do {
            if (null !== this.pendingChar)a = this.pendingChar, this.pendingChar = null; else {
                var b = this.byteReader.readByte();
                if (null === b)return null;
                if (0 === (128 & b))a = String.fromCharCode(b); else {
                    var c = 192, d = 0;
                    do {
                        var e = c >> 1 | 128;
                        if ((b & e) == c)break;
                        c = c >> 1 | 128
                    } while (++d < 5);
                    if (d > 0) {
                        var f;
                        if (1 === d)f = (31 & b) << 6 | 63 & this.byteReader.readByte(); else {
                            f <<= 6 * d;
                            for (var g = this.byteReader.read(d), h = 0; h > d; h++) {
                                var i = g[h];
                                128 != (192 & i) && this._throwError("Invalid sequence character", null, "readChar"), f = f << 6 | 63 & i
                            }
                        }
                        if (65535 >= f)a = 65279 == f && this.waitBom ? null : String.fromCharCode(f); else {
                            var j = f - 65536, k = 55296 | j >> 10 & 1023, l = 56320 | 1023 & j;
                            this.pendingChar = String.fromCharCode(l), a = String.fromCharCode(k)
                        }
                    } else this.strict ? this._throwError("Invalid character", null, "readChar") : a = String.fromCharCode(b)
                }
            }
            this.waitBom = !1
        } while (null === a);
        return a
    }, JSIO.TextDecoder = {Default: c, ANSI: c, UTF16: d, UTF8: e}
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.TextReader";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b);
    var c = function (c) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), this.decoder = c, this._version = a, this._typename = b, this.unreads = []
    };
    c.prototype.readChar = function () {
        return this.unreads.length > 0 ? this.unreads.pop() : this.decoder.readChar()
    }, c.prototype.read = function (a) {
        if (1 === this.decoder.charWidth)return JSIO.massApply(String.fromCharCode, new String, this.decoder.byteReader.read(a), !0);
        var b = "";
        for (vari = 0; i < a; i++) {
            var c = this.readChar();
            if (null === c)break;
            b += c
        }
        return b
    }, c.prototype.unreadChar = function (a) {
        this.unreads.push(a)
    }, c.prototype.readToEnd = function () {
        if (1 === this.decoder.charWidth)return JSIO.massApply(String.fromCharCode, new String, this.decoder.byteReader.readToEnd(n), !0);
        for (var a = "", b = "", c = 0, d = this.readChar(); null !== d;)b += d, c++, c >= 32768 && (a += b, b = "", c = 0), d = this.readChar();
        return a + b
    }, c.prototype.beginReadToEnd = function (a) {
        if (1 === this.decoder.charWidth)return this.decoder.byteReader.beginReadToEnd(function (b) {
            a(JSIO.massApply(String.fromCharCode, new String, b, !0))
        }), null;
        var b = "", c = "", d = this, e = function () {
            for (var f = 0, g = d.readChar(); null !== g;) {
                if (c += g, f++, f >= 32768) {
                    b += c, c = "";
                    break
                }
                g = d.readChar()
            }
            null !== g ? setTimeout(e, 1) : a(b + c)
        };
        return setTimeout(e, 1), null
    }, c.prototype.readLine = function () {
        var a = "", b = this.readChar();
        if (null === b)return null;
        for (; "\r" != b && "\n" != b;)if (a += b, b = this.readChar(), null === b)return a;
        return "\r" == b && (b = this.readChar(), null !== b && "\n" != b && this.unreadChar(b)), a
    }, JSIO.TextReader = c
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.Crc32";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), JSIO.crc32Table = null, JSIO.crc32Polynomial = 3988292384;
    var c = function () {
        if (!JSIO.crc32Table) {
            JSIO.crc32Table = new Array(256);
            for (var a = 0; 256 > a; a++) {
                for (var b = a, c = 0; 8 > c; c++)1 == (1 & b) ? b = JSIO.crc32Polynomial ^ b >>> 1 : b >>>= 1;
                JSIO.crc32Table[a] = b
            }
        }
    };
    JSIO.computeCrc32 = function (a) {
        c();
        var b = 4294967295, d = a.length;
        if ("object" == typeof a)for (var e = 0; d > e; e++)b = JSIO.crc32Table[255 & b ^ a[e]] ^ b >>> 8; else for (var f = 0; d > f; f++)b = JSIO.crc32Table[255 & b ^ a.charCodeAt(f)] ^ b >>> 8;
        return b ^= 4294967295, 0 > b && (b += 4294967296), b
    };
    var d = function () {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), c(), this._typename = b, this._version = a, this._runningCrc32 = 4294967295
    };
    d.prototype.slurpByte = function (a) {
        var b = this._runningCrc32;
        this._runningCrc32 = b >>> 8 ^ JSIO.crc32Table[a ^ 255 & b]
    }, d.prototype.result = function () {
        var a = 4294967295 ^ this._runningCrc32;
        return 0 > a && (a += 4294967296), a
    };
    var e = function (b) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.Crc32Reader", "ctor"), this._byteReader = b, this._typename = "JSIO.Crc32Reader", this._version = a, this._crc32 = new JSIO.Crc32
    };
    e.prototype = new JSIO._ByteReaderBase, e.prototype.readByte = function () {
        var a = this._byteReader.readByte();
        return null !== a && this._crc32.slurpByte(a), this.position++, a
    }, e.prototype.read = function (a) {
        if (0 === a)return [];
        var b = this._byteReader.read(a);
        a = b.length;
        for (var c, d = JSIO.crc32Table, e = this._crc32._runningCrc32, f = 0; a > f; f++)c = d[b[f] ^ 255 & e], e = e >>> 8 ^ c;
        return this._crc32._runningCrc32 = e, this.position += a, b
    }, e.prototype.crc32 = function () {
        return this._crc32.result()
    }, JSIO.Crc32 = d, JSIO.Crc32Reader = e
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.InflatingReader";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), JSIO.bitShiftTable = null;
    var c = function () {
        if (!JSIO.bitShiftTable) {
            var a = 8;
            JSIO.bitShiftTable = {LSB: new Array(a), MSB: new Array(a)};
            for (var b = 0; a > b; b++) {
                var c = a - b;
                JSIO.bitShiftTable.LSB[b] = new Array(c), JSIO.bitShiftTable.MSB[b] = new Array(c);
                for (var d = 1 << b, e = 1 << c - 1, f = 1; c >= f; f++)JSIO.bitShiftTable.LSB[b][f - 1] = d, JSIO.bitShiftTable.MSB[b][f - 1] = e, d |= 1 << b + f, e |= 1 << c - f - 1
            }
        }
    }, d = function (d) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b + "._InternalBitReader.ctor"), this.bitsLength = 0, this.bits = 0, this.byteReader = d, this._typeName = b + "._InternalBitReader", this._version = a, c()
    };
    d.prototype._throwError = JSIO.throwError, d.prototype.readBit = function () {
        if (0 === this.bitsLength) {
            var a = this.byteReader.readByte();
            null === a && this._throwError("Unexpected end of stream", null, "readBit"), this.bits = a, this.bitsLength = 8
        }
        var b = 0 !== (this.bits & 1 << 8 - this.bitsLength);
        return this.bitsLength--, b
    }, d.prototype.align = function () {
        this.bitsLength = 0
    }, d.prototype.readBits = function (a, b) {
        var c = 0;
        b = b || "LSB";
        for (var d = JSIO.bitShiftTable[b], e = 0; a > 0;) {
            if (0 === this.bitsLength) {
                var f = this.byteReader.readByte();
                null === f && this._throwError("Unexpected end of stream", null, "read" + b), this.bits = f, this.bitsLength = 8
            }
            var g = this.bitsLength >= a ? a : this.bitsLength, h = 8 - this.bitsLength;
            c |= (this.bits & d[h][g - 1]) >>> h << e, e += g, a -= g, this.bitsLength -= g
        }
        return c
    }, d.prototype.readLSB = function (a) {
        return this.readBits(a, "LSB")
    }, d.prototype.readMSB = function (a) {
        return this.readBits(a, "MSB")
    };
    var e = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), this._byteReader = c, this._bitReader = new d(c), this._buffer = [], this._bufferPosition = 0, this._state = 0, this._blockFinal = !1, this._typeName = b, this._version = a, this
    }, f = null, g = null, h = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], i = function (a) {
        var b = 0, c = new Array(a.length), d = a[0];
        for (b = 1; b < a.length; b++)d < a[b] && (d = a[b]);
        var e = new Array(d + 1);
        for (b = 0; d >= b; b++)e[b] = 0;
        for (b = 0; b < a.length; b++)++e[a[b]];
        var f = new Array(d + 1), g = 0;
        e[0] = 0;
        for (var h = 1; d >= h; h++)g = g + e[h - 1] << 1, f[h] = g;
        for (b = 0; b < c.length; b++) {
            var i = a[b];
            0 !== i && (c[b] = f[i], f[i]++)
        }
        return c
    }, j = function (a, b) {
        for (var c = [], d = 0; d < a.length; ++d)if (b[d] > 0) {
            var e = {};
            e.bits = a[d], e.length = b[d], e.index = d, c.push(e)
        }
        return k(c, 0, 0)
    }, k = function (a, b, c) {
        if (0 === a.length)return null;
        var d = [], e = [], f = {};
        f.isLeaf = !1;
        for (var g = 0; g < a.length; ++g) {
            if (a[g].length == c && a[g].bits == b) {
                f.isLeaf = !0, f.index = a[g].index;
                break
            }
            var h = (a[g].bits >> a[g].length - c - 1 & 1) > 0;
            h ? e.push(a[g]) : d.push(a[g])
        }
        return f.isLeaf || (f.zero = k(d, b << 1, c + 1), f.one = k(e, b << 1 | 1, c + 1)), f
    }, l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], m = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], n = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], o = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], p = function (a) {
        var b, c = a.readLSB(5) + 257, d = a.readLSB(5) + 1, e = a.readLSB(4) + 4, f = new Array(19);
        for (b = 0; b < f.length; b++)f[b] = 0;
        for (b = 0; e > b; b++)f[h[b]] = a.readLSB(3);
        for (var g = i(f), k = j(g, f), l = []; l.length < c + d;) {
            for (var m = k; !m.isLeaf;)m = a.readBit() ? m.one : m.zero;
            var n = m.index;
            if (15 >= n)l.push(n); else if (16 == n)for (var o = a.readLSB(2) + 3, p = 0; o > p; ++p)l.push(l[l.length - 1]); else if (17 == n)for (var q = a.readLSB(3) + 3, r = 0; q > r; ++r)l.push(0); else if (18 == n)for (var s = a.readLSB(7) + 11, t = 0; s > t; ++t)l.push(0)
        }
        var u = l.slice(0, c), v = i(u), w = l.slice(c, c + d), x = i(w);
        return {codesTree: j(v, u), distancesTree: j(x, w)}
    };
    e.prototype = new JSIO._ByteReaderBase, e.prototype._decodeItem = function () {
        if (2 == this._state)return null;
        var a;
        if (0 === this._state) {
            this._blockFinal = this._bitReader.readBit();
            var b = this._bitReader.readLSB(2);
            switch (b) {
                case 0:
                    this._bitReader.align();
                    var c = this._bitReader.readLSB(16), d = this._bitReader.readLSB(16);
                    return (c & ~d) != c && this._throwError("Invalid block type 0 length", null, "_decodeItem"), a = {}, a.itemType = 0, a.array = this._bitReader.byteReader.read(c), a.array.length < c && this._throwError("Incomplete block", null, "_decodeItem"), this._blockFinal && (this._state = 2), a;
                case 1:
                    this._codesTree = f, this._distancesTree = g, this._state = 1;
                    break;
                case 2:
                    var e = p(this._bitReader);
                    this._codesTree = e.codesTree, this._distancesTree = e.distancesTree, this._state = 1;
                    break;
                default:
                    this._throwError("Invalid block type (" + b + ")", null, "_decodeItem")
            }
        }
        a = {};
        for (var h = this._codesTree; !h.isLeaf;)h = this._bitReader.readBit() ? h.one : h.zero;
        if (h.index < 256)a.itemType = 2, a.symbol = h.index; else if (h.index > 256) {
            var i = h.index;
            i > 285 && this._throwError("Invalid length code", null, "_decodeItem");
            var j = l[i - 257];
            for (m[i - 257] > 0 && (j += this._bitReader.readLSB(m[i - 257])), h = this._distancesTree; !h.isLeaf;)h = this._bitReader.readBit() ? h.one : h.zero;
            var k = h.index, q = n[k];
            o[k] > 0 && (q += this._bitReader.readLSB(o[k])), a.itemType = 3, a.distance = q, a.length = j
        } else a.itemType = 1, this._state = this._blockFinal ? 2 : 0;
        return a
    }, e.prototype.readByte = function () {
        var a = this.read(1)[0];
        return null === a || void 0 === a ? null : a
    }, e.prototype.read = function (a) {
        for (var b = this._buffer; this._bufferPosition + a > b.length;) {
            var c = this._decodeItem();
            if (null === c) {
                a = b.length - this._bufferPosition;
                break
            }
            switch (c.itemType) {
                case 0:
                    JSIO.massApply(b.push, b, c.array);
                    break;
                case 2:
                    b.push(c.symbol);
                    break;
                case 3:
                    var d = b.length - c.distance;
                    if (c.distance >= c.length)JSIO.massApply(b.push, b, b.slice(d, d + c.length)); else {
                        for (var e = parseInt(c.length / c.distance), f = b.slice(d); e > 0;)1 & e && JSIO.massApply(b.push, b, f), (e >>= 1) && JSIO.massApply(f.push, f, f);
                        var g;
                        (g = c.length % c.distance) && JSIO.massApply(b.push, b, b.slice(d, d + g))
                    }
            }
        }
        var h = b.slice(this._bufferPosition, this._bufferPosition + a);
        if (this._bufferPosition += a, this.position += a, this._bufferPosition > 49152) {
            var i = b.length - 32768;
            i > this._bufferPosition && (i = this._bufferPosition), b.splice(0, i), this._bufferPosition -= i
        }
        return h
    }, function () {
        var a = new Array(288), b = new Array(288), c = 0;
        for (c = 0; 143 >= c; c++)a[c] = 48 + c, b[c] = 8;
        for (c = 144; 255 >= c; c++)a[c] = 400 + c - 144, b[c] = 9;
        for (c = 256; 279 >= c; c++)a[c] = 0 + c - 256, b[c] = 7;
        for (c = 280; 287 >= c; c++)a[c] = 192 + c - 280, b[c] = 8;
        f = j(a, b);
        var d = new Array(32), e = new Array(32);
        for (c = 0; 31 >= c; c++)d[c] = c, e[c] = 5;
        g = j(d, e)
    }(), JSIO.InflatingReader = e
}(), function () {
    function a(a) {
        this.zipfile = a, this._typename = "ZipEntry", this._version = b, this._crcCalculator = null
    }

    var b = "2.0 2012Feb", c = "Zipfile";
    "function" != typeof JSIO.BinaryUrlStream && JSIO.throwError("This extension requires JSIO.BinaryUrlStream.js v2.0", c), "object" != typeof JSIO.TextDecoder && JSIO.throwError("This extension requires JSIO.TextDecoder.js v2.0", c), "function" != typeof JSIO.TextReader && JSIO.throwError("This extension requires JSIO.TextReader.js v2.0", c), "function" != typeof JSIO.Crc32 && JSIO.throwError("This extension requires JSIO.Crc32.js v2.0", c), "function" != typeof JSIO.InflatingReader && JSIO.throwError("This extension requires JSIO.InflatingReader.js v2.0", c), a.prototype._throwError = JSIO.throwError, a.prototype.extract = function (a, b) {
        this.contentType = JSIO.guessFileType(this.name), b = b || this.contentType == JSIO.FileType.Text || this.contentType == JSIO.FileType.XML;
        var c = this;
        0 !== this.compressionMethod && 8 != this.compressionMethod && this._throwError("Unsupported compression method: " + this.compressionMethod, null, "extract");
        var d = b ? this.openTextReader(c.utf8 ? JSIO.TextDecoder.UTF8 : JSIO.TextDecoder.ANSI) : this.openBinaryReader();
        if (d.zipEntryName = c.name, "function" != typeof a) {
            var e = d.readToEnd();
            return this.verifyCrc32(), e
        }
        return d.beginReadToEnd(function (b) {
            try {
                c.verifyCrc32(), a(c, b)
            } catch (d) {
                a(c, d)
            }
        }), null
    }, a.prototype.openBinaryReader = function () {
        var a = new JSIO.StreamSegmentReader(this.zipfile.binaryStream, this.offset + this.lengthOfHeader, this.compressedSize);
        if (0 === this.compressionMethod)this._crcCalculator = new JSIO.Crc32Reader(a); else {
            var b = new JSIO.InflatingReader(a);
            this._crcCalculator = new JSIO.Crc32Reader(b)
        }
        return this._crcCalculator
    }, a.prototype.openTextReader = function (a) {
        var b = this.openBinaryReader();
        a = a || JSIO.TextDecoder.UTF8;
        var c = new a(b), d = new JSIO.TextReader(c);
        return c._parent = d, d
    }, a.prototype.verifyCrc32 = function () {
        var a = this._crcCalculator.crc32(), b = !1;
        if (this.crc32 != a) {
            var c = "WARNING: CRC check failed: entry(" + this.name + ") computed(" + JSIO.decimalToHexString(a, 8) + ") expected(" + JSIO.decimalToHexString(this.crc32, 8) + ") ";
            this.zipfile.status.push(c)
        } else b = !0, this.zipfile.verbose > 2 && this.zipfile.status.push("INFO: CRC check ok: 0x" + JSIO.decimalToHexString(this.crc32, 8));
        return b
    }, ZipFile = function (d, e, f) {
        function g(a) {
            if (65535 == a || 0 === a)return new Date(1995, 0, 1, 0, 0, 0, 0);
            var b = 65535 & a, c = (4294901760 & a) >> 16, d = 1980 + ((65024 & c) >> 9), e = ((480 & c) >> 5) - 1, f = 31 & c, g = (63488 & b) >> 11, h = (2016 & b) >> 5, i = 2 * (31 & b);
            i >= 60 && (h++, i = 0), h >= 60 && (g++, h = 0), g >= 24 && (f++, g = 0);
            var j, k = !1;
            try {
                j = new Date(d, e, f, g, h, i, 0), k = !0
            } catch (l) {
                if (1980 != d || 0 !== e && 0 !== f)try {
                    1980 > d && (d = 1980), d > 2030 && (d = 2030), 1 > e && (e = 1), e > 12 && (e = 12), 1 > f && (f = 1), f > 31 && (f = 31), 0 > h && (h = 0), h > 59 && (h = 59), 0 > i && (i = 0), i > 59 && (i = 59), j = new Date(d, e - 1, f, g, h, i, 0), k = !0
                } catch (m) {
                } else try {
                    j = new Date(1980, 0, 1, g, h, i, 0), k = !0
                } catch (n) {
                    try {
                        j = new Date(1980, 0, 1, 0, 0, 0, 0), k = !0
                    } catch (o) {
                    }
                }
            }
            return k || this._throwError("Bad date/time value in this ZIP file", null, "DateFromPackedFormat"), j
        }

        function h() {
            if (0 === j.entryNames.length)for (var a; null !== (a = i());)j.entries.push(a), j.entryNames.push(a.name)
        }

        function i() {
            var b = j.binaryStream.position, c = j.binaryStream.readNumber(4);
            if (c == ZipFile.Signatures.DirEntry)return j.verbose > 0 && j.status.push("INFO: at offset 0x" + JSIO.decimalToHexString(b) + ", found start of Zip Directory."), null;
            if (c != ZipFile.Signatures.Entry)return j.status.push("WARNING: at offset 0x" + JSIO.decimalToHexString(b) + ", found unexpected signature: 0x" + JSIO.decimalToHexString(c)), null;
            var d = new a(j);
            d.offset = b, d.versionNeeded = j.binaryStream.readNumber(2), d.bitField = j.binaryStream.readNumber(2), d.compressionMethod = j.binaryStream.readNumber(2);
            var e = j.binaryStream.readNumber(4);
            if (d.lastModified = g(e), d.crc32 = j.binaryStream.readNumber(4), d.compressedSize = j.binaryStream.readNumber(4), d.uncompressedSize = j.binaryStream.readNumber(4), 1 == (1 & d.bitField))return j.status.push("This zipfile uses Encryption, which is not supported by ZipFile.js."), null;
            if (d.utf8 = 2048 == (2048 & d.bitField), 8 == (8 & d.bitField))return j.status.push("This zipfile uses a bit 3 trailing data descriptor, which is not supported by ZipFile.js."), null;
            if (4294967295 == d.compressedSize || 4294967295 == d.uncompressedSize)return j.status.push("This zipfile uses ZIP64, which is not supported by ZipFile.js"), null;
            var f = j.binaryStream.readNumber(2), h = j.binaryStream.readNumber(2);
            j.status.push("INFO: filename length= " + f);
            var i = 30 + f + h;
            if (d.utf8) {
                j.status.push("INFO: before filename, position= 0x" + JSIO.decimalToHexString(j.binaryStream.position));
                var k = new JSIO.StreamSegmentReader(j.binaryStream, j.binaryStream.position, f), l = new JSIO.TextDecoder.UTF8(k), m = new JSIO.TextReader(l);
                d.name = m.readToEnd(), j.binaryStream.seek(f, JSIO.SeekOrigin.Current, j), j.status.push("INFO: after filename, position= 0x" + JSIO.decimalToHexString(j.binaryStream.position))
            } else d.name = j.binaryStream.readString(f);
            var n = 0;
            for (d.extra = []; h > n;) {
                var o = {type: j.binaryStream.readNumber(2), size: j.binaryStream.readNumber(2)};
                o.typeDescription = ZipFile.ExtraFieldTypes[o.type], o.data = j.binaryStream.read(o.size), d.extra.push(o), n += 4 + o.size
            }
            return j.verbose > 1 && j.status.push("INFO: at offset 0x" + JSIO.decimalToHexString(d.offset) + ", found entry '" + d.name + "' fnl(" + f + ") efl(" + h + ")"), h > 0 && j.verbose > 0 && j.status.push("INFO: entry " + d.name + " has " + h + " bytes of extra metadata (ID'd but ignored)"), d.lengthOfHeader = i, d.totalEntrySize = d.lengthOfHeader + d.compressedSize, j.verbose > 1 && j.status.push("INFO: seek 0x" + JSIO.decimalToHexString(d.compressedSize) + " (" + d.compressedSize + ") bytes"), j.binaryStream.seek(d.compressedSize, JSIO.SeekOrigin.Current, j), d
        }

        this instanceof arguments.callee || JSIO.throwError("You must use new to instantiate this class", c, "ctor"), this.verbose = f || 0, this.entries = [], this.entryNames = [], this.status = [], this._version = b, this._typename = "ZipFile", this._throwError = JSIO.throwError;
        var j = this, k = function (a) {
            try {
                if (200 == a.req.status) {
                    var b = j.binaryStream.readNumber(4);
                    b != ZipFile.Signatures.Entry ? j.status.push("WARNING: this file does not appear to be a zip file") : (j.binaryStream.seek(0, JSIO.SeekOrigin.Begin), h(), j.verbose > 0 && j.status.push("INFO: read " + j.entries.length + " entries"))
                } else j.status.push("ERROR: the URL could not be read (" + a.req.status + " " + a.req.statusText + ")");
                e(j)
            } catch (c) {
                j.status.push("Exception: " + c.message), e(j)
            }
        };
        return this.binaryStream = new JSIO.BinaryUrlStream(d, k), this
    }, ZipFile.Signatures = {
        Entry: 67324752,
        EndOfCentralDirectory: 101010256,
        DirEntry: 33639248
    }, ZipFile.Version = b, ZipFile.EncryptionAlgorithm = {
        None: 0,
        PkzipWeak: 1,
        WinZipAes: 2
    }, ZipFile.ExtraFieldTypes = {}, ZipFile.ExtraFieldTypes[1] = "Zip64 Extended Info", ZipFile.ExtraFieldTypes[7] = "AV Info", ZipFile.ExtraFieldTypes[8] = "Extended Language Encoding Data (PFS)", ZipFile.ExtraFieldTypes[9] = "OS/2", ZipFile.ExtraFieldTypes[10] = "NTFS ", ZipFile.ExtraFieldTypes[12] = "OpenVMS", ZipFile.ExtraFieldTypes[13] = "UNIX", ZipFile.ExtraFieldTypes[14] = "File Stream and Fork Descriptors", ZipFile.ExtraFieldTypes[15] = "Patch Descriptor", ZipFile.ExtraFieldTypes[20] = "PKCS#7 Store for X.509 Certificates", ZipFile.ExtraFieldTypes[21] = "X.509 Certificate ID and Signature (Individual File)", ZipFile.ExtraFieldTypes[22] = "X.509 Certificate ID (Central Directory)", ZipFile.ExtraFieldTypes[23] = "Strong Encryption Header", ZipFile.ExtraFieldTypes[24] = "Record Management Controls", ZipFile.ExtraFieldTypes[25] = "PKCS#7 Encryption Recipient Certificate List", ZipFile.ExtraFieldTypes[101] = "IBM S/390 (Z390), AS/400 (I400) attributes (uncompressed)", ZipFile.ExtraFieldTypes[102] = "IBM S/390 (Z390), AS/400 (I400) attributes (compressed)", ZipFile.ExtraFieldTypes[18064] = "POSZIP 4690 (reserved) ", ZipFile.ExtraFieldTypes[1992] = "Macintosh", ZipFile.ExtraFieldTypes[9733] = "ZipIt Macintosh", ZipFile.ExtraFieldTypes[9989] = "ZipIt Macintosh 1.3.5+", ZipFile.ExtraFieldTypes[10245] = "ZipIt Macintosh 1.3.5+", ZipFile.ExtraFieldTypes[13133] = "Info-ZIP Macintosh", ZipFile.ExtraFieldTypes[17217] = "Acorn/SparkFS ", ZipFile.ExtraFieldTypes[17491] = "Windows NT security descriptor (binary ACL)", ZipFile.ExtraFieldTypes[18180] = "VM/CMS", ZipFile.ExtraFieldTypes[18191] = "MVS", ZipFile.ExtraFieldTypes[19270] = "FWKCS MD5", ZipFile.ExtraFieldTypes[19521] = "OS/2 access control list (text ACL)", ZipFile.ExtraFieldTypes[19785] = "Info-ZIP OpenVMS", ZipFile.ExtraFieldTypes[20300] = "Xceed original location extra field", ZipFile.ExtraFieldTypes[21334] = "AOS/VS (ACL)", ZipFile.ExtraFieldTypes[21589] = "extended timestamp", ZipFile.ExtraFieldTypes[21838] = "Xceed unicode extra field", ZipFile.ExtraFieldTypes[22613] = "Info-ZIP UNIX (original, also OS/2, NT, etc)", ZipFile.ExtraFieldTypes[25461] = "Info-ZIP Unicode Comment Extra Field", ZipFile.ExtraFieldTypes[25922] = "BeOS/BeBox", ZipFile.ExtraFieldTypes[28789] = "Info-ZIP Unicode Path Extra Field", ZipFile.ExtraFieldTypes[30062] = "ASi UNIX", ZipFile.ExtraFieldTypes[30805] = "Info-ZIP UNIX (new)", ZipFile.ExtraFieldTypes[41504] = "Microsoft Open Packaging Growth Hint", ZipFile.ExtraFieldTypes[64842] = "SMS/QDOS"
}(), ProjectedOverlay.prototype = new google.maps.OverlayView, ProjectedOverlay.prototype.createElement = function () {
    var a = this.getPanes(), b = this.div_;
    b || (b = this.div_ = document.createElement("div"), b.style.position = "absolute", b.setAttribute("id", this.id_), this.div_ = b, this.lastZoom_ = -1, this.percentOpacity_ && this.setOpacity(this.percentOpacity_), a.overlayLayer.appendChild(b))
}, ProjectedOverlay.prototype.remove = function () {
    this.div_ && (this.div_.parentNode.removeChild(this.div_), this.div_ = null, this.setMap(null))
}, ProjectedOverlay.prototype.draw = function (a) {
    if (this.createElement(), this.div_) {
        var b = this.get("projection").fromLatLngToDivPixel(this.bounds_.getSouthWest()), c = this.get("projection").fromLatLngToDivPixel(this.bounds_.getNorthEast());
        if (b && c && (this.div_.style.width = Math.abs(c.x - b.x) + "px", this.div_.style.height = Math.abs(c.y - b.y) + "px", this.div_.style.left = Math.min(c.x, b.x) + "px", this.div_.style.top = Math.min(c.y, b.y) + "px", this.lastZoom_ != this.map_.getZoom())) {
            this.lastZoom_ = this.map_.getZoom();
            var d = this.url_;
            this.addZ_ && (d += this.addZ_ + this.map_.getZoom()), this.div_.innerHTML = '<img src="' + d + '"  width=' + this.div_.style.width + " height=" + this.div_.style.height + " >"
        }
    }
}, ProjectedOverlay.prototype.setOpacity = function (a) {
    0 > a && (a = 0), a > 100 && (a = 100);
    var b = a / 100;
    "string" == typeof this.div_.style.filter && (this.div_.style.filter = "alpha(opacity:" + a + ")"), "string" == typeof this.div_.style.KHTMLOpacity && (this.div_.style.KHTMLOpacity = b), "string" == typeof this.div_.style.MozOpacity && (this.div_.style.MozOpacity = b), "string" == typeof this.div_.style.opacity && (this.div_.style.opacity = b)
}, function () {
    if ("object" == typeof JSIO) {
        var a = new Error("JSIO is already defined");
        throw a.source = "JSIO.core.js", a
    }
    JSIO = {}, JSIO.version = "2.0 2012Feb", JSIO.throwError = function (a, b, c) {
        var d = new Error("Error: " + a);
        throw d.source = (b || this._typename || "JSIO") + (c ? "." + c : ""), d
    }, JSIO.decimalToHexString = function (a, b) {
        0 > a && (a = 4294967295 + a + 1);
        var c = a.toString(16).toUpperCase();
        return b && (c = "00000000" + c, c = c.substring(c.length - b)), c
    }, JSIO.FileType = {Text: 0, Binary: 1, XML: 2, Unknown: 3}, JSIO.guessFileType = function (a) {
        if ("makefile" == a)return JSIO.FileType.Text;
        var b = a.lastIndexOf(".");
        if (0 >= b)return JSIO.FileType.Unknown;
        var c = a.substring(b);
        return ".zip" == c ? JSIO.FileType.Binary : ".xlsx" == c ? JSIO.FileType.Binary : ".docx" == c ? JSIO.FileType.Binary : ".dll" == c ? JSIO.FileType.Binary : ".obj" == c ? JSIO.FileType.Binary : ".pdb" == c ? JSIO.FileType.Binary : ".exe" == c ? JSIO.FileType.Binary : ".kmz" == c ? JSIO.FileType.Binary : ".xml" == c ? JSIO.FileType.XML : ".xsl" == c ? JSIO.FileType.XML : ".kml" == c ? JSIO.FileType.XML : ".csproj" == c ? JSIO.FileType.XML : ".vbproj" == c ? JSIO.FileType.XML : ".shfbproj" == c ? JSIO.FileType.XML : ".resx" == c ? JSIO.FileType.XML : ".xslt" == c ? JSIO.FileType.XML : ".sln" == c ? JSIO.FileType.Text : ".htm" == c ? JSIO.FileType.Text : ".html" == c ? JSIO.FileType.Text : ".js" == c ? JSIO.FileType.Text : ".vb" == c ? JSIO.FileType.Text : ".txt" == c ? JSIO.FileType.Text : ".rels" == c ? JSIO.FileType.Text : ".css" == c ? JSIO.FileType.Text : ".cs" == c ? JSIO.FileType.Text : ".asp" == c ? JSIO.FileType.Text : JSIO.FileType.Unknown
    }, JSIO.stringOfLength = function (a, b) {
        for (var c = "", d = 0; b > d; d++)c += String.fromCharCode(a);
        return c
    }, JSIO.formatByteArray = function (a) {
        for (var b = "0000  ", c = "", d = 0; d < a.length; d++)0 !== d && d % 16 === 0 && (b += "    " + c + "\n" + JSIO.decimalToHexString(d, 4) + "  ", c = ""), b += JSIO.decimalToHexString(a[d], 2) + " ", c += a[d] >= 32 && a[d] <= 126 ? String.fromCharCode(a[d]) : ".";
        return c.length > 0 && (b += JSIO.stringOfLength(32, (d % 16 > 0 ? 3 * (16 - d % 16) : 0) + 4) + c), b
    }, JSIO.htmlEscape = function (a) {
        return a.replace(new RegExp("&", "g"), "&amp;").replace(new RegExp("<", "g"), "&lt;").replace(new RegExp(">", "g"), "&gt;").replace(new RegExp("", "g"), "<br/>").replace(new RegExp("", "g"), "<br/>")
    }, JSIO.massApply = function (a, b, c, d) {
        var e = 65536;
        if (c.length < e)return a.apply(b, c);
        for (var f = b, g = 0, h = 65536; g < c.length;) {
            var i;
            c.subarray ? i = c.subarray(g, h) : c.slice && (i = c.slice(g, h)), d ? f += a.apply(f, i) : a.apply(b, i), g += e, h += e, h = Math.min(c.length, h)
        }
        return f
    }
}(), function () {
    var a = "2.0 2012Feb";
    "object" != typeof JSIO && (JSIO = {}), "string" != typeof JSIO.version ? JSIO.version = a : (JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && (JSIO.version += " " + a);
    var b = function () {
        this.position = 0
    };
    b.prototype._throwError = JSIO.throwError, b.prototype._limitCheck = function (a, b) {
        var c = {len: a, pos: b, end: b + a};
        return 0 === a ? {
            len: 0,
            pos: 0,
            end: 0
        } : (0 > a && this._throwError("Invalid read length"), this.length ? (!b >= 0 && (c.pos = this.position), this.length <= c.pos && this._throwError("EOF reached"), c.end = c.pos + a, this.length < c.end && (c.end = c.pos + (c.len = this.length - this.position)), c) : {
            len: a,
            pos: this.position,
            end: a + this.position
        })
    }, JSIO.SeekOrigin = {
        Begin: 0,
        Current: 1,
        End: 2,
        SEEK_SET: 0,
        SEEK_CUR: 1,
        SEEK_END: 2
    }, b.prototype.seek = function (a, b) {
        switch (b) {
            case JSIO.SeekOrigin.Begin:
                if (a == this.position)return this.position;
                if (this.length)this.length < a && this._throwError("Cannot seek past reader length", null, "seek"), this.position = a; else if (a < this.position)this._throwError("Uni-directional stream cannot seek backwards", null, "seek"); else if (a > this.position)return this.read(a - this.position);
                break;
            case JSIO.SeekOrigin.Current:
                return this.seek(this.position + a, JSIO.SeekOrigin.Begin);
            case JSIO.SeekOrigin.End:
                return this.length || this._throwError("Uni-directional stream has no known end length for seek", null, "seek"), this.seek(this.length - 1 + a, JSIO.SeekOrigin.Begin);
            default:
                this._throwError("Invalid seek method", null, "seek")
        }
        return this.position
    }, b.prototype.read = function (a, b) {
        var c = this._limitCheck(a, b);
        if (0 === c.len)return [];
        c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        var d = [];
        if (this.array && this.array.subarray)d = this.array.subarray(c.pos, c.end); else if (this.array && this.array.slice)d = this.array.slice(c.pos, c.end); else if (this.stream)d = this.stream.read(c.len, c.pos); else if (this.length)for (var e = c.pos; e < c.end; e++)d.push(this.readByteAt(e)); else for (var e = c.pos; e < c.end; e++) {
            var f = this.readByte();
            if (null === f || void 0 === f)break;
            d.push(f)
        }
        return this.position = c.end, d
    }, b.prototype.beginRead = function (a, b, c) {
        var d = this._limitCheck(a, b);
        if (0 === d.len)return setTimeout(function () {
            c([])
        }, 1);
        d.pos != this.position && this.seek(d.pos, JSIO.SeekOrigin.Begin);
        var e = [], f = this, g = d.len, h = function () {
            var a = 0, b = (f.position, g >= 32768 ? 32768 : g), d = f.read(b);
            JSIO.massApply(e.push, e, d), a += b, g -= b, d.length < b && (g = 0), g > 0 ? setTimeout(h, 1) : c(e)
        };
        return setTimeout(h, 1), null
    }, b.prototype.readToEnd = function () {
        return this.array && this.array.subarray ? this.array.subarray(this.position) : this.array && this.array.slice ? this.array.slice(this.position) : this.length ? this.read(this.length - this.position) : this.read(81e6)
    }, b.prototype.beginReadToEnd = function (a) {
        if (this.array && this.array.subarray)setTimeout(function () {
            a(this.array.subarray(this.position))
        }, 1); else {
            if (!this.array || !this.array.slice)return this.length ? this.beginRead(this.length - this.position, this.position, a) : this.beginRead(81e6, this.position, a);
            setTimeout(function () {
                a(this.array.slice(this.position))
            }, 1)
        }
    }, b.prototype.readByte = function () {
        if (this.length && this.position >= this.length)return null;
        var a;
        return a = this.array ? this.array[this.position++] : this.length ? this.readByteAt(this.position++) : this.stream ? this.stream.read(1)[0] : this.read(1)[0], null === a || void 0 === a ? null : a
    }, b.prototype.readByteAt = function (a) {
        var b = this.position;
        (null === a || void 0 === a) && (a = this.position);
        var c;
        return c = this.array ? this.array[a] : a === b ? this.readByte() : this.stream ? this.stream.read(1, a)[0] : this.read(1, a)[0], this.position = b, null === c || void 0 === c ? null : c
    }, b.prototype.readBytes = b.prototype.read, b.prototype.beginReadBytes = function (a, b) {
        return this.beginRead(a, this.position, b)
    }, b.prototype.readNumber = function (a, b) {
        var c = this._limitCheck(a, b);
        0 === c.len && (c.len = 1), c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        for (var d = 0, e = this.read(c.len, c.pos), f = e.length - 1; f >= 0; f--)d = 256 * d + e[f];
        return d
    }, b.prototype.readString = function (a, b) {
        var c = this._limitCheck(a, b);
        if (0 === c.len)return "";
        c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        for (var d = "", e = this.read(c.len, c.pos), f = 0; f < e.length; f++)d += String.fromCharCode(e[f]);
        return d
    }, b.prototype.readNullTerminatedString = function (a) {
        var b = a || this.position;
        this.length && this.length < b && this._throwError("EOF reached", null, "readNullTerminatedString"), b != this.position && this.seek(b, JSIO.SeekOrigin.Begin);
        var c = "", d = "", e = 0;
        if (this.array && this.array.indexOf) {
            var f = b - this.array.indexOf(0, b);
            if (f > 0)return this.readString(f, b)
        }
        for (var g; g = String.fromCharCode(this.readByteAt(b + e)), null !== g;)d += g, e++, e >= 32768 && (c += d, d = "", b += e, this.position += e, e = 0);
        return this.position = b + e, c + d
    }, b.prototype.beginReadNullTerminatedString = function (a, b) {
        var c = b || this.position;
        this.length && this.length < c && this._throwError("EOF reached", null, "beginReadNullTerminatedString");
        var d = "", e = "", f = this, g = function () {
            for (var b, h = 0; b = String.fromCharCode(this.readByteAt(c + h)), null !== b;)e += b, h++, h >= 32768 && (d += e, e = "", c += h, this.position += h, h = 0);
            f.position = c + h, null !== b ? setTimeout(g, 1) : a(d + e)
        };
        if (this.array && this.array.indexOf) {
            var h = c - this.array.indexOf(0, c);
            h > 0 && (readBatchASync = function () {
                a(f.readString(h, c))
            })
        }
        return setTimeout(g, 1), null
    }, JSIO._ByteReaderBase = b;
    var c = function (b) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.ArrayReader", "ctor"), this.position = 0, this.array = b, this.length = b.length, this._typename = "JSIO.ArrayReader", this._version = a, this
    };
    c.prototype = new JSIO._ByteReaderBase, c.prototype.readByte = function () {
        return this.position >= this.array.length ? null : this.array[this.position++]
    }, c.prototype.readByteAt = function (a) {
        return this.array[a]
    };
    var d = function (b, d, e) {
        if (this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.StreamSegmentReader", "ctor"), b || this._throwError("You must pass a non-null stream", "JSIO.StreamSegmentReader", "ctor"), d >= 1 || (d = 0), e >= 1 || (e = 0), this.stream = b, this.array = null, b.array) {
            var f = e ? d + e : null;
            b.array.subarray ? this.array = b.array.subarray(d, f) : b.array.slice && (this.array = b.array.slice(d, f))
        }
        return this.length = this.array ? this.array.length : b.length ? b.length - d : null, this.offset = d, this.limit = e, this.position = 0, this._typeName = "JSIO.StreamSegmentReader", this._version = a, this.array && (this.readByte = c.prototype.readByte, this.readByteAt = c.prototype.readByteAt), this
    };
    d.prototype = new JSIO._ByteReaderBase, d.prototype.readByte = function () {
        return this.limit && this.position >= this.limit ? null : (this.position++, this.stream.readByteAt(this.offset + this.position - 1))
    }, d.prototype.readByteAt = function (a) {
        return this.limit && a >= this.limit ? null : this.stream.readByteAt(this.offset + a)
    }, JSIO.ArrayReader = c, JSIO.StreamReader = d, JSIO.StreamSegmentReader = d
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.BinaryUrlStream";
    if (("object" != typeof JSIO || "string" != typeof JSIO.version || JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && JSIO.throwError("This extension requires JSIO.core.js v2.0", b), "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        var c = "<!-- IEBinaryToArray_ByteStr -->\r\n<script type='text/vbscript'>\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteAsc_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n      IEBinaryToArray_ByteAsc_Last = AscB( MidB( Binary, lastIndex, 1 ) )\r\n   Else\r\n      IEBinaryToArray_ByteAsc_Last = -1\r\n   End If\r\nEnd Function\r\n</script>\r\n";
        document.write(c)
    }
    JSIO.IEByteMapping = null;
    var d = function (c, d) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.BinaryUrlStream", "ctor"), this.callback = d, this.position = 0, this.length = null, this.readByte = JSIO.ArrayReader.prototype.readByte, this.readByteAt = JSIO.ArrayReader.prototype.readByteAt, this.req = null, this._typename = b, this._version = a, this.status = "-none-";
        var e = function (a) {
            var b = this, c = function (a) {
                var b = new Array;
                try {
                    b = new VBArray(a).toArray()
                } catch (c) {
                    if (!JSIO.IEByteMapping) {
                        JSIO.IEByteMapping = {};
                        for (var d = 0; 256 > d; d++)for (var e = 0; 256 > e; e++)JSIO.IEByteMapping[String.fromCharCode(d + 256 * e)] = [d, e]
                    }
                    for (var f = IEBinaryToArray_ByteStr(a), g = IEBinaryToArray_ByteAsc_Last(a), d = 0; d < f.length; d++)b.push.apply(b, JSIO.IEByteMapping[f.substr(d, 1)]);
                    g >= 0 && b.push(g)
                }
                return b
            };
            this.req = function () {
                if (window.XMLHttpRequest)return new window.XMLHttpRequest;
                if (window.ActiveXObject)for (var a = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP"], b = 0; b < a.length; b++)try {
                    return new ActiveXObject(a[b])
                } catch (c) {
                    continue
                }
                return null
            }(), this.req.open("GET", a, !0), this.req.setRequestHeader("Accept-Charset", "x-user-defined"), this.req.onreadystatechange = function (d) {
                4 == b.req.readyState && (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status ? (b.array = c(b.req.responseBody), b.length = b.array.length, b.length < 0 && this._throwError('Failed to load "' + a + '" after converting'), "function" == typeof b.callback && b.callback(b)) : b._throwError('Failed to load "' + a + '": HTTP ' + b.status))
            }, this.req.send()
        }, f = function (a) {
            var b = this;
            this.req = new XMLHttpRequest, this.req.open("GET", a, !0), this.req.onreadystatechange = function (c) {
                if (4 == b.req.readyState)if (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status) {
                    var d = b.req.responseText;
                    b.length = d.byteLength, b.array = d.split("");
                    for (var e = 0; e < b.array.length; e++)b.array[e] = 255 & b.array[e].charCodeAt(0);
                    "function" == typeof b.callback && b.callback(b)
                } else b._throwError('Failed to load "' + a + '": HTTP ' + b.status)
            }, this.req.overrideMimeType && this.req.overrideMimeType("text/plain; charset=x-user-defined"), this.req.send(null)
        }, g = function (a) {
            var b = this;
            this.req = new XMLHttpRequest, this.req.open("GET", a, !0), this.req.onreadystatechange = function (c) {
                if (4 == b.req.readyState)if (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status) {
                    var d = b.req.response;
                    b.length = d.byteLength, b.array = new Uint8Array(d), "function" == typeof b.callback && b.callback(b)
                } else b._throwError('Failed to load "' + a + '": HTTP ' + b.status)
            }, this.req.responseType = "arraybuffer", this.req.overrideMimeType && this.req.overrideMimeType("application/octet-stream; charset=x-user-defined"), this.req.send(null)
        };
        "undefined" != typeof ArrayBuffer ? g.apply(this, [c]) : /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? e.apply(this, [c]) : f.apply(this, [c])
    };
    d.prototype = new JSIO._ByteReaderBase, d.prototype.readByte = function () {
        var a = this.readByteAt(this.position++);
        return null === a || void 0 === a ? null : a
    }, JSIO.BinaryUrlStream = d
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.TextDecoder";
    ("object" != typeof JSIO || "string" != typeof JSIO.version || JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && JSIO.throwError("This extension requires JSIO.core.js v2.0", b), "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b);
    var c = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.ANSI", "ctor"), this.byteReader = c, this.charWidth = 1, this._version = a, this._typename = b + ".ANSI", this
    };
    c.prototype.readChar = function () {
        var a = this.byteReader.readByte();
        return 0 > a ? null : String.fromCharCode(a)
    }, c.prototype.parseChar = function (a) {
        return 0 > a ? null : String.fromCharCode(a)
    };
    var d = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.UTF16", "ctor"), this.byteReader = c, this.charWidth = 2, this.bomState = 0, this._version = a, this._typename = b + ".UTF16", this
    };
    d.prototype.readChar = function () {
        var a = this.byteReader.readByte();
        if (0 > a)return null;
        var b = this.byteReader.readByte();
        if (0 > b && this._throwError("Incomplete UTF16 character", null, "readChar"), 0 === this.bomState && a + b == 509) {
            if (this.bomState = 254 == b ? 1 : 2, a = this.byteReader.readByte(), 0 > a)return null;
            b = this.byteReader.readByte(), 0 > b && this._throwError("Incomplete UTF16 character", null, "readChar")
        } else this.bomState = 1;
        return this.parseChar(a, b)
    }, d.prototype.parseChar = function (a, b) {
        return String.fromCharCode(1 == this.bomState ? b << 8 | a : a << 8 | b)
    };
    var e = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.UTF8", "ctor"), this.byteReader = c, this.charWidth = null, this.waitBom = !0, this.strict = !1, this.pendingChar = null, this._version = a, this._typename = b + ".UTF8", this
    };
    e.prototype.readChar = function () {
        var a = null;
        do {
            if (null !== this.pendingChar)a = this.pendingChar, this.pendingChar = null; else {
                var b = this.byteReader.readByte();
                if (null === b)return null;
                if (0 === (128 & b))a = String.fromCharCode(b); else {
                    var c = 192, d = 0;
                    do {
                        var e = c >> 1 | 128;
                        if ((b & e) == c)break;
                        c = c >> 1 | 128
                    } while (++d < 5);
                    if (d > 0) {
                        var f;
                        if (1 === d)f = (31 & b) << 6 | 63 & this.byteReader.readByte(); else {
                            f <<= 6 * d;
                            for (var g = this.byteReader.read(d), h = 0; h > d; h++) {
                                var i = g[h];
                                128 != (192 & i) && this._throwError("Invalid sequence character", null, "readChar"), f = f << 6 | 63 & i
                            }
                        }
                        if (65535 >= f)a = 65279 == f && this.waitBom ? null : String.fromCharCode(f); else {
                            var j = f - 65536, k = 55296 | j >> 10 & 1023, l = 56320 | 1023 & j;
                            this.pendingChar = String.fromCharCode(l), a = String.fromCharCode(k)
                        }
                    } else this.strict ? this._throwError("Invalid character", null, "readChar") : a = String.fromCharCode(b)
                }
            }
            this.waitBom = !1
        } while (null === a);
        return a
    }, JSIO.TextDecoder = {Default: c, ANSI: c, UTF16: d, UTF8: e}
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.TextReader";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b);
    var c = function (c) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), this.decoder = c, this._version = a, this._typename = b, this.unreads = []
    };
    c.prototype.readChar = function () {
        return this.unreads.length > 0 ? this.unreads.pop() : this.decoder.readChar()
    }, c.prototype.read = function (a) {
        if (1 === this.decoder.charWidth)return JSIO.massApply(String.fromCharCode, new String, this.decoder.byteReader.read(a), !0);
        var b = "";
        for (vari = 0; i < a; i++) {
            var c = this.readChar();
            if (null === c)break;
            b += c
        }
        return b
    }, c.prototype.unreadChar = function (a) {
        this.unreads.push(a)
    }, c.prototype.readToEnd = function () {
        if (1 === this.decoder.charWidth)return JSIO.massApply(String.fromCharCode, new String, this.decoder.byteReader.readToEnd(n), !0);
        for (var a = "", b = "", c = 0, d = this.readChar(); null !== d;)b += d, c++, c >= 32768 && (a += b, b = "", c = 0), d = this.readChar();
        return a + b
    }, c.prototype.beginReadToEnd = function (a) {
        if (1 === this.decoder.charWidth)return this.decoder.byteReader.beginReadToEnd(function (b) {
            a(JSIO.massApply(String.fromCharCode, new String, b, !0))
        }), null;
        var b = "", c = "", d = this, e = function () {
            for (var f = 0, g = d.readChar(); null !== g;) {
                if (c += g, f++, f >= 32768) {
                    b += c, c = "";
                    break
                }
                g = d.readChar()
            }
            null !== g ? setTimeout(e, 1) : a(b + c)
        };
        return setTimeout(e, 1), null
    }, c.prototype.readLine = function () {
        var a = "", b = this.readChar();
        if (null === b)return null;
        for (; "\r" != b && "\n" != b;)if (a += b, b = this.readChar(), null === b)return a;
        return "\r" == b && (b = this.readChar(), null !== b && "\n" != b && this.unreadChar(b)), a
    }, JSIO.TextReader = c
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.Crc32";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), JSIO.crc32Table = null, JSIO.crc32Polynomial = 3988292384;
    var c = function () {
        if (!JSIO.crc32Table) {
            JSIO.crc32Table = new Array(256);
            for (var a = 0; 256 > a; a++) {
                for (var b = a, c = 0; 8 > c; c++)1 == (1 & b) ? b = JSIO.crc32Polynomial ^ b >>> 1 : b >>>= 1;
                JSIO.crc32Table[a] = b
            }
        }
    };
    JSIO.computeCrc32 = function (a) {
        c();
        var b = 4294967295, d = a.length;
        if ("object" == typeof a)for (var e = 0; d > e; e++)b = JSIO.crc32Table[255 & b ^ a[e]] ^ b >>> 8; else for (var f = 0; d > f; f++)b = JSIO.crc32Table[255 & b ^ a.charCodeAt(f)] ^ b >>> 8;
        return b ^= 4294967295, 0 > b && (b += 4294967296), b
    };
    var d = function () {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), c(), this._typename = b, this._version = a, this._runningCrc32 = 4294967295
    };
    d.prototype.slurpByte = function (a) {
        var b = this._runningCrc32;
        this._runningCrc32 = b >>> 8 ^ JSIO.crc32Table[a ^ 255 & b]
    }, d.prototype.result = function () {
        var a = 4294967295 ^ this._runningCrc32;
        return 0 > a && (a += 4294967296), a
    };
    var e = function (b) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.Crc32Reader", "ctor"), this._byteReader = b, this._typename = "JSIO.Crc32Reader", this._version = a, this._crc32 = new JSIO.Crc32
    };
    e.prototype = new JSIO._ByteReaderBase, e.prototype.readByte = function () {
        var a = this._byteReader.readByte();
        return null !== a && this._crc32.slurpByte(a), this.position++, a
    }, e.prototype.read = function (a) {
        if (0 === a)return [];
        var b = this._byteReader.read(a);
        a = b.length;
        for (var c, d = JSIO.crc32Table, e = this._crc32._runningCrc32, f = 0; a > f; f++)c = d[b[f] ^ 255 & e], e = e >>> 8 ^ c;
        return this._crc32._runningCrc32 = e, this.position += a, b
    }, e.prototype.crc32 = function () {
        return this._crc32.result()
    }, JSIO.Crc32 = d, JSIO.Crc32Reader = e
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.InflatingReader";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), JSIO.bitShiftTable = null;
    var c = function () {
        if (!JSIO.bitShiftTable) {
            var a = 8;
            JSIO.bitShiftTable = {LSB: new Array(a), MSB: new Array(a)};
            for (var b = 0; a > b; b++) {
                var c = a - b;
                JSIO.bitShiftTable.LSB[b] = new Array(c), JSIO.bitShiftTable.MSB[b] = new Array(c);
                for (var d = 1 << b, e = 1 << c - 1, f = 1; c >= f; f++)JSIO.bitShiftTable.LSB[b][f - 1] = d, JSIO.bitShiftTable.MSB[b][f - 1] = e, d |= 1 << b + f, e |= 1 << c - f - 1
            }
        }
    }, d = function (d) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b + "._InternalBitReader.ctor"), this.bitsLength = 0, this.bits = 0, this.byteReader = d, this._typeName = b + "._InternalBitReader", this._version = a, c()
    };
    d.prototype._throwError = JSIO.throwError, d.prototype.readBit = function () {
        if (0 === this.bitsLength) {
            var a = this.byteReader.readByte();
            null === a && this._throwError("Unexpected end of stream", null, "readBit"), this.bits = a, this.bitsLength = 8
        }
        var b = 0 !== (this.bits & 1 << 8 - this.bitsLength);
        return this.bitsLength--, b
    }, d.prototype.align = function () {
        this.bitsLength = 0
    }, d.prototype.readBits = function (a, b) {
        var c = 0;
        b = b || "LSB";
        for (var d = JSIO.bitShiftTable[b], e = 0; a > 0;) {
            if (0 === this.bitsLength) {
                var f = this.byteReader.readByte();
                null === f && this._throwError("Unexpected end of stream", null, "read" + b), this.bits = f, this.bitsLength = 8
            }
            var g = this.bitsLength >= a ? a : this.bitsLength, h = 8 - this.bitsLength;
            c |= (this.bits & d[h][g - 1]) >>> h << e, e += g, a -= g, this.bitsLength -= g
        }
        return c
    }, d.prototype.readLSB = function (a) {
        return this.readBits(a, "LSB")
    }, d.prototype.readMSB = function (a) {
        return this.readBits(a, "MSB")
    };
    var e = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), this._byteReader = c, this._bitReader = new d(c), this._buffer = [], this._bufferPosition = 0, this._state = 0, this._blockFinal = !1, this._typeName = b, this._version = a, this
    }, f = null, g = null, h = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], i = function (a) {
        var b = 0, c = new Array(a.length), d = a[0];
        for (b = 1; b < a.length; b++)d < a[b] && (d = a[b]);
        var e = new Array(d + 1);
        for (b = 0; d >= b; b++)e[b] = 0;
        for (b = 0; b < a.length; b++)++e[a[b]];
        var f = new Array(d + 1), g = 0;
        e[0] = 0;
        for (var h = 1; d >= h; h++)g = g + e[h - 1] << 1, f[h] = g;
        for (b = 0; b < c.length; b++) {
            var i = a[b];
            0 !== i && (c[b] = f[i], f[i]++)
        }
        return c
    }, j = function (a, b) {
        for (var c = [], d = 0; d < a.length; ++d)if (b[d] > 0) {
            var e = {};
            e.bits = a[d], e.length = b[d], e.index = d, c.push(e)
        }
        return k(c, 0, 0)
    }, k = function (a, b, c) {
        if (0 === a.length)return null;
        var d = [], e = [], f = {};
        f.isLeaf = !1;
        for (var g = 0; g < a.length; ++g) {
            if (a[g].length == c && a[g].bits == b) {
                f.isLeaf = !0, f.index = a[g].index;
                break
            }
            var h = (a[g].bits >> a[g].length - c - 1 & 1) > 0;
            h ? e.push(a[g]) : d.push(a[g])
        }
        return f.isLeaf || (f.zero = k(d, b << 1, c + 1), f.one = k(e, b << 1 | 1, c + 1)), f
    }, l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], m = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], n = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], o = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], p = function (a) {
        var b, c = a.readLSB(5) + 257, d = a.readLSB(5) + 1, e = a.readLSB(4) + 4, f = new Array(19);
        for (b = 0; b < f.length; b++)f[b] = 0;
        for (b = 0; e > b; b++)f[h[b]] = a.readLSB(3);
        for (var g = i(f), k = j(g, f), l = []; l.length < c + d;) {
            for (var m = k; !m.isLeaf;)m = a.readBit() ? m.one : m.zero;
            var n = m.index;
            if (15 >= n)l.push(n); else if (16 == n)for (var o = a.readLSB(2) + 3, p = 0; o > p; ++p)l.push(l[l.length - 1]); else if (17 == n)for (var q = a.readLSB(3) + 3, r = 0; q > r; ++r)l.push(0); else if (18 == n)for (var s = a.readLSB(7) + 11, t = 0; s > t; ++t)l.push(0)
        }
        var u = l.slice(0, c), v = i(u), w = l.slice(c, c + d), x = i(w);
        return {codesTree: j(v, u), distancesTree: j(x, w)}
    };
    e.prototype = new JSIO._ByteReaderBase, e.prototype._decodeItem = function () {
        if (2 == this._state)return null;
        var a;
        if (0 === this._state) {
            this._blockFinal = this._bitReader.readBit();
            var b = this._bitReader.readLSB(2);
            switch (b) {
                case 0:
                    this._bitReader.align();
                    var c = this._bitReader.readLSB(16), d = this._bitReader.readLSB(16);
                    return (c & ~d) != c && this._throwError("Invalid block type 0 length", null, "_decodeItem"), a = {}, a.itemType = 0, a.array = this._bitReader.byteReader.read(c), a.array.length < c && this._throwError("Incomplete block", null, "_decodeItem"), this._blockFinal && (this._state = 2), a;
                case 1:
                    this._codesTree = f, this._distancesTree = g, this._state = 1;
                    break;
                case 2:
                    var e = p(this._bitReader);
                    this._codesTree = e.codesTree, this._distancesTree = e.distancesTree, this._state = 1;
                    break;
                default:
                    this._throwError("Invalid block type (" + b + ")", null, "_decodeItem")
            }
        }
        a = {};
        for (var h = this._codesTree; !h.isLeaf;)h = this._bitReader.readBit() ? h.one : h.zero;
        if (h.index < 256)a.itemType = 2, a.symbol = h.index; else if (h.index > 256) {
            var i = h.index;
            i > 285 && this._throwError("Invalid length code", null, "_decodeItem");
            var j = l[i - 257];
            for (m[i - 257] > 0 && (j += this._bitReader.readLSB(m[i - 257])), h = this._distancesTree; !h.isLeaf;)h = this._bitReader.readBit() ? h.one : h.zero;
            var k = h.index, q = n[k];
            o[k] > 0 && (q += this._bitReader.readLSB(o[k])), a.itemType = 3, a.distance = q, a.length = j
        } else a.itemType = 1, this._state = this._blockFinal ? 2 : 0;
        return a
    }, e.prototype.readByte = function () {
        var a = this.read(1)[0];
        return null === a || void 0 === a ? null : a
    }, e.prototype.read = function (a) {
        for (var b = this._buffer; this._bufferPosition + a > b.length;) {
            var c = this._decodeItem();
            if (null === c) {
                a = b.length - this._bufferPosition;
                break
            }
            switch (c.itemType) {
                case 0:
                    JSIO.massApply(b.push, b, c.array);
                    break;
                case 2:
                    b.push(c.symbol);
                    break;
                case 3:
                    var d = b.length - c.distance;
                    if (c.distance >= c.length)JSIO.massApply(b.push, b, b.slice(d, d + c.length)); else {
                        for (var e = parseInt(c.length / c.distance), f = b.slice(d); e > 0;)1 & e && JSIO.massApply(b.push, b, f), (e >>= 1) && JSIO.massApply(f.push, f, f);
                        var g;
                        (g = c.length % c.distance) && JSIO.massApply(b.push, b, b.slice(d, d + g))
                    }
            }
        }
        var h = b.slice(this._bufferPosition, this._bufferPosition + a);
        if (this._bufferPosition += a, this.position += a, this._bufferPosition > 49152) {
            var i = b.length - 32768;
            i > this._bufferPosition && (i = this._bufferPosition), b.splice(0, i), this._bufferPosition -= i
        }
        return h
    }, function () {
        var a = new Array(288), b = new Array(288), c = 0;
        for (c = 0; 143 >= c; c++)a[c] = 48 + c, b[c] = 8;
        for (c = 144; 255 >= c; c++)a[c] = 400 + c - 144, b[c] = 9;
        for (c = 256; 279 >= c; c++)a[c] = 0 + c - 256, b[c] = 7;
        for (c = 280; 287 >= c; c++)a[c] = 192 + c - 280, b[c] = 8;
        f = j(a, b);
        var d = new Array(32), e = new Array(32);
        for (c = 0; 31 >= c; c++)d[c] = c, e[c] = 5;
        g = j(d, e)
    }(), JSIO.InflatingReader = e
}(), function () {
    function a(a) {
        this.zipfile = a, this._typename = "ZipEntry", this._version = b, this._crcCalculator = null
    }

    var b = "2.0 2012Feb", c = "Zipfile";
    "function" != typeof JSIO.BinaryUrlStream && JSIO.throwError("This extension requires JSIO.BinaryUrlStream.js v2.0", c), "object" != typeof JSIO.TextDecoder && JSIO.throwError("This extension requires JSIO.TextDecoder.js v2.0", c), "function" != typeof JSIO.TextReader && JSIO.throwError("This extension requires JSIO.TextReader.js v2.0", c), "function" != typeof JSIO.Crc32 && JSIO.throwError("This extension requires JSIO.Crc32.js v2.0", c), "function" != typeof JSIO.InflatingReader && JSIO.throwError("This extension requires JSIO.InflatingReader.js v2.0", c), a.prototype._throwError = JSIO.throwError, a.prototype.extract = function (a, b) {
        this.contentType = JSIO.guessFileType(this.name), b = b || this.contentType == JSIO.FileType.Text || this.contentType == JSIO.FileType.XML;
        var c = this;
        0 !== this.compressionMethod && 8 != this.compressionMethod && this._throwError("Unsupported compression method: " + this.compressionMethod, null, "extract");
        var d = b ? this.openTextReader(c.utf8 ? JSIO.TextDecoder.UTF8 : JSIO.TextDecoder.ANSI) : this.openBinaryReader();
        if (d.zipEntryName = c.name, "function" != typeof a) {
            var e = d.readToEnd();
            return this.verifyCrc32(), e
        }
        return d.beginReadToEnd(function (b) {
            try {
                c.verifyCrc32(), a(c, b)
            } catch (d) {
                a(c, d)
            }
        }), null
    }, a.prototype.openBinaryReader = function () {
        var a = new JSIO.StreamSegmentReader(this.zipfile.binaryStream, this.offset + this.lengthOfHeader, this.compressedSize);
        if (0 === this.compressionMethod)this._crcCalculator = new JSIO.Crc32Reader(a); else {
            var b = new JSIO.InflatingReader(a);
            this._crcCalculator = new JSIO.Crc32Reader(b)
        }
        return this._crcCalculator
    }, a.prototype.openTextReader = function (a) {
        var b = this.openBinaryReader();
        a = a || JSIO.TextDecoder.UTF8;
        var c = new a(b), d = new JSIO.TextReader(c);
        return c._parent = d, d
    }, a.prototype.verifyCrc32 = function () {
        var a = this._crcCalculator.crc32(), b = !1;
        if (this.crc32 != a) {
            var c = "WARNING: CRC check failed: entry(" + this.name + ") computed(" + JSIO.decimalToHexString(a, 8) + ") expected(" + JSIO.decimalToHexString(this.crc32, 8) + ") ";
            this.zipfile.status.push(c)
        } else b = !0, this.zipfile.verbose > 2 && this.zipfile.status.push("INFO: CRC check ok: 0x" + JSIO.decimalToHexString(this.crc32, 8));
        return b
    }, ZipFile = function (d, e, f) {
        function g(a) {
            if (65535 == a || 0 === a)return new Date(1995, 0, 1, 0, 0, 0, 0);
            var b = 65535 & a, c = (4294901760 & a) >> 16, d = 1980 + ((65024 & c) >> 9), e = ((480 & c) >> 5) - 1, f = 31 & c, g = (63488 & b) >> 11, h = (2016 & b) >> 5, i = 2 * (31 & b);
            i >= 60 && (h++, i = 0), h >= 60 && (g++, h = 0), g >= 24 && (f++, g = 0);
            var j, k = !1;
            try {
                j = new Date(d, e, f, g, h, i, 0), k = !0
            } catch (l) {
                if (1980 != d || 0 !== e && 0 !== f)try {
                    1980 > d && (d = 1980), d > 2030 && (d = 2030), 1 > e && (e = 1), e > 12 && (e = 12), 1 > f && (f = 1), f > 31 && (f = 31), 0 > h && (h = 0), h > 59 && (h = 59), 0 > i && (i = 0), i > 59 && (i = 59), j = new Date(d, e - 1, f, g, h, i, 0), k = !0
                } catch (m) {
                } else try {
                    j = new Date(1980, 0, 1, g, h, i, 0), k = !0
                } catch (n) {
                    try {
                        j = new Date(1980, 0, 1, 0, 0, 0, 0), k = !0
                    } catch (o) {
                    }
                }
            }
            return k || this._throwError("Bad date/time value in this ZIP file", null, "DateFromPackedFormat"), j
        }

        function h() {
            if (0 === j.entryNames.length)for (var a; null !== (a = i());)j.entries.push(a), j.entryNames.push(a.name)
        }

        function i() {
            var b = j.binaryStream.position, c = j.binaryStream.readNumber(4);
            if (c == ZipFile.Signatures.DirEntry)return j.verbose > 0 && j.status.push("INFO: at offset 0x" + JSIO.decimalToHexString(b) + ", found start of Zip Directory."), null;
            if (c != ZipFile.Signatures.Entry)return j.status.push("WARNING: at offset 0x" + JSIO.decimalToHexString(b) + ", found unexpected signature: 0x" + JSIO.decimalToHexString(c)), null;
            var d = new a(j);
            d.offset = b, d.versionNeeded = j.binaryStream.readNumber(2), d.bitField = j.binaryStream.readNumber(2), d.compressionMethod = j.binaryStream.readNumber(2);
            var e = j.binaryStream.readNumber(4);
            if (d.lastModified = g(e), d.crc32 = j.binaryStream.readNumber(4), d.compressedSize = j.binaryStream.readNumber(4), d.uncompressedSize = j.binaryStream.readNumber(4), 1 == (1 & d.bitField))return j.status.push("This zipfile uses Encryption, which is not supported by ZipFile.js."), null;
            if (d.utf8 = 2048 == (2048 & d.bitField), 8 == (8 & d.bitField))return j.status.push("This zipfile uses a bit 3 trailing data descriptor, which is not supported by ZipFile.js."), null;
            if (4294967295 == d.compressedSize || 4294967295 == d.uncompressedSize)return j.status.push("This zipfile uses ZIP64, which is not supported by ZipFile.js"), null;
            var f = j.binaryStream.readNumber(2), h = j.binaryStream.readNumber(2);
            j.status.push("INFO: filename length= " + f);
            var i = 30 + f + h;
            if (d.utf8) {
                j.status.push("INFO: before filename, position= 0x" + JSIO.decimalToHexString(j.binaryStream.position));
                var k = new JSIO.StreamSegmentReader(j.binaryStream, j.binaryStream.position, f), l = new JSIO.TextDecoder.UTF8(k), m = new JSIO.TextReader(l);
                d.name = m.readToEnd(), j.binaryStream.seek(f, JSIO.SeekOrigin.Current, j), j.status.push("INFO: after filename, position= 0x" + JSIO.decimalToHexString(j.binaryStream.position))
            } else d.name = j.binaryStream.readString(f);
            var n = 0;
            for (d.extra = []; h > n;) {
                var o = {type: j.binaryStream.readNumber(2), size: j.binaryStream.readNumber(2)};
                o.typeDescription = ZipFile.ExtraFieldTypes[o.type], o.data = j.binaryStream.read(o.size), d.extra.push(o), n += 4 + o.size
            }
            return j.verbose > 1 && j.status.push("INFO: at offset 0x" + JSIO.decimalToHexString(d.offset) + ", found entry '" + d.name + "' fnl(" + f + ") efl(" + h + ")"), h > 0 && j.verbose > 0 && j.status.push("INFO: entry " + d.name + " has " + h + " bytes of extra metadata (ID'd but ignored)"), d.lengthOfHeader = i, d.totalEntrySize = d.lengthOfHeader + d.compressedSize, j.verbose > 1 && j.status.push("INFO: seek 0x" + JSIO.decimalToHexString(d.compressedSize) + " (" + d.compressedSize + ") bytes"), j.binaryStream.seek(d.compressedSize, JSIO.SeekOrigin.Current, j), d
        }

        this instanceof arguments.callee || JSIO.throwError("You must use new to instantiate this class", c, "ctor"), this.verbose = f || 0, this.entries = [], this.entryNames = [], this.status = [], this._version = b, this._typename = "ZipFile", this._throwError = JSIO.throwError;
        var j = this, k = function (a) {
            try {
                if (200 == a.req.status) {
                    var b = j.binaryStream.readNumber(4);
                    b != ZipFile.Signatures.Entry ? j.status.push("WARNING: this file does not appear to be a zip file") : (j.binaryStream.seek(0, JSIO.SeekOrigin.Begin), h(), j.verbose > 0 && j.status.push("INFO: read " + j.entries.length + " entries"))
                } else j.status.push("ERROR: the URL could not be read (" + a.req.status + " " + a.req.statusText + ")");
                e(j)
            } catch (c) {
                j.status.push("Exception: " + c.message), e(j)
            }
        };
        return this.binaryStream = new JSIO.BinaryUrlStream(d, k), this
    }, ZipFile.Signatures = {
        Entry: 67324752,
        EndOfCentralDirectory: 101010256,
        DirEntry: 33639248
    }, ZipFile.Version = b, ZipFile.EncryptionAlgorithm = {
        None: 0,
        PkzipWeak: 1,
        WinZipAes: 2
    }, ZipFile.ExtraFieldTypes = {}, ZipFile.ExtraFieldTypes[1] = "Zip64 Extended Info", ZipFile.ExtraFieldTypes[7] = "AV Info", ZipFile.ExtraFieldTypes[8] = "Extended Language Encoding Data (PFS)", ZipFile.ExtraFieldTypes[9] = "OS/2", ZipFile.ExtraFieldTypes[10] = "NTFS ", ZipFile.ExtraFieldTypes[12] = "OpenVMS", ZipFile.ExtraFieldTypes[13] = "UNIX", ZipFile.ExtraFieldTypes[14] = "File Stream and Fork Descriptors", ZipFile.ExtraFieldTypes[15] = "Patch Descriptor", ZipFile.ExtraFieldTypes[20] = "PKCS#7 Store for X.509 Certificates", ZipFile.ExtraFieldTypes[21] = "X.509 Certificate ID and Signature (Individual File)", ZipFile.ExtraFieldTypes[22] = "X.509 Certificate ID (Central Directory)", ZipFile.ExtraFieldTypes[23] = "Strong Encryption Header", ZipFile.ExtraFieldTypes[24] = "Record Management Controls", ZipFile.ExtraFieldTypes[25] = "PKCS#7 Encryption Recipient Certificate List", ZipFile.ExtraFieldTypes[101] = "IBM S/390 (Z390), AS/400 (I400) attributes (uncompressed)", ZipFile.ExtraFieldTypes[102] = "IBM S/390 (Z390), AS/400 (I400) attributes (compressed)", ZipFile.ExtraFieldTypes[18064] = "POSZIP 4690 (reserved) ", ZipFile.ExtraFieldTypes[1992] = "Macintosh", ZipFile.ExtraFieldTypes[9733] = "ZipIt Macintosh", ZipFile.ExtraFieldTypes[9989] = "ZipIt Macintosh 1.3.5+", ZipFile.ExtraFieldTypes[10245] = "ZipIt Macintosh 1.3.5+", ZipFile.ExtraFieldTypes[13133] = "Info-ZIP Macintosh", ZipFile.ExtraFieldTypes[17217] = "Acorn/SparkFS ", ZipFile.ExtraFieldTypes[17491] = "Windows NT security descriptor (binary ACL)", ZipFile.ExtraFieldTypes[18180] = "VM/CMS", ZipFile.ExtraFieldTypes[18191] = "MVS", ZipFile.ExtraFieldTypes[19270] = "FWKCS MD5", ZipFile.ExtraFieldTypes[19521] = "OS/2 access control list (text ACL)", ZipFile.ExtraFieldTypes[19785] = "Info-ZIP OpenVMS", ZipFile.ExtraFieldTypes[20300] = "Xceed original location extra field", ZipFile.ExtraFieldTypes[21334] = "AOS/VS (ACL)", ZipFile.ExtraFieldTypes[21589] = "extended timestamp", ZipFile.ExtraFieldTypes[21838] = "Xceed unicode extra field", ZipFile.ExtraFieldTypes[22613] = "Info-ZIP UNIX (original, also OS/2, NT, etc)", ZipFile.ExtraFieldTypes[25461] = "Info-ZIP Unicode Comment Extra Field", ZipFile.ExtraFieldTypes[25922] = "BeOS/BeBox", ZipFile.ExtraFieldTypes[28789] = "Info-ZIP Unicode Path Extra Field", ZipFile.ExtraFieldTypes[30062] = "ASi UNIX", ZipFile.ExtraFieldTypes[30805] = "Info-ZIP UNIX (new)", ZipFile.ExtraFieldTypes[41504] = "Microsoft Open Packaging Growth Hint", ZipFile.ExtraFieldTypes[64842] = "SMS/QDOS"
}(), ProjectedOverlay.prototype = new google.maps.OverlayView, ProjectedOverlay.prototype.createElement = function () {
    var a = this.getPanes(), b = this.div_;
    b || (b = this.div_ = document.createElement("div"), b.style.position = "absolute", b.setAttribute("id", this.id_), this.div_ = b, this.lastZoom_ = -1, this.percentOpacity_ && this.setOpacity(this.percentOpacity_), a.overlayLayer.appendChild(b))
}, ProjectedOverlay.prototype.remove = function () {
    this.div_ && (this.div_.parentNode.removeChild(this.div_), this.div_ = null, this.setMap(null))
}, ProjectedOverlay.prototype.draw = function (a) {
    if (this.createElement(), this.div_) {
        var b = this.get("projection").fromLatLngToDivPixel(this.bounds_.getSouthWest()), c = this.get("projection").fromLatLngToDivPixel(this.bounds_.getNorthEast());
        if (b && c && (this.div_.style.width = Math.abs(c.x - b.x) + "px", this.div_.style.height = Math.abs(c.y - b.y) + "px", this.div_.style.left = Math.min(c.x, b.x) + "px", this.div_.style.top = Math.min(c.y, b.y) + "px", this.lastZoom_ != this.map_.getZoom())) {
            this.lastZoom_ = this.map_.getZoom();
            var d = this.url_;
            this.addZ_ && (d += this.addZ_ + this.map_.getZoom()), this.div_.innerHTML = '<img src="' + d + '"  width=' + this.div_.style.width + " height=" + this.div_.style.height + " >"
        }
    }
}, ProjectedOverlay.prototype.setOpacity = function (a) {
    0 > a && (a = 0), a > 100 && (a = 100);
    var b = a / 100;
    "string" == typeof this.div_.style.filter && (this.div_.style.filter = "alpha(opacity:" + a + ")"), "string" == typeof this.div_.style.KHTMLOpacity && (this.div_.style.KHTMLOpacity = b), "string" == typeof this.div_.style.MozOpacity && (this.div_.style.MozOpacity = b), "string" == typeof this.div_.style.opacity && (this.div_.style.opacity = b)
}, function () {
    if ("object" == typeof JSIO) {
        var a = new Error("JSIO is already defined");
        throw a.source = "JSIO.core.js", a
    }
    JSIO = {}, JSIO.version = "2.0 2012Feb", JSIO.throwError = function (a, b, c) {
        var d = new Error("Error: " + a);
        throw d.source = (b || this._typename || "JSIO") + (c ? "." + c : ""), d
    }, JSIO.decimalToHexString = function (a, b) {
        0 > a && (a = 4294967295 + a + 1);
        var c = a.toString(16).toUpperCase();
        return b && (c = "00000000" + c, c = c.substring(c.length - b)), c
    }, JSIO.FileType = {Text: 0, Binary: 1, XML: 2, Unknown: 3}, JSIO.guessFileType = function (a) {
        if ("makefile" == a)return JSIO.FileType.Text;
        var b = a.lastIndexOf(".");
        if (0 >= b)return JSIO.FileType.Unknown;
        var c = a.substring(b);
        return ".zip" == c ? JSIO.FileType.Binary : ".xlsx" == c ? JSIO.FileType.Binary : ".docx" == c ? JSIO.FileType.Binary : ".dll" == c ? JSIO.FileType.Binary : ".obj" == c ? JSIO.FileType.Binary : ".pdb" == c ? JSIO.FileType.Binary : ".exe" == c ? JSIO.FileType.Binary : ".kmz" == c ? JSIO.FileType.Binary : ".xml" == c ? JSIO.FileType.XML : ".xsl" == c ? JSIO.FileType.XML : ".kml" == c ? JSIO.FileType.XML : ".csproj" == c ? JSIO.FileType.XML : ".vbproj" == c ? JSIO.FileType.XML : ".shfbproj" == c ? JSIO.FileType.XML : ".resx" == c ? JSIO.FileType.XML : ".xslt" == c ? JSIO.FileType.XML : ".sln" == c ? JSIO.FileType.Text : ".htm" == c ? JSIO.FileType.Text : ".html" == c ? JSIO.FileType.Text : ".js" == c ? JSIO.FileType.Text : ".vb" == c ? JSIO.FileType.Text : ".txt" == c ? JSIO.FileType.Text : ".rels" == c ? JSIO.FileType.Text : ".css" == c ? JSIO.FileType.Text : ".cs" == c ? JSIO.FileType.Text : ".asp" == c ? JSIO.FileType.Text : JSIO.FileType.Unknown
    }, JSIO.stringOfLength = function (a, b) {
        for (var c = "", d = 0; b > d; d++)c += String.fromCharCode(a);
        return c
    }, JSIO.formatByteArray = function (a) {
        for (var b = "0000  ", c = "", d = 0; d < a.length; d++)0 !== d && d % 16 === 0 && (b += "    " + c + "\n" + JSIO.decimalToHexString(d, 4) + "  ", c = ""), b += JSIO.decimalToHexString(a[d], 2) + " ", c += a[d] >= 32 && a[d] <= 126 ? String.fromCharCode(a[d]) : ".";
        return c.length > 0 && (b += JSIO.stringOfLength(32, (d % 16 > 0 ? 3 * (16 - d % 16) : 0) + 4) + c), b
    }, JSIO.htmlEscape = function (a) {
        return a.replace(new RegExp("&", "g"), "&amp;").replace(new RegExp("<", "g"), "&lt;").replace(new RegExp(">", "g"), "&gt;").replace(new RegExp("", "g"), "<br/>").replace(new RegExp("", "g"), "<br/>")
    }, JSIO.massApply = function (a, b, c, d) {
        var e = 65536;
        if (c.length < e)return a.apply(b, c);
        for (var f = b, g = 0, h = 65536; g < c.length;) {
            var i;
            c.subarray ? i = c.subarray(g, h) : c.slice && (i = c.slice(g, h)), d ? f += a.apply(f, i) : a.apply(b, i), g += e, h += e, h = Math.min(c.length, h)
        }
        return f
    }
}(), function () {
    var a = "2.0 2012Feb";
    "object" != typeof JSIO && (JSIO = {}), "string" != typeof JSIO.version ? JSIO.version = a : (JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && (JSIO.version += " " + a);
    var b = function () {
        this.position = 0
    };
    b.prototype._throwError = JSIO.throwError, b.prototype._limitCheck = function (a, b) {
        var c = {len: a, pos: b, end: b + a};
        return 0 === a ? {
            len: 0,
            pos: 0,
            end: 0
        } : (0 > a && this._throwError("Invalid read length"), this.length ? (!b >= 0 && (c.pos = this.position), this.length <= c.pos && this._throwError("EOF reached"), c.end = c.pos + a, this.length < c.end && (c.end = c.pos + (c.len = this.length - this.position)), c) : {
            len: a,
            pos: this.position,
            end: a + this.position
        })
    }, JSIO.SeekOrigin = {
        Begin: 0,
        Current: 1,
        End: 2,
        SEEK_SET: 0,
        SEEK_CUR: 1,
        SEEK_END: 2
    }, b.prototype.seek = function (a, b) {
        switch (b) {
            case JSIO.SeekOrigin.Begin:
                if (a == this.position)return this.position;
                if (this.length)this.length < a && this._throwError("Cannot seek past reader length", null, "seek"), this.position = a; else if (a < this.position)this._throwError("Uni-directional stream cannot seek backwards", null, "seek"); else if (a > this.position)return this.read(a - this.position);
                break;
            case JSIO.SeekOrigin.Current:
                return this.seek(this.position + a, JSIO.SeekOrigin.Begin);
            case JSIO.SeekOrigin.End:
                return this.length || this._throwError("Uni-directional stream has no known end length for seek", null, "seek"), this.seek(this.length - 1 + a, JSIO.SeekOrigin.Begin);
            default:
                this._throwError("Invalid seek method", null, "seek")
        }
        return this.position
    }, b.prototype.read = function (a, b) {
        var c = this._limitCheck(a, b);
        if (0 === c.len)return [];
        c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        var d = [];
        if (this.array && this.array.subarray)d = this.array.subarray(c.pos, c.end); else if (this.array && this.array.slice)d = this.array.slice(c.pos, c.end); else if (this.stream)d = this.stream.read(c.len, c.pos); else if (this.length)for (var e = c.pos; e < c.end; e++)d.push(this.readByteAt(e)); else for (var e = c.pos; e < c.end; e++) {
            var f = this.readByte();
            if (null === f || void 0 === f)break;
            d.push(f)
        }
        return this.position = c.end, d
    }, b.prototype.beginRead = function (a, b, c) {
        var d = this._limitCheck(a, b);
        if (0 === d.len)return setTimeout(function () {
            c([])
        }, 1);
        d.pos != this.position && this.seek(d.pos, JSIO.SeekOrigin.Begin);
        var e = [], f = this, g = d.len, h = function () {
            var a = 0, b = (f.position, g >= 32768 ? 32768 : g), d = f.read(b);
            JSIO.massApply(e.push, e, d), a += b, g -= b, d.length < b && (g = 0), g > 0 ? setTimeout(h, 1) : c(e)
        };
        return setTimeout(h, 1), null
    }, b.prototype.readToEnd = function () {
        return this.array && this.array.subarray ? this.array.subarray(this.position) : this.array && this.array.slice ? this.array.slice(this.position) : this.length ? this.read(this.length - this.position) : this.read(81e6)
    }, b.prototype.beginReadToEnd = function (a) {
        if (this.array && this.array.subarray)setTimeout(function () {
            a(this.array.subarray(this.position))
        }, 1); else {
            if (!this.array || !this.array.slice)return this.length ? this.beginRead(this.length - this.position, this.position, a) : this.beginRead(81e6, this.position, a);
            setTimeout(function () {
                a(this.array.slice(this.position))
            }, 1)
        }
    }, b.prototype.readByte = function () {
        if (this.length && this.position >= this.length)return null;
        var a;
        return a = this.array ? this.array[this.position++] : this.length ? this.readByteAt(this.position++) : this.stream ? this.stream.read(1)[0] : this.read(1)[0], null === a || void 0 === a ? null : a
    }, b.prototype.readByteAt = function (a) {
        var b = this.position;
        (null === a || void 0 === a) && (a = this.position);
        var c;
        return c = this.array ? this.array[a] : a === b ? this.readByte() : this.stream ? this.stream.read(1, a)[0] : this.read(1, a)[0], this.position = b, null === c || void 0 === c ? null : c
    }, b.prototype.readBytes = b.prototype.read, b.prototype.beginReadBytes = function (a, b) {
        return this.beginRead(a, this.position, b)
    }, b.prototype.readNumber = function (a, b) {
        var c = this._limitCheck(a, b);
        0 === c.len && (c.len = 1), c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        for (var d = 0, e = this.read(c.len, c.pos), f = e.length - 1; f >= 0; f--)d = 256 * d + e[f];
        return d
    }, b.prototype.readString = function (a, b) {
        var c = this._limitCheck(a, b);
        if (0 === c.len)return "";
        c.pos != this.position && this.seek(c.pos, JSIO.SeekOrigin.Begin);
        for (var d = "", e = this.read(c.len, c.pos), f = 0; f < e.length; f++)d += String.fromCharCode(e[f]);
        return d
    }, b.prototype.readNullTerminatedString = function (a) {
        var b = a || this.position;
        this.length && this.length < b && this._throwError("EOF reached", null, "readNullTerminatedString"), b != this.position && this.seek(b, JSIO.SeekOrigin.Begin);
        var c = "", d = "", e = 0;
        if (this.array && this.array.indexOf) {
            var f = b - this.array.indexOf(0, b);
            if (f > 0)return this.readString(f, b)
        }
        for (var g; g = String.fromCharCode(this.readByteAt(b + e)), null !== g;)d += g, e++, e >= 32768 && (c += d, d = "", b += e, this.position += e, e = 0);
        return this.position = b + e, c + d
    }, b.prototype.beginReadNullTerminatedString = function (a, b) {
        var c = b || this.position;
        this.length && this.length < c && this._throwError("EOF reached", null, "beginReadNullTerminatedString");
        var d = "", e = "", f = this, g = function () {
            for (var b, h = 0; b = String.fromCharCode(this.readByteAt(c + h)), null !== b;)e += b, h++, h >= 32768 && (d += e, e = "", c += h, this.position += h, h = 0);
            f.position = c + h, null !== b ? setTimeout(g, 1) : a(d + e)
        };
        if (this.array && this.array.indexOf) {
            var h = c - this.array.indexOf(0, c);
            h > 0 && (readBatchASync = function () {
                a(f.readString(h, c))
            })
        }
        return setTimeout(g, 1), null
    }, JSIO._ByteReaderBase = b;
    var c = function (b) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.ArrayReader", "ctor"), this.position = 0, this.array = b, this.length = b.length, this._typename = "JSIO.ArrayReader", this._version = a, this
    };
    c.prototype = new JSIO._ByteReaderBase, c.prototype.readByte = function () {
        return this.position >= this.array.length ? null : this.array[this.position++]
    }, c.prototype.readByteAt = function (a) {
        return this.array[a]
    };
    var d = function (b, d, e) {
        if (this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.StreamSegmentReader", "ctor"), b || this._throwError("You must pass a non-null stream", "JSIO.StreamSegmentReader", "ctor"), d >= 1 || (d = 0), e >= 1 || (e = 0), this.stream = b, this.array = null, b.array) {
            var f = e ? d + e : null;
            b.array.subarray ? this.array = b.array.subarray(d, f) : b.array.slice && (this.array = b.array.slice(d, f))
        }
        return this.length = this.array ? this.array.length : b.length ? b.length - d : null, this.offset = d, this.limit = e, this.position = 0, this._typeName = "JSIO.StreamSegmentReader", this._version = a, this.array && (this.readByte = c.prototype.readByte, this.readByteAt = c.prototype.readByteAt), this
    };
    d.prototype = new JSIO._ByteReaderBase, d.prototype.readByte = function () {
        return this.limit && this.position >= this.limit ? null : (this.position++, this.stream.readByteAt(this.offset + this.position - 1))
    }, d.prototype.readByteAt = function (a) {
        return this.limit && a >= this.limit ? null : this.stream.readByteAt(this.offset + a)
    }, JSIO.ArrayReader = c, JSIO.StreamReader = d, JSIO.StreamSegmentReader = d
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.BinaryUrlStream";
    if (("object" != typeof JSIO || "string" != typeof JSIO.version || JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && JSIO.throwError("This extension requires JSIO.core.js v2.0", b), "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        var c = "<!-- IEBinaryToArray_ByteStr -->\r\n<script type='text/vbscript'>\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteAsc_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n      IEBinaryToArray_ByteAsc_Last = AscB( MidB( Binary, lastIndex, 1 ) )\r\n   Else\r\n      IEBinaryToArray_ByteAsc_Last = -1\r\n   End If\r\nEnd Function\r\n</script>\r\n";
        document.write(c)
    }
    JSIO.IEByteMapping = null;
    var d = function (c, d) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.BinaryUrlStream", "ctor"), this.callback = d, this.position = 0, this.length = null, this.readByte = JSIO.ArrayReader.prototype.readByte, this.readByteAt = JSIO.ArrayReader.prototype.readByteAt, this.req = null, this._typename = b, this._version = a, this.status = "-none-";
        var e = function (a) {
            var b = this, c = function (a) {
                var b = new Array;
                try {
                    b = new VBArray(a).toArray()
                } catch (c) {
                    if (!JSIO.IEByteMapping) {
                        JSIO.IEByteMapping = {};
                        for (var d = 0; 256 > d; d++)for (var e = 0; 256 > e; e++)JSIO.IEByteMapping[String.fromCharCode(d + 256 * e)] = [d, e]
                    }
                    for (var f = IEBinaryToArray_ByteStr(a), g = IEBinaryToArray_ByteAsc_Last(a), d = 0; d < f.length; d++)b.push.apply(b, JSIO.IEByteMapping[f.substr(d, 1)]);
                    g >= 0 && b.push(g)
                }
                return b
            };
            this.req = function () {
                if (window.XMLHttpRequest)return new window.XMLHttpRequest;
                if (window.ActiveXObject)for (var a = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP"], b = 0; b < a.length; b++)try {
                    return new ActiveXObject(a[b])
                } catch (c) {
                    continue
                }
                return null
            }(), this.req.open("GET", a, !0), this.req.setRequestHeader("Accept-Charset", "x-user-defined"), this.req.onreadystatechange = function (d) {
                4 == b.req.readyState && (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status ? (b.array = c(b.req.responseBody), b.length = b.array.length, b.length < 0 && this._throwError('Failed to load "' + a + '" after converting'), "function" == typeof b.callback && b.callback(b)) : b._throwError('Failed to load "' + a + '": HTTP ' + b.status))
            }, this.req.send()
        }, f = function (a) {
            var b = this;
            this.req = new XMLHttpRequest, this.req.open("GET", a, !0), this.req.onreadystatechange = function (c) {
                if (4 == b.req.readyState)if (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status) {
                    var d = b.req.responseText;
                    b.length = d.byteLength, b.array = d.split("");
                    for (var e = 0; e < b.array.length; e++)b.array[e] = 255 & b.array[e].charCodeAt(0);
                    "function" == typeof b.callback && b.callback(b)
                } else b._throwError('Failed to load "' + a + '": HTTP ' + b.status)
            }, this.req.overrideMimeType && this.req.overrideMimeType("text/plain; charset=x-user-defined"), this.req.send(null)
        }, g = function (a) {
            var b = this;
            this.req = new XMLHttpRequest, this.req.open("GET", a, !0), this.req.onreadystatechange = function (c) {
                if (4 == b.req.readyState)if (b.status = "Status: " + b.req.status + " " + b.req.statusText, 200 == b.req.status) {
                    var d = b.req.response;
                    b.length = d.byteLength, b.array = new Uint8Array(d), "function" == typeof b.callback && b.callback(b)
                } else b._throwError('Failed to load "' + a + '": HTTP ' + b.status)
            }, this.req.responseType = "arraybuffer", this.req.overrideMimeType && this.req.overrideMimeType("application/octet-stream; charset=x-user-defined"), this.req.send(null)
        };
        "undefined" != typeof ArrayBuffer ? g.apply(this, [c]) : /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? e.apply(this, [c]) : f.apply(this, [c])
    };
    d.prototype = new JSIO._ByteReaderBase, d.prototype.readByte = function () {
        var a = this.readByteAt(this.position++);
        return null === a || void 0 === a ? null : a
    }, JSIO.BinaryUrlStream = d
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.TextDecoder";
    ("object" != typeof JSIO || "string" != typeof JSIO.version || JSIO.version.length < 3 || "2.0" !== JSIO.version.substring(0, 3)) && JSIO.throwError("This extension requires JSIO.core.js v2.0", b), "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b);
    var c = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.ANSI", "ctor"), this.byteReader = c, this.charWidth = 1, this._version = a, this._typename = b + ".ANSI", this
    };
    c.prototype.readChar = function () {
        var a = this.byteReader.readByte();
        return 0 > a ? null : String.fromCharCode(a)
    }, c.prototype.parseChar = function (a) {
        return 0 > a ? null : String.fromCharCode(a)
    };
    var d = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.UTF16", "ctor"), this.byteReader = c, this.charWidth = 2, this.bomState = 0, this._version = a, this._typename = b + ".UTF16", this
    };
    d.prototype.readChar = function () {
        var a = this.byteReader.readByte();
        if (0 > a)return null;
        var b = this.byteReader.readByte();
        if (0 > b && this._throwError("Incomplete UTF16 character", null, "readChar"), 0 === this.bomState && a + b == 509) {
            if (this.bomState = 254 == b ? 1 : 2, a = this.byteReader.readByte(), 0 > a)return null;
            b = this.byteReader.readByte(), 0 > b && this._throwError("Incomplete UTF16 character", null, "readChar")
        } else this.bomState = 1;
        return this.parseChar(a, b)
    }, d.prototype.parseChar = function (a, b) {
        return String.fromCharCode(1 == this.bomState ? b << 8 | a : a << 8 | b)
    };
    var e = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.TextDecoder.UTF8", "ctor"), this.byteReader = c, this.charWidth = null, this.waitBom = !0, this.strict = !1, this.pendingChar = null, this._version = a, this._typename = b + ".UTF8", this
    };
    e.prototype.readChar = function () {
        var a = null;
        do {
            if (null !== this.pendingChar)a = this.pendingChar, this.pendingChar = null; else {
                var b = this.byteReader.readByte();
                if (null === b)return null;
                if (0 === (128 & b))a = String.fromCharCode(b); else {
                    var c = 192, d = 0;
                    do {
                        var e = c >> 1 | 128;
                        if ((b & e) == c)break;
                        c = c >> 1 | 128
                    } while (++d < 5);
                    if (d > 0) {
                        var f;
                        if (1 === d)f = (31 & b) << 6 | 63 & this.byteReader.readByte(); else {
                            f <<= 6 * d;
                            for (var g = this.byteReader.read(d), h = 0; h > d; h++) {
                                var i = g[h];
                                128 != (192 & i) && this._throwError("Invalid sequence character", null, "readChar"), f = f << 6 | 63 & i
                            }
                        }
                        if (65535 >= f)a = 65279 == f && this.waitBom ? null : String.fromCharCode(f); else {
                            var j = f - 65536, k = 55296 | j >> 10 & 1023, l = 56320 | 1023 & j;
                            this.pendingChar = String.fromCharCode(l), a = String.fromCharCode(k)
                        }
                    } else this.strict ? this._throwError("Invalid character", null, "readChar") : a = String.fromCharCode(b)
                }
            }
            this.waitBom = !1
        } while (null === a);
        return a
    }, JSIO.TextDecoder = {Default: c, ANSI: c, UTF16: d, UTF8: e}
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.TextReader";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b);
    var c = function (c) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), this.decoder = c, this._version = a, this._typename = b, this.unreads = []
    };
    c.prototype.readChar = function () {
        return this.unreads.length > 0 ? this.unreads.pop() : this.decoder.readChar()
    }, c.prototype.read = function (a) {
        if (1 === this.decoder.charWidth)return JSIO.massApply(String.fromCharCode, new String, this.decoder.byteReader.read(a), !0);
        var b = "";
        for (vari = 0; i < a; i++) {
            var c = this.readChar();
            if (null === c)break;
            b += c
        }
        return b
    }, c.prototype.unreadChar = function (a) {
        this.unreads.push(a)
    }, c.prototype.readToEnd = function () {
        if (1 === this.decoder.charWidth)return JSIO.massApply(String.fromCharCode, new String, this.decoder.byteReader.readToEnd(n), !0);
        for (var a = "", b = "", c = 0, d = this.readChar(); null !== d;)b += d, c++, c >= 32768 && (a += b, b = "", c = 0), d = this.readChar();
        return a + b
    }, c.prototype.beginReadToEnd = function (a) {
        if (1 === this.decoder.charWidth)return this.decoder.byteReader.beginReadToEnd(function (b) {
            a(JSIO.massApply(String.fromCharCode, new String, b, !0))
        }), null;
        var b = "", c = "", d = this, e = function () {
            for (var f = 0, g = d.readChar(); null !== g;) {
                if (c += g, f++, f >= 32768) {
                    b += c, c = "";
                    break
                }
                g = d.readChar()
            }
            null !== g ? setTimeout(e, 1) : a(b + c)
        };
        return setTimeout(e, 1), null
    }, c.prototype.readLine = function () {
        var a = "", b = this.readChar();
        if (null === b)return null;
        for (; "\r" != b && "\n" != b;)if (a += b, b = this.readChar(), null === b)return a;
        return "\r" == b && (b = this.readChar(), null !== b && "\n" != b && this.unreadChar(b)), a
    }, JSIO.TextReader = c
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.Crc32";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), JSIO.crc32Table = null, JSIO.crc32Polynomial = 3988292384;
    var c = function () {
        if (!JSIO.crc32Table) {
            JSIO.crc32Table = new Array(256);
            for (var a = 0; 256 > a; a++) {
                for (var b = a, c = 0; 8 > c; c++)1 == (1 & b) ? b = JSIO.crc32Polynomial ^ b >>> 1 : b >>>= 1;
                JSIO.crc32Table[a] = b
            }
        }
    };
    JSIO.computeCrc32 = function (a) {
        c();
        var b = 4294967295, d = a.length;
        if ("object" == typeof a)for (var e = 0; d > e; e++)b = JSIO.crc32Table[255 & b ^ a[e]] ^ b >>> 8; else for (var f = 0; d > f; f++)b = JSIO.crc32Table[255 & b ^ a.charCodeAt(f)] ^ b >>> 8;
        return b ^= 4294967295, 0 > b && (b += 4294967296), b
    };
    var d = function () {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), c(), this._typename = b, this._version = a, this._runningCrc32 = 4294967295
    };
    d.prototype.slurpByte = function (a) {
        var b = this._runningCrc32;
        this._runningCrc32 = b >>> 8 ^ JSIO.crc32Table[a ^ 255 & b]
    }, d.prototype.result = function () {
        var a = 4294967295 ^ this._runningCrc32;
        return 0 > a && (a += 4294967296), a
    };
    var e = function (b) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", "JSIO.Crc32Reader", "ctor"), this._byteReader = b, this._typename = "JSIO.Crc32Reader", this._version = a, this._crc32 = new JSIO.Crc32
    };
    e.prototype = new JSIO._ByteReaderBase, e.prototype.readByte = function () {
        var a = this._byteReader.readByte();
        return null !== a && this._crc32.slurpByte(a), this.position++, a
    }, e.prototype.read = function (a) {
        if (0 === a)return [];
        var b = this._byteReader.read(a);
        a = b.length;
        for (var c, d = JSIO.crc32Table, e = this._crc32._runningCrc32, f = 0; a > f; f++)c = d[b[f] ^ 255 & e], e = e >>> 8 ^ c;
        return this._crc32._runningCrc32 = e, this.position += a, b
    }, e.prototype.crc32 = function () {
        return this._crc32.result()
    }, JSIO.Crc32 = d, JSIO.Crc32Reader = e
}(), function () {
    var a = "2.0 2012Feb", b = "JSIO.InflatingReader";
    "function" != typeof JSIO._ByteReaderBase && JSIO.throwError("This extension requires JSIO.BasicByteReaders.js", b), JSIO.bitShiftTable = null;
    var c = function () {
        if (!JSIO.bitShiftTable) {
            var a = 8;
            JSIO.bitShiftTable = {LSB: new Array(a), MSB: new Array(a)};
            for (var b = 0; a > b; b++) {
                var c = a - b;
                JSIO.bitShiftTable.LSB[b] = new Array(c), JSIO.bitShiftTable.MSB[b] = new Array(c);
                for (var d = 1 << b, e = 1 << c - 1, f = 1; c >= f; f++)JSIO.bitShiftTable.LSB[b][f - 1] = d, JSIO.bitShiftTable.MSB[b][f - 1] = e, d |= 1 << b + f, e |= 1 << c - f - 1
            }
        }
    }, d = function (d) {
        this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b + "._InternalBitReader.ctor"), this.bitsLength = 0, this.bits = 0, this.byteReader = d, this._typeName = b + "._InternalBitReader", this._version = a, c()
    };
    d.prototype._throwError = JSIO.throwError, d.prototype.readBit = function () {
        if (0 === this.bitsLength) {
            var a = this.byteReader.readByte();
            null === a && this._throwError("Unexpected end of stream", null, "readBit"), this.bits = a, this.bitsLength = 8
        }
        var b = 0 !== (this.bits & 1 << 8 - this.bitsLength);
        return this.bitsLength--, b
    }, d.prototype.align = function () {
        this.bitsLength = 0
    }, d.prototype.readBits = function (a, b) {
        var c = 0;
        b = b || "LSB";
        for (var d = JSIO.bitShiftTable[b], e = 0; a > 0;) {
            if (0 === this.bitsLength) {
                var f = this.byteReader.readByte();
                null === f && this._throwError("Unexpected end of stream", null, "read" + b), this.bits = f, this.bitsLength = 8
            }
            var g = this.bitsLength >= a ? a : this.bitsLength, h = 8 - this.bitsLength;
            c |= (this.bits & d[h][g - 1]) >>> h << e, e += g, a -= g, this.bitsLength -= g
        }
        return c
    }, d.prototype.readLSB = function (a) {
        return this.readBits(a, "LSB")
    }, d.prototype.readMSB = function (a) {
        return this.readBits(a, "MSB")
    };
    var e = function (c) {
        return this instanceof arguments.callee || this._throwError("You must use new to instantiate this class", b, "ctor"), this._byteReader = c, this._bitReader = new d(c), this._buffer = [], this._bufferPosition = 0, this._state = 0, this._blockFinal = !1, this._typeName = b, this._version = a, this
    }, f = null, g = null, h = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], i = function (a) {
        var b = 0, c = new Array(a.length), d = a[0];
        for (b = 1; b < a.length; b++)d < a[b] && (d = a[b]);
        var e = new Array(d + 1);
        for (b = 0; d >= b; b++)e[b] = 0;
        for (b = 0; b < a.length; b++)++e[a[b]];
        var f = new Array(d + 1), g = 0;
        e[0] = 0;
        for (var h = 1; d >= h; h++)g = g + e[h - 1] << 1, f[h] = g;
        for (b = 0; b < c.length; b++) {
            var i = a[b];
            0 !== i && (c[b] = f[i], f[i]++)
        }
        return c
    }, j = function (a, b) {
        for (var c = [], d = 0; d < a.length; ++d)if (b[d] > 0) {
            var e = {};
            e.bits = a[d], e.length = b[d], e.index = d, c.push(e)
        }
        return k(c, 0, 0)
    }, k = function (a, b, c) {
        if (0 === a.length)return null;
        var d = [], e = [], f = {};
        f.isLeaf = !1;
        for (var g = 0; g < a.length; ++g) {
            if (a[g].length == c && a[g].bits == b) {
                f.isLeaf = !0, f.index = a[g].index;
                break
            }
            var h = (a[g].bits >> a[g].length - c - 1 & 1) > 0;
            h ? e.push(a[g]) : d.push(a[g])
        }
        return f.isLeaf || (f.zero = k(d, b << 1, c + 1), f.one = k(e, b << 1 | 1, c + 1)), f
    }, l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], m = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], n = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], o = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], p = function (a) {
        var b, c = a.readLSB(5) + 257, d = a.readLSB(5) + 1, e = a.readLSB(4) + 4, f = new Array(19);
        for (b = 0; b < f.length; b++)f[b] = 0;
        for (b = 0; e > b; b++)f[h[b]] = a.readLSB(3);
        for (var g = i(f), k = j(g, f), l = []; l.length < c + d;) {
            for (var m = k; !m.isLeaf;)m = a.readBit() ? m.one : m.zero;
            var n = m.index;
            if (15 >= n)l.push(n); else if (16 == n)for (var o = a.readLSB(2) + 3, p = 0; o > p; ++p)l.push(l[l.length - 1]); else if (17 == n)for (var q = a.readLSB(3) + 3, r = 0; q > r; ++r)l.push(0); else if (18 == n)for (var s = a.readLSB(7) + 11, t = 0; s > t; ++t)l.push(0)
        }
        var u = l.slice(0, c), v = i(u), w = l.slice(c, c + d), x = i(w);
        return {codesTree: j(v, u), distancesTree: j(x, w)}
    };
    e.prototype = new JSIO._ByteReaderBase, e.prototype._decodeItem = function () {
        if (2 == this._state)return null;
        var a;
        if (0 === this._state) {
            this._blockFinal = this._bitReader.readBit();
            var b = this._bitReader.readLSB(2);
            switch (b) {
                case 0:
                    this._bitReader.align();
                    var c = this._bitReader.readLSB(16), d = this._bitReader.readLSB(16);
                    return (c & ~d) != c && this._throwError("Invalid block type 0 length", null, "_decodeItem"), a = {}, a.itemType = 0, a.array = this._bitReader.byteReader.read(c), a.array.length < c && this._throwError("Incomplete block", null, "_decodeItem"), this._blockFinal && (this._state = 2), a;
                case 1:
                    this._codesTree = f, this._distancesTree = g, this._state = 1;
                    break;
                case 2:
                    var e = p(this._bitReader);
                    this._codesTree = e.codesTree, this._distancesTree = e.distancesTree, this._state = 1;
                    break;
                default:
                    this._throwError("Invalid block type (" + b + ")", null, "_decodeItem")
            }
        }
        a = {};
        for (var h = this._codesTree; !h.isLeaf;)h = this._bitReader.readBit() ? h.one : h.zero;
        if (h.index < 256)a.itemType = 2, a.symbol = h.index; else if (h.index > 256) {
            var i = h.index;
            i > 285 && this._throwError("Invalid length code", null, "_decodeItem");
            var j = l[i - 257];
            for (m[i - 257] > 0 && (j += this._bitReader.readLSB(m[i - 257])), h = this._distancesTree; !h.isLeaf;)h = this._bitReader.readBit() ? h.one : h.zero;
            var k = h.index, q = n[k];
            o[k] > 0 && (q += this._bitReader.readLSB(o[k])), a.itemType = 3, a.distance = q, a.length = j
        } else a.itemType = 1, this._state = this._blockFinal ? 2 : 0;
        return a
    }, e.prototype.readByte = function () {
        var a = this.read(1)[0];
        return null === a || void 0 === a ? null : a
    }, e.prototype.read = function (a) {
        for (var b = this._buffer; this._bufferPosition + a > b.length;) {
            var c = this._decodeItem();
            if (null === c) {
                a = b.length - this._bufferPosition;
                break
            }
            switch (c.itemType) {
                case 0:
                    JSIO.massApply(b.push, b, c.array);
                    break;
                case 2:
                    b.push(c.symbol);
                    break;
                case 3:
                    var d = b.length - c.distance;
                    if (c.distance >= c.length)JSIO.massApply(b.push, b, b.slice(d, d + c.length)); else {
                        for (var e = parseInt(c.length / c.distance), f = b.slice(d); e > 0;)1 & e && JSIO.massApply(b.push, b, f), (e >>= 1) && JSIO.massApply(f.push, f, f);
                        var g;
                        (g = c.length % c.distance) && JSIO.massApply(b.push, b, b.slice(d, d + g))
                    }
            }
        }
        var h = b.slice(this._bufferPosition, this._bufferPosition + a);
        if (this._bufferPosition += a, this.position += a, this._bufferPosition > 49152) {
            var i = b.length - 32768;
            i > this._bufferPosition && (i = this._bufferPosition), b.splice(0, i), this._bufferPosition -= i
        }
        return h
    }, function () {
        var a = new Array(288), b = new Array(288), c = 0;
        for (c = 0; 143 >= c; c++)a[c] = 48 + c, b[c] = 8;
        for (c = 144; 255 >= c; c++)a[c] = 400 + c - 144, b[c] = 9;
        for (c = 256; 279 >= c; c++)a[c] = 0 + c - 256, b[c] = 7;
        for (c = 280; 287 >= c; c++)a[c] = 192 + c - 280, b[c] = 8;
        f = j(a, b);
        var d = new Array(32), e = new Array(32);
        for (c = 0; 31 >= c; c++)d[c] = c, e[c] = 5;
        g = j(d, e)
    }(), JSIO.InflatingReader = e
}(), function () {
    function a(a) {
        this.zipfile = a, this._typename = "ZipEntry", this._version = b, this._crcCalculator = null
    }

    var b = "2.0 2012Feb", c = "Zipfile";
    "function" != typeof JSIO.BinaryUrlStream && JSIO.throwError("This extension requires JSIO.BinaryUrlStream.js v2.0", c), "object" != typeof JSIO.TextDecoder && JSIO.throwError("This extension requires JSIO.TextDecoder.js v2.0", c), "function" != typeof JSIO.TextReader && JSIO.throwError("This extension requires JSIO.TextReader.js v2.0", c), "function" != typeof JSIO.Crc32 && JSIO.throwError("This extension requires JSIO.Crc32.js v2.0", c), "function" != typeof JSIO.InflatingReader && JSIO.throwError("This extension requires JSIO.InflatingReader.js v2.0", c), a.prototype._throwError = JSIO.throwError, a.prototype.extract = function (a, b) {
        this.contentType = JSIO.guessFileType(this.name), b = b || this.contentType == JSIO.FileType.Text || this.contentType == JSIO.FileType.XML;
        var c = this;
        0 !== this.compressionMethod && 8 != this.compressionMethod && this._throwError("Unsupported compression method: " + this.compressionMethod, null, "extract");
        var d = b ? this.openTextReader(c.utf8 ? JSIO.TextDecoder.UTF8 : JSIO.TextDecoder.ANSI) : this.openBinaryReader();
        if (d.zipEntryName = c.name, "function" != typeof a) {
            var e = d.readToEnd();
            return this.verifyCrc32(), e
        }
        return d.beginReadToEnd(function (b) {
            try {
                c.verifyCrc32(), a(c, b)
            } catch (d) {
                a(c, d)
            }
        }), null
    }, a.prototype.openBinaryReader = function () {
        var a = new JSIO.StreamSegmentReader(this.zipfile.binaryStream, this.offset + this.lengthOfHeader, this.compressedSize);
        if (0 === this.compressionMethod)this._crcCalculator = new JSIO.Crc32Reader(a); else {
            var b = new JSIO.InflatingReader(a);
            this._crcCalculator = new JSIO.Crc32Reader(b)
        }
        return this._crcCalculator
    }, a.prototype.openTextReader = function (a) {
        var b = this.openBinaryReader();
        a = a || JSIO.TextDecoder.UTF8;
        var c = new a(b), d = new JSIO.TextReader(c);
        return c._parent = d, d
    }, a.prototype.verifyCrc32 = function () {
        var a = this._crcCalculator.crc32(), b = !1;
        if (this.crc32 != a) {
            var c = "WARNING: CRC check failed: entry(" + this.name + ") computed(" + JSIO.decimalToHexString(a, 8) + ") expected(" + JSIO.decimalToHexString(this.crc32, 8) + ") ";
            this.zipfile.status.push(c)
        } else b = !0, this.zipfile.verbose > 2 && this.zipfile.status.push("INFO: CRC check ok: 0x" + JSIO.decimalToHexString(this.crc32, 8));
        return b
    }, ZipFile = function (d, e, f) {
        function g(a) {
            if (65535 == a || 0 === a)return new Date(1995, 0, 1, 0, 0, 0, 0);
            var b = 65535 & a, c = (4294901760 & a) >> 16, d = 1980 + ((65024 & c) >> 9), e = ((480 & c) >> 5) - 1, f = 31 & c, g = (63488 & b) >> 11, h = (2016 & b) >> 5, i = 2 * (31 & b);
            i >= 60 && (h++, i = 0), h >= 60 && (g++, h = 0), g >= 24 && (f++, g = 0);
            var j, k = !1;
            try {
                j = new Date(d, e, f, g, h, i, 0), k = !0
            } catch (l) {
                if (1980 != d || 0 !== e && 0 !== f)try {
                    1980 > d && (d = 1980), d > 2030 && (d = 2030), 1 > e && (e = 1), e > 12 && (e = 12), 1 > f && (f = 1), f > 31 && (f = 31), 0 > h && (h = 0), h > 59 && (h = 59), 0 > i && (i = 0), i > 59 && (i = 59), j = new Date(d, e - 1, f, g, h, i, 0), k = !0
                } catch (m) {
                } else try {
                    j = new Date(1980, 0, 1, g, h, i, 0), k = !0
                } catch (n) {
                    try {
                        j = new Date(1980, 0, 1, 0, 0, 0, 0), k = !0
                    } catch (o) {
                    }
                }
            }
            return k || this._throwError("Bad date/time value in this ZIP file", null, "DateFromPackedFormat"), j
        }

        function h() {
            if (0 === j.entryNames.length)for (var a; null !== (a = i());)j.entries.push(a), j.entryNames.push(a.name)
        }

        function i() {
            var b = j.binaryStream.position, c = j.binaryStream.readNumber(4);
            if (c == ZipFile.Signatures.DirEntry)return j.verbose > 0 && j.status.push("INFO: at offset 0x" + JSIO.decimalToHexString(b) + ", found start of Zip Directory."), null;
            if (c != ZipFile.Signatures.Entry)return j.status.push("WARNING: at offset 0x" + JSIO.decimalToHexString(b) + ", found unexpected signature: 0x" + JSIO.decimalToHexString(c)), null;
            var d = new a(j);
            d.offset = b, d.versionNeeded = j.binaryStream.readNumber(2), d.bitField = j.binaryStream.readNumber(2), d.compressionMethod = j.binaryStream.readNumber(2);
            var e = j.binaryStream.readNumber(4);
            if (d.lastModified = g(e), d.crc32 = j.binaryStream.readNumber(4), d.compressedSize = j.binaryStream.readNumber(4), d.uncompressedSize = j.binaryStream.readNumber(4), 1 == (1 & d.bitField))return j.status.push("This zipfile uses Encryption, which is not supported by ZipFile.js."), null;
            if (d.utf8 = 2048 == (2048 & d.bitField), 8 == (8 & d.bitField))return j.status.push("This zipfile uses a bit 3 trailing data descriptor, which is not supported by ZipFile.js."), null;
            if (4294967295 == d.compressedSize || 4294967295 == d.uncompressedSize)return j.status.push("This zipfile uses ZIP64, which is not supported by ZipFile.js"), null;
            var f = j.binaryStream.readNumber(2), h = j.binaryStream.readNumber(2);
            j.status.push("INFO: filename length= " + f);
            var i = 30 + f + h;
            if (d.utf8) {
                j.status.push("INFO: before filename, position= 0x" + JSIO.decimalToHexString(j.binaryStream.position));
                var k = new JSIO.StreamSegmentReader(j.binaryStream, j.binaryStream.position, f), l = new JSIO.TextDecoder.UTF8(k), m = new JSIO.TextReader(l);
                d.name = m.readToEnd(), j.binaryStream.seek(f, JSIO.SeekOrigin.Current, j), j.status.push("INFO: after filename, position= 0x" + JSIO.decimalToHexString(j.binaryStream.position))
            } else d.name = j.binaryStream.readString(f);
            var n = 0;
            for (d.extra = []; h > n;) {
                var o = {type: j.binaryStream.readNumber(2), size: j.binaryStream.readNumber(2)};
                o.typeDescription = ZipFile.ExtraFieldTypes[o.type], o.data = j.binaryStream.read(o.size), d.extra.push(o), n += 4 + o.size
            }
            return j.verbose > 1 && j.status.push("INFO: at offset 0x" + JSIO.decimalToHexString(d.offset) + ", found entry '" + d.name + "' fnl(" + f + ") efl(" + h + ")"), h > 0 && j.verbose > 0 && j.status.push("INFO: entry " + d.name + " has " + h + " bytes of extra metadata (ID'd but ignored)"), d.lengthOfHeader = i, d.totalEntrySize = d.lengthOfHeader + d.compressedSize, j.verbose > 1 && j.status.push("INFO: seek 0x" + JSIO.decimalToHexString(d.compressedSize) + " (" + d.compressedSize + ") bytes"), j.binaryStream.seek(d.compressedSize, JSIO.SeekOrigin.Current, j), d
        }

        this instanceof arguments.callee || JSIO.throwError("You must use new to instantiate this class", c, "ctor"), this.verbose = f || 0, this.entries = [], this.entryNames = [], this.status = [], this._version = b, this._typename = "ZipFile", this._throwError = JSIO.throwError;
        var j = this, k = function (a) {
            try {
                if (200 == a.req.status) {
                    var b = j.binaryStream.readNumber(4);
                    b != ZipFile.Signatures.Entry ? j.status.push("WARNING: this file does not appear to be a zip file") : (j.binaryStream.seek(0, JSIO.SeekOrigin.Begin), h(), j.verbose > 0 && j.status.push("INFO: read " + j.entries.length + " entries"))
                } else j.status.push("ERROR: the URL could not be read (" + a.req.status + " " + a.req.statusText + ")");
                e(j)
            } catch (c) {
                j.status.push("Exception: " + c.message), e(j)
            }
        };
        return this.binaryStream = new JSIO.BinaryUrlStream(d, k), this
    }, ZipFile.Signatures = {
        Entry: 67324752,
        EndOfCentralDirectory: 101010256,
        DirEntry: 33639248
    }, ZipFile.Version = b, ZipFile.EncryptionAlgorithm = {
        None: 0,
        PkzipWeak: 1,
        WinZipAes: 2
    }, ZipFile.ExtraFieldTypes = {}, ZipFile.ExtraFieldTypes[1] = "Zip64 Extended Info", ZipFile.ExtraFieldTypes[7] = "AV Info", ZipFile.ExtraFieldTypes[8] = "Extended Language Encoding Data (PFS)", ZipFile.ExtraFieldTypes[9] = "OS/2", ZipFile.ExtraFieldTypes[10] = "NTFS ", ZipFile.ExtraFieldTypes[12] = "OpenVMS", ZipFile.ExtraFieldTypes[13] = "UNIX", ZipFile.ExtraFieldTypes[14] = "File Stream and Fork Descriptors", ZipFile.ExtraFieldTypes[15] = "Patch Descriptor", ZipFile.ExtraFieldTypes[20] = "PKCS#7 Store for X.509 Certificates", ZipFile.ExtraFieldTypes[21] = "X.509 Certificate ID and Signature (Individual File)", ZipFile.ExtraFieldTypes[22] = "X.509 Certificate ID (Central Directory)", ZipFile.ExtraFieldTypes[23] = "Strong Encryption Header", ZipFile.ExtraFieldTypes[24] = "Record Management Controls", ZipFile.ExtraFieldTypes[25] = "PKCS#7 Encryption Recipient Certificate List", ZipFile.ExtraFieldTypes[101] = "IBM S/390 (Z390), AS/400 (I400) attributes (uncompressed)", ZipFile.ExtraFieldTypes[102] = "IBM S/390 (Z390), AS/400 (I400) attributes (compressed)", ZipFile.ExtraFieldTypes[18064] = "POSZIP 4690 (reserved) ", ZipFile.ExtraFieldTypes[1992] = "Macintosh", ZipFile.ExtraFieldTypes[9733] = "ZipIt Macintosh", ZipFile.ExtraFieldTypes[9989] = "ZipIt Macintosh 1.3.5+", ZipFile.ExtraFieldTypes[10245] = "ZipIt Macintosh 1.3.5+", ZipFile.ExtraFieldTypes[13133] = "Info-ZIP Macintosh", ZipFile.ExtraFieldTypes[17217] = "Acorn/SparkFS ", ZipFile.ExtraFieldTypes[17491] = "Windows NT security descriptor (binary ACL)", ZipFile.ExtraFieldTypes[18180] = "VM/CMS", ZipFile.ExtraFieldTypes[18191] = "MVS", ZipFile.ExtraFieldTypes[19270] = "FWKCS MD5", ZipFile.ExtraFieldTypes[19521] = "OS/2 access control list (text ACL)", ZipFile.ExtraFieldTypes[19785] = "Info-ZIP OpenVMS", ZipFile.ExtraFieldTypes[20300] = "Xceed original location extra field", ZipFile.ExtraFieldTypes[21334] = "AOS/VS (ACL)", ZipFile.ExtraFieldTypes[21589] = "extended timestamp", ZipFile.ExtraFieldTypes[21838] = "Xceed unicode extra field", ZipFile.ExtraFieldTypes[22613] = "Info-ZIP UNIX (original, also OS/2, NT, etc)", ZipFile.ExtraFieldTypes[25461] = "Info-ZIP Unicode Comment Extra Field", ZipFile.ExtraFieldTypes[25922] = "BeOS/BeBox", ZipFile.ExtraFieldTypes[28789] = "Info-ZIP Unicode Path Extra Field", ZipFile.ExtraFieldTypes[30062] = "ASi UNIX", ZipFile.ExtraFieldTypes[30805] = "Info-ZIP UNIX (new)", ZipFile.ExtraFieldTypes[41504] = "Microsoft Open Packaging Growth Hint", ZipFile.ExtraFieldTypes[64842] = "SMS/QDOS"
}(), !function (a) {
    "use strict";
    a.module("LogicifyGMap", [])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(b) {
                var c = d.open;
                d.open = function (a, e) {
                    h = a, "function" == typeof a.openInfoWnd && a.openInfoWnd(b, a, e, d, c)
                };
                var e = d.close;
                if (d.close = function (b) {
                        return h ? void("function" == typeof h.closeInfoWnd && b === !0 ? h.closeInfoWnd(d, e) : e.apply(d, [])) : void a.error("Info window is closed now, you can not close it twice!")
                    }, g = !0, f.length > 0) {
                    for (var i = 0; i < f.length; i++)f[i](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            };
            var h = null;
            arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap")
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(b) {
                var c = d.open;
                d.open = function (a, e) {
                    h = a, "function" == typeof a.openInfoWnd && a.openInfoWnd(b, a, e, d, c)
                };
                var e = d.close;
                if (d.close = function (b) {
                        return h ? void("function" == typeof h.closeInfoWnd && b === !0 ? h.closeInfoWnd(d, e) : e.apply(d, [])) : void a.error("Info window is closed now, you can not close it twice!")
                    }, g = !0, f.length > 0) {
                    for (var i = 0; i < f.length; i++)f[i](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            };
            var h = null;
            arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap")
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(b) {
                var c = d.open;
                d.open = function (a, e) {
                    h = a, "function" == typeof a.openInfoWnd && a.openInfoWnd(b, a, e, d, c)
                };
                var e = d.close;
                if (d.close = function (b) {
                        return h ? void("function" == typeof h.closeInfoWnd && b === !0 ? h.closeInfoWnd(d, e) : e.apply(d, [])) : void a.error("Info window is closed now, you can not close it twice!")
                    }, g = !0, f.length > 0) {
                    for (var i = 0; i < f.length; i++)f[i](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            };
            var h = null;
            arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap", [])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(b) {
                var c = d.open;
                d.open = function (a, e) {
                    h = a, "function" == typeof a.openInfoWnd && a.openInfoWnd(b, a, e, d, c)
                };
                var e = d.close;
                if (d.close = function (b) {
                        return h ? void("function" == typeof h.closeInfoWnd && b === !0 ? h.closeInfoWnd(d, e) : e.apply(d, [])) : void a.error("Info window is closed now, you can not close it twice!")
                    }, g = !0, f.length > 0) {
                    for (var i = 0; i < f.length; i++)f[i](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            };
            var h = null;
            arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular), window.google && google.maps && (MultiGeometry.prototype = new google.maps.MVCObject, MultiGeometry.prototype.changed = function (a) {
    if (this.polylines)for (var b = 0; b < this.polylines.length; b++)this.polylines[b].set(a, this.get(a))
}, MultiGeometry.prototype.setMap = function (a) {
    this.set("map", a)
}, MultiGeometry.prototype.getMap = function () {
    return this.get("map")
}), String.prototype.trim || (String.prototype.trim = function () {
    return this.replace(/^\s+|\s+$/g, "")
}), geoXML3 = window.geoXML3 || {instances: []}, geoXML3.parser = function (a) {
    function b(a, b, c) {
        return c = c || function (a) {
            x(a, b)
        }, "application/vnd.google-earth.kml+xml" !== b.type && "function" == typeof ZipFile && "object" == typeof JSIO && "function" == typeof JSIO.guessFileType && (contentType = JSIO.guessFileType(b.baseUrl), 3 === contentType ? contentType = JSIO.FileType.Binary : null, contentType == JSIO.FileType.Binary || contentType == JSIO.FileType.Unknown) ? (b.isCompressed = !0, b.baseDir = b.baseUrl + "/", void geoXML3.fetchZIP(a, c, b.internals.parser)) : (b.isCompressed = !1, b.baseDir = defileURL(b.baseUrl), void geoXML3.fetchXML(a, c))
    }

    function c(a) {
        var b = t(w(a, "styleUrl")[0]);
        if (b && -1 != b.indexOf("#"))var c = b.split("#"); else var c = ["", ""];
        return c
    }

    function d(a, b, c, d) {
        var f = "{inline}" === b ? e(r) : m[b][c] = m[b][c] || e(r), g = w(a, "BalloonStyle");
        g && g.length > 0 && (f.balloon.bgColor = t(w(g[0], "bgColor")[0], f.balloon.bgColor), f.balloon.textColor = t(w(g[0], "textColor")[0], f.balloon.textColor), f.balloon.text = t(w(g[0], "text")[0], f.balloon.text), f.balloon.displayMode = t(w(g[0], "displayMode")[0], f.balloon.displayMode));
        var g = w(a, "IconStyle");
        if (g && g.length > 0) {
            var h = f.icon;
            h.scale = parseFloat(t(w(g[0], "scale")[0], h.scale)), g = w(g[0], "hotSpot"), g && g.length > 0 && (h.hotSpot = {
                x: g[0].getAttribute("x"),
                y: g[0].getAttribute("y"),
                xunits: g[0].getAttribute("xunits"),
                yunits: g[0].getAttribute("yunits")
            }), g = w(a, "Icon"), g && g.length > 0 && (h.href = t(w(g[0], "href")[0]), h.url = cleanURL(d, h.href), l[h.url] && (h.url = l[h.url].dataUrl), h.dim = {
                x: parseInt(t(v(g[0], s, "x")[0], h.dim.x)),
                y: parseInt(t(v(g[0], s, "y")[0], h.dim.y)),
                w: parseInt(t(v(g[0], s, "w")[0], h.dim.w)),
                h: parseInt(t(v(g[0], s, "h")[0], h.dim.h))
            }, h.img = new Image, h.img.onload = function () {
                h.dim.w < 0 || h.dim.h < 0 ? (h.dim.w = this.width, h.dim.h = this.height) : h.dim.th = this.height
            }, h.img.src = h.url, h.img.width > 0 && (h.dim.w < 0 || h.dim.h < 0 ? (h.dim.w = h.img.width, h.dim.h = h.img.height) : h.dim.th = h.img.height))
        }
        return g = w(a, "LineStyle"), g && g.length > 0 && (f.line.color = t(w(g[0], "color")[0], f.line.color), f.line.colorMode = t(w(g[0], "colorMode")[0], f.line.colorMode), f.line.width = t(w(g[0], "width")[0], f.line.width)), g = w(a, "PolyStyle"), g && g.length > 0 && (f.poly.color = t(w(g[0], "color")[0], f.poly.color), f.poly.colorMode = t(w(g[0], "colorMode")[0], f.poly.colorMode), f.poly.outline = u(w(g[0], "outline")[0], f.poly.outline), f.poly.fill = u(w(g[0], "fill")[0], f.poly.fill)), f
    }

    function e(a) {
        if (null == a || "object" != typeof a)return a;
        if (a.cloneNode)return a.cloneNode(!0);
        var b = new a.constructor;
        for (var c in a)b[c] = e(a[c]);
        return b
    }

    function f(a, b, f, g) {
        for (var h = w(a, "Pair"), j = new Object, k = 0; k < h.length; k++) {
            var l = t(w(h[k], "key")[0]), n = t(w(h[k], "Style")[0]), o = c(h[k]), p = o[0] ? cleanURL(g, o[0]) : b, q = o[1];
            n ? j[l] = d(n, p, q) : q && m[p][q] && (j[l] = e(m[p][q]))
        }
        j.normal ? m[b][f] = e(j.normal) : m[b][f] = e(r), j.highlight && i.processStyles && A(j.highlight), m[b][f].map = e(j)
    }

    function g(a, b) {
        for (var c = w(a, b), d = [], e = 0; e < c.length; e++) {
            var f = w(c[e], "coordinates");
            if (!f) {
                if (d.length > 0)break;
                return [{coordinates: []}]
            }
            for (var g = 0; g < f.length; g++) {
                var h = t(f[g]).trim();
                h = h.replace(/,\s+/g, ",");
                for (var i = h.split(/\s+/g), j = i.length, k = [], l = 0; j > l; l++)h = i[l].split(","), isNaN(h[0]) || isNaN(h[1]) || k.push({
                    lat: parseFloat(h[1]),
                    lng: parseFloat(h[0]),
                    alt: parseFloat(h[2])
                });
                d.push({coordinates: k})
            }
        }
        return d
    }

    google.maps.MVCObject.call(this);
    var h, i = new geoXML3.parserOptions(a), j = [], k = {}, l = {}, m = {};
    !i.infoWindow && i.singleInfoWindow && (i.infoWindow = new google.maps.InfoWindow);
    var n = function (a, b) {
        var c = {parser: this, docSet: b || [], remaining: 1, parseOnly: !(i.afterParse || i.processStyles)};
        thisDoc = new Object, thisDoc.internals = c, c.docSet.push(thisDoc), x(geoXML3.xmlParse(a), thisDoc)
    }, o = function (a, c) {
        h || (h = "geoXML3.instances[" + (geoXML3.instances.push(this) - 1) + "]"), "string" == typeof a && (a = [a]), a instanceof Blob && (a = [a]);
        for (var d, e = {
            parser: this,
            docSet: c || [],
            remaining: a.length,
            parseOnly: !(i.afterParse || i.processStyles)
        }, f = 0; f < a.length; f++) {
            var g = null, j = null;
            a[f]instanceof Blob ? (g = a[f].type, j = URL.createObjectURL(a[f])) : j = a[f];
            var l = cleanURL(defileURL(location.pathname), j);
            k[l] ? (d = k[l], d.reload = !0) : (d = new Object, d.baseUrl = l, e.docSet.push(d)), d.type = g, d.url = j, d.internals = e, b(d.url, d)
        }
    }, p = function (a) {
        a || (a = j[0]);
        var b;
        if (a.markers)for (b = 0; b < a.markers.length; b++)a.markers[b].infoWindow && a.markers[b].infoWindow.close(), a.markers[b].setVisible(!1);
        if (a.ggroundoverlays)for (b = 0; b < a.ggroundoverlays.length; b++)a.ggroundoverlays[b].setOpacity(0);
        if (a.gpolylines)for (b = 0; b < a.gpolylines.length; b++)a.gpolylines[b].infoWindow && a.gpolylines[b].infoWindow.close(), a.gpolylines[b].setMap(null);
        if (a.gpolygons)for (b = 0; b < a.gpolygons.length; b++)a.gpolygons[b].infoWindow && a.gpolygons[b].infoWindow.close(), a.gpolygons[b].setMap(null)
    }, q = function (a) {
        a || (a = j[0]);
        var b;
        if (a.markers)for (b = 0; b < a.markers.length; b++)a.markers[b].setVisible(!0);
        if (a.ggroundoverlays)for (b = 0; b < a.ggroundoverlays.length; b++)a.ggroundoverlays[b].setOpacity(a.ggroundoverlays[b].percentOpacity_);
        if (a.gpolylines)for (b = 0; b < a.gpolylines.length; b++)a.gpolylines[b].setMap(i.map);
        if (a.gpolygons)for (b = 0; b < a.gpolygons.length; b++)a.gpolygons[b].setMap(i.map)
    }, r = {
        balloon: {
            bgColor: "ffffffff",
            textColor: "ff000000",
            text: "<h3>$[name]</h3>\n<div>$[description]</div>\n<div>$[geDirections]</div>",
            displayMode: "default"
        },
        icon: {
            scale: 1,
            dim: {x: 0, y: 0, w: -1, h: -1},
            hotSpot: {x: .5, y: .5, xunits: "fraction", yunits: "fraction"}
        },
        line: {color: "ffffffff", colorMode: "normal", width: 1},
        poly: {color: "ffffffff", colorMode: "normal", fill: !0, outline: !0}
    }, s = "http://www.google.com/kml/ext/2.2", t = geoXML3.nodeValue, u = geoXML3.getBooleanValue, v = geoXML3.getElementsByTagNameNS, w = geoXML3.getElementsByTagName, x = function (a, n) {
        if (!a || "failed parse" == a)return geoXML3.log("Unable to retrieve " + n.url), i.failedParse && i.failedParse(n), void(n.failed = !0);
        if (a.parseError && 0 != a.parseError.errorCode) {
            var o = a.parseError, p = "Parse error in line " + o.line + ", col " + o.linePos + " (error code: " + o.errorCode + ")\n\nError Reason: " + o.reason + "Error Line: " + o.srcText;
            return geoXML3.log("Unable to retrieve " + n.url + ": " + p), i.failedParse && i.failedParse(n), void(n.failed = !0)
        }
        if (a.documentElement && "parsererror" == a.documentElement.nodeName)return geoXML3.log("Unable to retrieve " + n.url + ": " + a.documentElement.childNodes[0].nodeValue), i.failedParse && i.failedParse(n), void(n.failed = !0);
        if (!n)throw"geoXML3 internal error: render called with null document";
        var q;
        n.placemarks = [], n.groundoverlays = [], n.ggroundoverlays = [], n.networkLinks = [], n.gpolygons = [], n.gpolylines = [];
        for (var y = w(a, "styleUrl"), z = n.internals.docSet, q = 0; q < y.length; q++) {
            var G = t(y[q]).split("#")[0];
            if (G) {
                var H = cleanURL(n.baseDir, G);
                if (H !== n.baseUrl && !k[H]) {
                    var I, J = z.indexOfObjWithItem("baseUrl", H);
                    if (-1 != J) {
                        if (I = z[J], I.failed)continue
                    } else I = new Object, I.url = H, I.baseUrl = H, I.internals = n.internals, n.internals.docSet.push(I), n.internals.remaining++;
                    return void b(H, I, function (b) {
                        x(b, I), x(a, n)
                    })
                }
            }
        }
        n.styles = m[n.baseUrl] = m[n.baseUrl] || {};
        var K;
        for (y = w(a, "Style"), nodeCount = y.length, q = 0; q < nodeCount; q++) {
            thisNode = y[q];
            var K = thisNode.getAttribute("id");
            K && d(thisNode, n.baseUrl, K, n.baseDir)
        }
        for (y = w(a, "StyleMap"), q = 0; q < y.length; q++) {
            thisNode = y[q];
            var K = thisNode.getAttribute("id");
            K && f(thisNode, n.baseUrl, K, n.baseDir)
        }
        if ((i.processStyles || !i.createMarker) && B(n), n.reload && n.markers)for (q = 0; q < n.markers.length; q++)n.markers[q].active = !1;
        var L, M, N, O, P, N, Q, R, S = w(a, "Placemark");
        for (pm = 0; pm < S.length; pm++) {
            M = S[pm];
            var T = c(M);
            L = {
                name: t(w(M, "name")[0]),
                description: t(w(M, "description")[0]),
                styleUrl: T.join("#"),
                styleBaseUrl: T[0] ? cleanURL(n.baseDir, T[0]) : n.baseUrl,
                styleID: T[1],
                visibility: u(w(M, "visibility")[0], !0),
                balloonVisibility: u(v(M, s, "balloonVisibility")[0], !i.suppressInfoWindows),
                id: M.getAttribute("id"),
                index: pm
            }, L.style = m[L.styleBaseUrl] && m[L.styleBaseUrl][L.styleID] || e(r);
            var U = w(M, "Style");
            if (U && U.length > 0) {
                var V = d(M, "{inline}", "{inline}");
                A(V), V && (L.style = V)
            }
            /^https?:\/\//.test(L.description) && (L.description = ['<a href="', L.description, '">', L.description, "</a>"].join("")), L.vars = {
                display: {
                    name: "Name",
                    description: "Description",
                    address: "Street Address",
                    id: "ID",
                    Snippet: "Snippet",
                    geDirections: "Directions"
                },
                val: {
                    name: L.name || "",
                    description: L.description || "",
                    address: t(w(M, "address")[0], ""),
                    id: M.getAttribute("id") || "",
                    Snippet: t(w(M, "Snippet")[0], "")
                },
                directions: ["f=d", "source=GeoXML3"]
            };
            var W = w(M, "ExtendedData");
            if (W && W.length > 0)for (var X = w(W[0], "Data"), Y = 0; Y < X.length; Y++) {
                var Z = X[Y], $ = Z.getAttribute("name");
                if ($) {
                    var _ = t(w(Z, "displayName")[0], $), aa = t(w(Z, "value")[0]);
                    L.vars.val[$] = aa, L.vars.display[$] = _
                }
            }
            var ba = w(M, "coordinates"), ca = null;
            if (ba && ba.length > 0)for (var da = 0; da < ba.length; da++)if (ba[da].parentNode && ba[da].parentNode.nodeName) {
                var ea = ba[da].parentNode;
                switch (ca = ea.nodeName) {
                    case"Point":
                        L.Point = g(M, "Point")[0], L.latlng = new google.maps.LatLng(L.Point.coordinates[0].lat, L.Point.coordinates[0].lng), P = 1;
                        break;
                    case"LinearRing":
                        Q = w(M, "Polygon"), L.Polygon || (L.Polygon = [{
                            outerBoundaryIs: {coordinates: []},
                            innerBoundaryIs: [{coordinates: []}]
                        }]);
                        for (var fa = 0; fa < Q.length; fa++)L.Polygon[fa] = {
                            outerBoundaryIs: {coordinates: []},
                            innerBoundaryIs: [{coordinates: []}]
                        }, L.Polygon[fa].outerBoundaryIs = g(Q[fa], "outerBoundaryIs"), L.Polygon[fa].innerBoundaryIs = g(Q[fa], "innerBoundaryIs");
                        R = L.Polygon[0].outerBoundaryIs;
                        break;
                    case"LineString":
                        P = 0, L.LineString = g(M, "LineString")
                }
            }
            if (i.pmParseFn && i.pmParseFn(M, L), n.placemarks.push(L), L.Point) {
                google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, n.bounds.extend(L.latlng));
                var ga = i.createMarker || C, ha = !1;
                if (!i.createMarker && n && (n.markers = n.markers || [], n.reload))for (var J = 0; J < n.markers.length; J++)if (n.markers[J].id == L.id || !n.markers[J].id && n.markers[J].getPosition().equals(L.latlng)) {
                    ha = n.markers[J].active = !0;
                    break
                }
                if (!ha) {
                    var N = ga(L, n);
                    N && (N.active = L.visibility, N.id = L.id)
                }
            }
            var O, ia;
            n && (L.Polygon && (n.gpolygons = n.gpolygons || []), L.LineString && (n.gpolylines = n.gpolylines || []));
            var ja = i.createPolygon || F, ka = i.createLineString || E;
            L.Polygon && (O = ja(L, n), O && (O.active = L.visibility)), L.LineString && (ia = ka(L, n), ia && (ia.active = L.visibility)), google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, O && n.bounds.union(O.bounds), ia && n.bounds.union(ia.bounds))
        }
        if (n.reload && n.markers)for (q = n.markers.length - 1; q >= 0; q--)n.markers[q].active || (n.markers[q].infoWindow && n.markers[q].infoWindow.close(), n.markers[q].setMap(null), n.markers.splice(q, 1));
        if (n.reload && n.groundoverlays)for (q = 0; q < n.groundoverlays.length; q++)n.groundoverlays[q].active = !1;
        n && (n.groundoverlays = n.groundoverlays || []);
        var la, ma, na = w(a, "GroundOverlay");
        for (q = 0; q < na.length; q++) {
            M = na[q];
            var oa = cleanURL(n.baseDir, t(w(M, "href")[0]));
            l[oa] && (oa = l[oa].dataUrl), la = {
                name: t(w(M, "name")[0]),
                description: t(w(M, "description")[0]),
                icon: {href: oa},
                latLonBox: {
                    north: parseFloat(t(w(M, "north")[0])),
                    east: parseFloat(t(w(M, "east")[0])),
                    south: parseFloat(t(w(M, "south")[0])),
                    west: parseFloat(t(w(M, "west")[0]))
                },
                index: q
            }, google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, n.bounds.union(new google.maps.LatLngBounds(new google.maps.LatLng(la.latLonBox.south, la.latLonBox.west), new google.maps.LatLng(la.latLonBox.north, la.latLonBox.east))));
            var pa = w(M, "color");
            if (pa && pa.length > 0 ? la.opacity = geoXML3.getOpacity(t(pa[0])) : la.opacity = 1, n.groundoverlays.push(la), i.createOverlay)i.createOverlay(la, n); else {
                var ha = !1;
                if (n && (n.groundoverlays = n.groundoverlays || [], n.reload)) {
                    overlayBounds = new google.maps.LatLngBounds(new google.maps.LatLng(la.latLonBox.south, la.latLonBox.west), new google.maps.LatLng(la.latLonBox.north, la.latLonBox.east));
                    var qa = n.groundoverlays;
                    for (q = qa.length; q--;)if (qa[q].bounds().equals(overlayBounds) && qa.url_ === la.icon.href) {
                        ha = qa[q].active = !0;
                        break
                    }
                }
                ha || (ma = D(la, n), ma.active = !0)
            }
            if (n.reload && n.groundoverlays && n.groundoverlays.length) {
                var qa = n.groundoverlays;
                for (q = qa.length; q--;)qa[q].active || (qa[q].remove(), qa.splice(q, 1));
                n.groundoverlays = qa
            }
        }
        var ra, sa = document.location.pathname.split("/");
        sa = sa.splice(0, sa.length - 1).join("/");
        var ta = w(a, "NetworkLink");
        for (q = 0; q < ta.length; q++)M = ta[q], ra = {
            name: t(w(M, "name")[0]),
            link: {href: t(w(M, "href")[0]), refreshMode: t(w(M, "refreshMode")[0])}
        }, ra.link.refreshMode || (ra.link.refreshMode = "onChange"), "onInterval" === ra.link.refreshMode ? (ra.link.refreshInterval = parseFloat(t(w(M, "refreshInterval")[0])), isNaN(ra.link.refreshInterval) && (ra.link.refreshInterval = 0)) : "onChange" === ra.link.refreshMode && (ra.link.viewRefreshMode = t(w(M, "viewRefreshMode")[0]), ra.link.viewRefreshMode || (ra.link.viewRefreshMode = "never"), "onStop" === ra.link.viewRefreshMode && (ra.link.viewRefreshTime = t(w(M, "refreshMode")[0]), ra.link.viewFormat = t(w(M, "refreshMode")[0]), ra.link.viewFormat || (ra.link.viewFormat = "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]"))), /^[\/|http]/.test(ra.link.href) || (ra.link.href = sa + "/" + ra.link.href), "onInterval" === ra.link.refreshMode && ra.link.refreshInterval > 0 ? setInterval(h + '.parse("' + ra.link.href + '")', 1e3 * ra.link.refreshInterval) : "onChange" === ra.link.refreshMode && ("never" === ra.link.viewRefreshMode ? n.internals.parser.parse(ra.link.href, n.internals.docSet) : "onStop" === ra.link.viewRefreshMode);
        if (n.bounds && (n.internals.bounds = n.internals.bounds || new google.maps.LatLngBounds, n.internals.bounds.union(n.bounds)), (n.markers || n.groundoverlays || n.gpolylines || n.gpolygons) && (n.internals.parseOnly = !1), !n.internals.parseOnly && n.baseUrl)if (k[n.baseUrl])for (var q in k[n.baseUrl])k[n.baseUrl][q] = n[q]; else j.push(n), k[n.baseUrl] = n;
        n.internals.remaining--, 0 === n.internals.remaining && (i.zoom && n.internals.bounds && !n.internals.bounds.isEmpty() && i.map && i.map.fitBounds(n.internals.bounds), i.afterParse && i.afterParse(n.internals.docSet), google.maps.event.trigger(n.internals.parser, "parsed"))
    }, y = function (a, b) {
        var c = {};
        a = a || "ffffffff";
        var d = a.substr(0, 2), e = a.substr(2, 2), f = a.substr(4, 2), g = a.substr(6, 2);
        return c.opacity = parseInt(d, 16) / 256, c.color = "random" === b ? z(g, f, e) : "#" + g + f + e, c
    }, z = function (a, b, c) {
        var d = {rr: a, gg: b, bb: c};
        for (var e in d) {
            var f = d[e];
            null == f && (f = "ff"), f = Math.round(Math.random() * parseInt(a, 16)).toString(16), 1 === f.length && (f = "0" + f), d[e] = f
        }
        return "#" + d.rr + d.gg + d.bb
    }, A = function (a) {
        var b = a.icon;
        if (b && b.href) {
            if (b.img && !b.img.complete && b.dim.w < 0 && b.dim.h < 0)return b.markerBacklog = [], void(b.img.onload = function () {
                b.dim.w < 0 || b.dim.h < 0 ? (b.dim.w = this.width, b.dim.h = this.height) : b.dim.th = this.height, A(a);
                for (var c = 0; c < b.markerBacklog.length; c++) {
                    var d = b.markerBacklog[c][0], e = b.markerBacklog[c][1];
                    C(d, e), d.marker && (d.marker.active = !0)
                }
                delete b.markerBacklog
            });
            b.img && b.img.complete ? b.dim.w < 0 || b.dim.h < 0 ? (b.dim.w = b.img.width, b.dim.h = b.img.height) : b.dim.th = b.img.height : (b.dim.whGuess = !0, b.dim.w = 32, b.dim.h = 32, b.dim.th = 32);
            var c = Math.round, d = b.dim.y;
            "undefined" != typeof b.dim.th && b.dim.th != b.dim.h && (d = Math.abs(d - (b.dim.th - b.dim.h)));
            var e, f, g = {
                x: b.dim.x * b.scale,
                y: d * b.scale,
                w: b.dim.w * b.scale,
                h: b.dim.h * b.scale,
                aX: b.hotSpot.x * b.scale,
                aY: b.hotSpot.y * b.scale,
                iW: (b.img ? b.img.width : b.dim.w) * b.scale,
                iH: (b.img ? b.img.height : b.dim.h) * b.scale
            };
            switch (b.hotSpot.xunits) {
                case"fraction":
                    e = c(g.aX * b.dim.w);
                    break;
                case"insetPixels":
                    e = c(b.dim.w * b.scale - g.aX);
                    break;
                default:
                    e = c(g.aX)
            }
            f = g.h - c(("fraction" === b.hotSpot.yunits ? b.dim.h : 1) * g.aY);
            var h = new google.maps.Point(e, f), i = b.dim.whGuess ? null : new google.maps.Size(c(g.w), c(g.h)), j = 1 == b.scale ? null : b.dim.whGuess ? new google.maps.Size(c(g.w), c(g.h)) : new google.maps.Size(c(g.iW), c(g.iH)), k = new google.maps.Point(c(g.x), c(g.y));
            l[b.url] && (b.url = l[b.url].dataUrl), b.marker = {
                url: b.url,
                size: i,
                origin: k,
                anchor: h,
                scaledSize: j
            };
            var m = /\/(red|blue|green|yellow|lightblue|purple|pink|orange)(-dot)?\.png/, n = new google.maps.Size(59, 32), o = new google.maps.Point(16, 32);
            m.test(b.href) ? b.shadow = {
                url: "http://maps.google.com/mapfiles/ms/micons/msmarker.shadow.png",
                size: n,
                origin: null,
                anchor: o,
                scaledSize: n
            } : b.href.indexOf("-pushpin.png") > -1 && (b.shadow = {
                url: "http://maps.google.com/mapfiles/ms/micons/pushpin_shadow.png",
                size: n,
                origin: null,
                anchor: o,
                scaledSize: n
            })
        }
    }, B = function (a) {
        for (var b in a.styles)A(a.styles[b])
    }, C = function (a, b) {
        var c = a.style.icon;
        if (!c.marker && c.img)return c.markerBacklog = c.markerBacklog || [], void c.markerBacklog.push([a, b]);
        var d = geoXML3.combineOptions(i.markerOptions, {
            map: i.map,
            position: new google.maps.LatLng(a.Point.coordinates[0].lat, a.Point.coordinates[0].lng),
            title: a.name,
            zIndex: Math.round(-1e5 * a.Point.coordinates[0].lat) << 5,
            icon: c.marker,
            shadow: c.shadow,
            flat: !c.shadow,
            visible: a.visibility
        }), e = new google.maps.Marker(d);
        return b && b.markers.push(e), G(a, b, e), a.marker = e, e
    }, D = function (a, b) {
        if (!window.ProjectedOverlay)throw"geoXML3 error: ProjectedOverlay not found while rendering GroundOverlay from KML";
        var c = new google.maps.LatLngBounds(new google.maps.LatLng(a.latLonBox.south, a.latLonBox.west), new google.maps.LatLng(a.latLonBox.north, a.latLonBox.east)), d = geoXML3.combineOptions(i.overlayOptions, {
            percentOpacity: 100 * a.opacity,
            index: a.index
        }), e = new ProjectedOverlay(i.map, a.icon.href, c, d);
        return b && (b.ggroundoverlays = b.ggroundoverlays || [], b.ggroundoverlays.push(e)), "function" == typeof i.onAfterCreateGroundOverlay && i.onAfterCreateGroundOverlay(e), e
    }, E = function (a, b) {
        for (var c = [], d = new google.maps.LatLngBounds, e = 0; e < a.LineString.length; e++) {
            for (var f = [], g = a.LineString[e].coordinates, h = 0; h < g.length; h++) {
                var j = new google.maps.LatLng(g[h].lat, g[h].lng);
                f.push(j), d.extend(j)
            }
            c.push(f)
        }
        var k = (c[0][Math.floor(f.length / 2)], y(a.style.line.color, a.style.line.colorMode)), l = geoXML3.combineOptions(i.polylineOptions, {
            map: i.map,
            path: f,
            strokeColor: k.color,
            strokeWeight: a.style.line.width,
            strokeOpacity: k.opacity,
            title: a.name,
            visible: a.visibility,
            index: a.index
        });
        if (c.length > 1) {
            l.paths = c;
            var m = new MultiGeometry(l)
        } else {
            l.path = c[0];
            var m = new google.maps.Polyline(l)
        }
        return m.bounds = d, G(a, b, m), b && b.gpolylines.push(m), a.polyline = m, "function" == typeof i.onAfterCreatePolyLine && i.onAfterCreatePolyLine(m, a), m
    }, F = function (a, b) {
        for (var c = new google.maps.LatLngBounds, d = 0, e = [], f = 0; f < a.Polygon.length; f++) {
            for (var g = 0; g < a.Polygon[f].outerBoundaryIs.length; g++) {
                for (var h = a.Polygon[f].outerBoundaryIs[g].coordinates, j = [], k = 0; k < h.length; k++) {
                    var l = new google.maps.LatLng(h[k].lat, h[k].lng);
                    j.push(l), c.extend(l)
                }
                e.push(j), d += j.length
            }
            for (var g = 0; g < a.Polygon[f].innerBoundaryIs.length; g++) {
                for (var h = a.Polygon[f].innerBoundaryIs[g].coordinates, j = [], k = 0; k < h.length; k++) {
                    var l = new google.maps.LatLng(h[k].lat, h[k].lng);
                    j.push(l), c.extend(l)
                }
                e.push(j), d += j.length
            }
        }
        var m = y(a.style.line.color, a.style.line.colorMode), n = y(a.style.poly.color, a.style.poly.colorMode);
        a.style.poly.fill || (n.opacity = 0);
        var o = a.style.line.width;
        a.style.poly.outline || (o = 0, m.opacity = 0);
        var p = geoXML3.combineOptions(i.polygonOptions, {
            map: i.map,
            paths: e,
            title: a.name,
            strokeColor: m.color,
            strokeWeight: o,
            strokeOpacity: m.opacity,
            fillColor: n.color,
            fillOpacity: n.opacity,
            visible: a.visibility,
            index: a.index
        }), q = new google.maps.Polygon(p);
        return q.bounds = c, G(a, b, q), b && b.gpolygons.push(q), a.polygon = q, "function" == typeof i.onAfterCreatePolygon && i.onAfterCreatePolygon(q, a), q
    }, G = function (a, b, c) {
        var d = a.style.balloon, e = a.vars;
        if (a.balloonVisibility && "hide" !== d.displayMode) {
            if (!a.latlng || i.suppressDirections && i.suppressDirections)e.val.geDirections = ""; else {
                e.directions.push("sll=" + a.latlng.toUrlValue());
                var f = "http://maps.google.com/maps?" + e.directions.join("&"), g = encodeURIComponent(e.val.address || a.latlng.toUrlValue()).replace(/\%20/g, "+");
                e.val.geDirections = '<a href="' + f + "&daddr=" + g + '" target=_blank>To Here</a> - <a href="' + f + "&saddr=" + g + '" target=_blank>From Here</a>'
            }
            var h = d.text.replace(/\$\[(\w+(\/displayName)?)\]/g, function (a, b, c) {
                return c ? e.display[b] : e.val[b]
            }), j = "geoxml3_infowindow geoxml3_style_" + a.styleID, k = [];
            "ffffffff" != d.bgColor && k.push("background: " + y(d.bgColor).color + ";"), "ff000000" != d.textColor && k.push("color: " + y(d.textColor).color + ";");
            var l = k.length ? ' style="' + k.join(" ") + '"' : "", m = geoXML3.combineOptions(i.infoWindowOptions, {
                content: '<div class="' + j + '"' + l + ">" + h + "</div>",
                pixelOffset: new google.maps.Size(0, 2)
            });
            c.infoWindow = i.infoWindow || new google.maps.InfoWindow(m), delete m.content, c.infoWindowOptions = m, google.maps.event.addListener(c, "click", function (a) {
                var b = this.infoWindow;
                b.close(), b.setOptions(this.infoWindowOptions), a && a.latLng ? b.setPosition(a.latLng) : this.bounds && b.setPosition(this.bounds.getCenter()), google.maps.event.addListenerOnce(b, "domready", function () {
                }), b.open(this.map, this.bounds ? null : this), "function" == typeof this.infoWindow.$onOpen && this.infoWindow.$onOpen(c)
            })
        }
    };
    return {
        options: i,
        docs: j,
        docsByUrl: k,
        kmzMetaData: l,
        parse: o,
        render: x,
        parseKmlString: n,
        hideDocument: p,
        showDocument: q,
        processStyles: B,
        createMarker: C,
        createOverlay: D,
        createPolyline: E,
        createPolygon: F
    }
}, geoXML3.getOpacity = function (a) {
    if (a && "" !== a && 8 == a.length) {
        var b = parseInt(a.substr(0, 2), 16);
        return b / 255
    }
    return 1
}, geoXML3.log = function (a) {
    window.console ? console.log(a) : alert("log:" + a)
}, geoXML3.parserOptions = function (a) {
    if (this.map = null, this.zoom = !0, this.singleInfoWindow = !1, this.suppressInfoWindows = !1, this.processStyles = !1, this.markerOptions = {}, this.infoWindowOptions = {}, this.overlayOptions = {}, this.afterParse = null, this.failedParse = null, this.createMarker = null, this.createOverlay = null, a)for (var b in a)a.hasOwnProperty(b) && (this[b] = a[b]);
    return this
}, geoXML3.combineOptions = function (a, b) {
    var c = {};
    if (a)for (var d in a)a.hasOwnProperty(d) && (c[d] = a[d]);
    if (b)for (d in b)b.hasOwnProperty(d) && void 0 === c[d] && (c[d] = b[d]);
    return c
}, geoXML3.parserOptions.prototype.combineOptions = geoXML3.combineOptions, geoXML3.fetchers = [], geoXML3.xmlParse = function (a) {
    if ("undefined" != typeof ActiveXObject || "ActiveXObject"in window) {
        var b = new ActiveXObject("Microsoft.XMLDOM");
        return b.loadXML(a), b
    }
    return "undefined" != typeof DOMParser ? (new DOMParser).parseFromString(a, "text/xml") : document.createElement("div", null)
}, geoXML3.isParseError = function (a) {
    if ("undefined" != typeof ActiveXObject || "ActiveXObject"in window)return !1;
    var b = new DOMParser, c = b.parseFromString("<", "text/xml"), d = c.getElementsByTagName("parsererror")[0].namespaceURI;
    return "http://www.w3.org/1999/xhtml" === d ? a.getElementsByTagName("parsererror").length > 0 : a.getElementsByTagNameNS(d, "parsererror").length > 0
}, geoXML3.fetchXML = function (a, b) {
    function c() {
        b()
    }

    var d = new Object;
    if (geoXML3.fetchers.length)d = geoXML3.fetchers.pop(); else if (window.XMLHttpRequest)d.fetcher = new window.XMLHttpRequest; else if (window.ActiveXObject) {
        for (var e = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP"], f = 0; f < e.length; f++)try {
            d.fetcher = new ActiveXObject(e[f]);
            break
        } catch (g) {
            continue
        }
        if (!d.fetcher)return geoXML3.log("Unable to create XHR object"), b(null), null
    }
    return d.fetcher.open("GET", a, !0), d.fetcher.overrideMimeType && d.fetcher.overrideMimeType("text/xml"), d.fetcher.onreadystatechange = function () {
        if (4 === d.fetcher.readyState) {
            if (d.xhrtimeout && clearTimeout(d.xhrtimeout), d.fetcher.status >= 400)geoXML3.log("HTTP error " + d.fetcher.status + " retrieving " + a), b(); else {
                if (d.fetcher.responseXML) {
                    var c = d.fetcher.responseXML;
                    !c || c.documentElement || c.ownerElement || c.loadXML(d.fetcher.responseText)
                } else c = geoXML3.xmlParse(d.fetcher.responseText);
                c.parseError && 0 != c.parseError.errorCode ? (geoXML3.log("XML parse error " + c.parseError.errorCode + ", " + c.parseError.reason + "\nLine:" + c.parseError.line + ", Position:" + c.parseError.linepos + ", srcText:" + c.parseError.srcText), c = "failed parse") : geoXML3.isParseError(c) && (geoXML3.log("XML parse error"), c = "failed parse"), b(c)
            }
            geoXML3.fetchers.push(d)
        }
    }, d.xhrtimeout = setTimeout(c, 6e4), d.fetcher.send(null), null
};
var IEversion = function () {
    var a = -1;
    if ("Microsoft Internet Explorer" == navigator.appName) {
        var b = navigator.userAgent, c = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
        null != c.exec(b) && (a = parseFloat(RegExp.$1))
    }
    return a
};
geoXML3.fetchZIP = function (a, b, c) {
    new ZipFile(a, function (d) {
        for (var e = 0; e < d.status.length; e++) {
            var f = d.status[e];
            if (0 == f.indexOf("ERROR"))return geoXML3.log("HTTP/ZIP error retrieving " + a + ": " + f), void b();
            0 == f.indexOf("WARNING") && geoXML3.log("HTTP/ZIP warning retrieving " + a + ": " + f)
        }
        for (var g, h = 0, e = 0; e < d.entries.length; e++) {
            var i = d.entries[e].name;
            /\.kml$/.test(i) && (h++, 1 == h ? g = e : geoXML3.log("KMZ warning retrieving " + a + ': found extra KML "' + i + '" in KMZ; discarding...'))
        }
        for (var j = cleanURL(defileURL(a), a) + "/", k = {
            timer: null,
            extractLeft: 0,
            timerCalls: 0
        }, l = function (a, d) {
            var e = cleanURL(j, a.name), f = a.name.substring(a.name.lastIndexOf(".") + 1).toLowerCase();
            if (k.extractLeft--, "string" == typeof d.description && "Error" == d.name)return geoXML3.log("KMZ error extracting " + e + ": " + d.description), void b();
            var g;
            "jpg" === f && (f = "jpeg"), g = /^(gif|jpeg|png)$/.test(f) ? "image/" + f : "mp3" === f ? "audio/mpeg" : "m4a" === f ? "audio/mp4" : "m4a" === f ? "audio/MP4-LATM" : "application/octet-stream", c.kmzMetaData[e] = {}, c.kmzMetaData[e].entry = a, c.kmzMetaData[e].dataUrl = "data:" + g + ";base64," + base64Encode(d), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && (IEversion() < 8 && c.kmzMetaData[e].dataUrl.length > 2071 || 9 > IEversion && c.kmzMetaData[e].dataUrl.length > 32767) && (c.kmzMetaData[e].dataUrl = "data:image/gif;base64,R0lGODlhDwAQAOMPADBPvSpQ1Dpoyz1p6FhwvU2A6ECP63CM04CWxYCk+V6x+UK++Jao3rvC3fj7+v///yH5BAEKAA8ALAAAAAAPABAAAASC8Mk5mwCAUMlWwcLRHEelLAoGDMgzSsiyGCAhCETDPMh5XQCBwYBrNBIKWmg0MCQHj8MJU5IoroYCY6AAAgrDIbbQDGIK6DR5UPhlNo0JAlSUNAiDgH7eNAxEDWAKCQM2AAFheVxYAA0AIkFOJ1gBcQQaUQKKA5w7LpcEBwkJaKMUEQA7"), c.kmzMetaData[internalSrc(a.name)] = c.kmzMetaData[e]
        }, m = function (c, d) {
            return "string" == typeof d.description && "Error" == d.name ? (geoXML3.log("KMZ error extracting " + mdUrl + ": " + d.description), void b()) : (clearTimeout(k.timer), k.extractLeft <= 1 ? (k.extractLeft--, void b(geoXML3.xmlParse(d))) : (k.timerCalls++, void(k.timerCalls < 100 ? k.timer = setTimeout(function () {
                m(c, d)
            }, 100) : (geoXML3.log("KMZ warning extracting " + a + ": entire ZIP has not been extracted after 10 seconds; running through KML, anyway..."), k.extractLeft--, b(geoXML3.xmlParse(d))))))
        }, e = 0; e < d.entries.length; e++) {
            var n = d.entries[e], o = n.name.substring(n.name.lastIndexOf(".") + 1).toLowerCase();
            /^(gif|jpe?g|png|kml)$/.test(o) && ("kml" !== o || e == g) && (c || "kml" == o) && (k.extractLeft++, "kml" === o ? n.extract(m) : n.extract(l))
        }
    })
}, geoXML3.nodeValue = function (a, b) {
    var c = "";
    if (!a)return "undefined" == typeof b || null === b ? null : b;
    if (3 == a.nodeType || 4 == a.nodeType || 2 == a.nodeType)c += a.nodeValue; else if (1 == a.nodeType || 9 == a.nodeType || 11 == a.nodeType)for (var d = 0; d < a.childNodes.length; ++d)c += arguments.callee(a.childNodes[d]);
    return c
}, geoXML3.getBooleanValue = function (a, b) {
    var c = geoXML3.nodeValue(a);
    return null === c ? b || !1 : (c = parseInt(c), isNaN(c) ? !0 : 0 == c ? !1 : !0)
}, geoXML3.getElementsByTagNameNS = function (a, b, c) {
    if (a && "undefined" != typeof a.getElementsByTagNameNS)return a.getElementsByTagNameNS(b, c);
    if (!a)return [];
    var d = a.documentElement || a.ownerDocument && a.ownerDocument.documentElement;
    if (!d || !d.attributes)return [];
    for (var e = 0; e < d.attributes.length; e++) {
        var f = d.attributes[e];
        if ("xmlns" === f.prefix && f.nodeValue === b)return a.getElementsByTagName(f.baseName + ":" + c);
        if ("xmlns" === f.nodeName && f.nodeValue === b)return "undefined" != typeof a.selectNodes ? (d.ownerDocument.getProperty("SelectionNamespaces") || d.ownerDocument.setProperty("SelectionNamespaces", "xmlns:defaultNS='" + b + "'"), a.selectNodes(".//defaultNS:" + c)) : (d.setAttribute("xmlns:defaultNS", b), a.getElementsByTagName("defaultNS:" + c))
    }
    return geoXML3.getElementsByTagName(a, c)
}, geoXML3.getElementsByTagName = function (a, b) {
    return a && "undefined" != typeof a.getElementsByTagNameNS ? a.getElementsByTagName(b) : a.getElementsByTagName(b)
};
var toAbsURL = function (a, b) {
    var c, d, e, f = location.protocol + "://" + location.host;
    if (!b.length)return "";
    if (/^\w+:/.test(b))return b;
    if (0 == b.indexOf("/"))return f + b;
    if (c = a.replace(/\/[^\/]*$/, ""), d = b.match(/\.\.\//g))for (b = b.substring(3 * d.length), e = d.length; e--;)c = c.substring(0, c.lastIndexOf("/"));
    return f + c + "/" + b
}, internalSrc = function (a) {
    var b = document.location.href;
    b = b.substring(0, b.lastIndexOf("/") + 1);
    var c = b + a;
    return c
}, dehostURL = function (a) {
    var b = location.protocol + "://" + location.host;
    return b = b.replace(/([\.\\\+\*\?\[\^\]\$\(\)])/g, "\\$1"), a.replace(new RegExp("^" + b, "i"), "")
}, cleanURL = function (a, b) {
    return dehostURL(toAbsURL(a ? a.split("#")[0].split("?")[0] : defileURL(location.pathname), b ? b.split("#")[0].split("?")[0] : ""))
}, defileURL = function (a) {
    return a ? a.substr(0, a.lastIndexOf("/") + 1) : "/"
};
Array.prototype.hasObject = Array.indexOf ? function (a) {
    return -1 !== this.indexOf(a)
} : function (a) {
    for (var b = this.length + 1; b--;)if (this[b - 1] === a)return !0;
    return !1
}, Array.prototype.hasItemInObj = function (a, b) {
    for (var c = this.length + 1; c--;)if (this[c - 1][a] === b)return !0;
    return !1
}, Array.prototype.indexOf || (Array.prototype.indexOf = function (a, b) {
    null == b ? b = 0 : 0 > b && (b = Math.max(0, this.length + b));
    for (var c = b, d = this.length; d > c; c++)if (this[c] === a)return c;
    return -1
}), Array.prototype.indexOfObjWithItem = function (a, b, c) {
    null == c ? c = 0 : 0 > c && (c = Math.max(0, this.length + c));
    for (var d = c, e = this.length; e > d; d++)if (this[d][a] === b)return d;
    return -1
};
var base64Encode = function (a) {
    for (var b, c, d, e, f, g, h, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", j = "", k = 0; k < a.length;)b = a[k++], c = a[k++], d = a[k++], e = b >> 2, f = (3 & b) << 4 | c >> 4, g = (15 & c) << 2 | d >> 6, h = 63 & d, void 0 == c ? g = h = 64 : void 0 == d && (h = 64), j = j + i.charAt(e) + i.charAt(f) + i.charAt(g) + i.charAt(h);
    return j
};
!function (a) {
    "use strict";
    a.module("LogicifyGMap", [])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").service("SmartCollection", [function () {
        function b(b) {
            var d = this, e = null;
            d.next = function () {
                return null == e ? e = 0 : e++, void 0 !== d[e] ? d[e] : void(e = null)
            }, d.setIterator = function (b) {
                if (a.isNumber(b) && NaN !== b) {
                    if (void 0 === d[b])throw new Error("Can not reach this element, because it doesn't exist. Index: " + b);
                    e = b
                }
            }, Array.isArray(b) && b.forEach(function (a, b) {
                d.push(a)
            }), d._uid = c++;
            var f = [], g = [], h = d.push;
            d.push = function () {
                var a = Array.prototype.slice.call(arguments), b = h.apply(d, a);
                return a.forEach(function (a) {
                    f.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            };
            var i = d.pop;
            d.pop = function () {
                var a = Array.prototype.slice.call(arguments), b = i.apply(d, a);
                return g.forEach(function (a) {
                    a.apply(d, [b])
                }), b
            };
            var j = d.unshift;
            d.unshift = function () {
                var a = Array.prototype.slice.call(arguments), b = j.apply(d, a);
                return a.forEach(function (a) {
                    f.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            }, d.shift, d.shift = function () {
                var a = Array.prototype.slice.call(arguments), b = j.apply(d, a);
                return g.forEach(function (a) {
                    a.apply(d, [b])
                }), b
            };
            var k = d.splice;
            d.splice = function () {
                var a = Array.prototype.slice.call(arguments), b = k.apply(d, a);
                return b.forEach(function (a) {
                    g.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            }, d.removeQuietly = k, d.onRemoveItem = function (a) {
                "function" == typeof a && g.push(a)
            }, d.onAddItem = function (a) {
                "function" == typeof a && f.push(a)
            }
        }

        var c = 0;
        return Array.isArray = function (a) {
            return "[object Array]" === Object.prototype.toString.call(a) || null != a && a.constructor && "SmartCollection" === a.constructor.name && "[object Array]" === Object.prototype.toString.call(a.__proto__.__proto__)
        }, b.prototype = Object.create(Array.prototype), b.prototype.constructor = b, b
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                    "function" != typeof f.$onOpen && (f.$onOpen = function (a) {
                        "function" == typeof f.onAfterOpen && f.onAfterOpen(a)
                    })
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a, b) {
    "use strict";
    a.module("LogicifyGMap").directive("xmlOverlays", ["$timeout", "$log", "$q", "$compile", "$http", "SmartCollection", function (c, d, e, f, g, h) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (e, f, i, j) {
                function k(b, c) {
                    var d = {};
                    return a.extend(d, e.parserOptions), d.map = b, d.afterParse = o, d.onAfterCreateGroundOverlay = e.events.onAfterCreateGroundOverlay, d.onAfterCreatePolygon = e.events.onAfterCreatePolygon, d.onAfterCreatePolyLine = e.events.onAfterCreatePolyLine, d.failedParse = p, d.infoWindow = c, d
                }

                function l() {
                    return e.$watch("kmlCollection._uid", function (a, b) {
                        if (null == a)if (e.kmlCollection = new h(e.$eval(i.kmlCollection)), (e.downLoadingStarted === !0 || e.parserStarted === !0) && (e.cancel = !0), e.cancel === !0)var c = e.$watch("cancel", function (a, b) {
                            a === !0 && (u(), c())
                        }); else u()
                    })
                }

                function m(a) {
                    null != a && (a.downloadNext = !1, e.currentDocument = a, w(a))
                }

                function n(a) {
                    t(a)
                }

                function o(a) {
                    return e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (a[0].$uid = (new Date).getTime() + "-index-" + Math.floor(-9 * Math.random()), e.currentDocument.doc = a, "function" == typeof e.events.onAfterParse && e.events.onAfterParse(a), void q(null, e.currentDocument))
                }

                function p() {
                    if (e.cancel === !0)return c(function () {
                        e.cancel = !1
                    }), !1;
                    var a = {message: "Failed to parse file url: " + e.currentDocument.url};
                    d.error(a.message), "function" == typeof e.events.onAfterParseFailed && e.events.onAfterParseFailed(a), q(a)
                }

                function q(a, b) {
                    r("parserStarted", !1, v), e.currentDocument.downloadNext === !1 ? (delete e.currentDocument.downloadNext, s()) : (e.currentDocument = e.kmlCollection.next(), w(e.currentDocument))
                }

                function r(a, b, c) {
                    e[a] = b, "function" == typeof c && c()
                }

                function s() {
                    e.globalBounds = new google.maps.LatLngBounds, 1 != e.kmlCollection.length && e.fitBoundsAfterAll !== !1 ? (e.kmlCollection.forEach(function (a) {
                        e.globalBounds.extend(a.doc[0].bounds.getCenter())
                    }), c(function () {
                        e.gMap.fitBounds(e.globalBounds)
                    }, 10)) : e.kmlCollection.length > 0 && e.fitBoundsAfterAll !== !1 && c(function () {
                        e.gMap.fitBounds(e.kmlCollection[0].doc[0].bounds)
                    }, 10)
                }

                function t(b) {
                    if (b) {
                        y.hideDocument(b.doc[0]);
                        var c = y.docs.indexOf(b.doc[0]);
                        c > -1 && (delete y.docsByUrl[b.doc[0].baseUrl], y.docs.splice(c, 1), s())
                    } else a.forEach(y.docs, function (a) {
                        y.hideDocument(a)
                    }), y.docs.splice(0, y.docs.length), y.docsByUrl = {}, e.globalBounds = null, e.currentDocument = null
                }

                function u() {
                    Array.isArray(e.kmlCollection) && 0 !== e.kmlCollection.length ? (e.finished = !1, void 0 !== e.currentDocument && t(), e.currentDocument = e.kmlCollection.next(), e.kmlCollection.onAddItem(m), e.kmlCollection.onRemoveItem(n), w(e.currentDocument)) : e.currentDocument = null
                }

                function v() {
                    "function" == typeof e.onProgress && e.onProgress({
                        isDownloading: e.downLoadingStarted,
                        isParsing: e.parserStarted,
                        finished: e.finished
                    })
                }

                function w(a) {
                    return a ? e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (r("downLoadingStarted", !0, v), void(null != a.url ? g.get(a.url, {
                        responseType: "arraybuffer"
                    }).then(function (a) {
                        var b = new Blob([a.data], {type: a.headers()["content-type"]});
                        b.lastModifiedDate = new Date, b.name = "example" + b.lastModifiedDate, x(b)
                    }) : "String" == typeof a.content ? x(null, a.content) : a instanceof Blob ? x(a) : d.error("Incorrect file type. Should be an instance of a Blob or String (url)."))) : (r("finished", !0, v), s(), !1)
                }

                function x(a, b) {
                    return e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (r("parserStarted", !0), r("downLoadingStarted", !1, v), void(null == b ? y.parse(a) : y.parseKmlString(b)))
                }

                var y = null;
                e.kmlCollection = new h(e.$eval(i.kmlCollection)), e.events = e.$eval(i.gmapEvents) || {}, e.parserOptions = e.$eval(i.parserOptions) || {}, e.onProgress = e.$eval(i.onProgress), e.fitBoundsAfterAll = e.$eval(i.fitAllLayers), j.$mapReady(function (a) {
                    e.infowindow = e.$eval(i.infoWindow), e.collectionsWatcher = l(), e.gMap = a, e.infowindow && "function" == typeof e.infowindow.$ready ? e.infowindow.$ready(function (c) {
                        y = new b.parser(k(a, c)), u()
                    }) : (y = new b.parser(k(a)), u())
                }), e.cancel = !1, e.$on("$destroy", function () {
                    "function" == typeof e.collectionsWatcher && e.collectionsWatcher()
                })
            }
        }
    }])
}(angular, geoXML3), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(a) {
                var b = d.open;
                d.open = function (c, e) {
                    h = c, "function" == typeof c.openInfoWnd && c.openInfoWnd(a, c, e, d, b)
                };
                var c = d.close;
                if (d.close = function (a) {
                        h && ("function" == typeof h.closeInfoWnd && a === !0 ? h.closeInfoWnd(d, c) : c.apply(d, []))
                    }, g = !0, f.length > 0) {
                    for (var e = 0; e < f.length; e++)f[e](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1, h = null;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            }, arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular), window.google && google.maps && (MultiGeometry.prototype = new google.maps.MVCObject, MultiGeometry.prototype.changed = function (a) {
    if (this.polylines)for (var b = 0; b < this.polylines.length; b++)this.polylines[b].set(a, this.get(a))
}, MultiGeometry.prototype.setMap = function (a) {
    this.set("map", a)
}, MultiGeometry.prototype.getMap = function () {
    return this.get("map")
}), String.prototype.trim || (String.prototype.trim = function () {
    return this.replace(/^\s+|\s+$/g, "")
}), geoXML3 = window.geoXML3 || {instances: []}, geoXML3.parser = function (a) {
    function b(a, b, c) {
        return c = c || function (a) {
            x(a, b)
        }, "application/vnd.google-earth.kml+xml" !== b.type && "function" == typeof ZipFile && "object" == typeof JSIO && "function" == typeof JSIO.guessFileType && (contentType = JSIO.guessFileType(b.baseUrl), 3 === contentType ? contentType = JSIO.FileType.Binary : null, contentType == JSIO.FileType.Binary || contentType == JSIO.FileType.Unknown) ? (b.isCompressed = !0, b.baseDir = b.baseUrl + "/", void geoXML3.fetchZIP(a, c, b.internals.parser)) : (b.isCompressed = !1, b.baseDir = defileURL(b.baseUrl), void geoXML3.fetchXML(a, c))
    }

    function c(a) {
        var b = t(w(a, "styleUrl")[0]);
        if (b && -1 != b.indexOf("#"))var c = b.split("#"); else var c = ["", ""];
        return c
    }

    function d(a, b, c, d) {
        var f = "{inline}" === b ? e(r) : m[b][c] = m[b][c] || e(r), g = w(a, "BalloonStyle");
        g && g.length > 0 && (f.balloon.bgColor = t(w(g[0], "bgColor")[0], f.balloon.bgColor), f.balloon.textColor = t(w(g[0], "textColor")[0], f.balloon.textColor), f.balloon.text = t(w(g[0], "text")[0], f.balloon.text), f.balloon.displayMode = t(w(g[0], "displayMode")[0], f.balloon.displayMode));
        var g = w(a, "IconStyle");
        if (g && g.length > 0) {
            var h = f.icon;
            h.scale = parseFloat(t(w(g[0], "scale")[0], h.scale)), g = w(g[0], "hotSpot"), g && g.length > 0 && (h.hotSpot = {
                x: g[0].getAttribute("x"),
                y: g[0].getAttribute("y"),
                xunits: g[0].getAttribute("xunits"),
                yunits: g[0].getAttribute("yunits")
            }), g = w(a, "Icon"), g && g.length > 0 && (h.href = t(w(g[0], "href")[0]), h.url = cleanURL(d, h.href), l[h.url] && (h.url = l[h.url].dataUrl), h.dim = {
                x: parseInt(t(v(g[0], s, "x")[0], h.dim.x)),
                y: parseInt(t(v(g[0], s, "y")[0], h.dim.y)),
                w: parseInt(t(v(g[0], s, "w")[0], h.dim.w)),
                h: parseInt(t(v(g[0], s, "h")[0], h.dim.h))
            }, h.img = new Image, h.img.onload = function () {
                h.dim.w < 0 || h.dim.h < 0 ? (h.dim.w = this.width, h.dim.h = this.height) : h.dim.th = this.height
            }, h.img.src = h.url, h.img.width > 0 && (h.dim.w < 0 || h.dim.h < 0 ? (h.dim.w = h.img.width, h.dim.h = h.img.height) : h.dim.th = h.img.height))
        }
        return g = w(a, "LineStyle"), g && g.length > 0 && (f.line.color = t(w(g[0], "color")[0], f.line.color), f.line.colorMode = t(w(g[0], "colorMode")[0], f.line.colorMode), f.line.width = t(w(g[0], "width")[0], f.line.width)), g = w(a, "PolyStyle"), g && g.length > 0 && (f.poly.color = t(w(g[0], "color")[0], f.poly.color), f.poly.colorMode = t(w(g[0], "colorMode")[0], f.poly.colorMode), f.poly.outline = u(w(g[0], "outline")[0], f.poly.outline), f.poly.fill = u(w(g[0], "fill")[0], f.poly.fill)), f
    }

    function e(a) {
        if (null == a || "object" != typeof a)return a;
        if (a.cloneNode)return a.cloneNode(!0);
        var b = new a.constructor;
        for (var c in a)b[c] = e(a[c]);
        return b
    }

    function f(a, b, f, g) {
        for (var h = w(a, "Pair"), j = new Object, k = 0; k < h.length; k++) {
            var l = t(w(h[k], "key")[0]), n = t(w(h[k], "Style")[0]), o = c(h[k]), p = o[0] ? cleanURL(g, o[0]) : b, q = o[1];
            n ? j[l] = d(n, p, q) : q && m[p][q] && (j[l] = e(m[p][q]))
        }
        j.normal ? m[b][f] = e(j.normal) : m[b][f] = e(r), j.highlight && i.processStyles && A(j.highlight), m[b][f].map = e(j)
    }

    function g(a, b) {
        for (var c = w(a, b), d = [], e = 0; e < c.length; e++) {
            var f = w(c[e], "coordinates");
            if (!f) {
                if (d.length > 0)break;
                return [{coordinates: []}]
            }
            for (var g = 0; g < f.length; g++) {
                var h = t(f[g]).trim();
                h = h.replace(/,\s+/g, ",");
                for (var i = h.split(/\s+/g), j = i.length, k = [], l = 0; j > l; l++)h = i[l].split(","), isNaN(h[0]) || isNaN(h[1]) || k.push({
                    lat: parseFloat(h[1]),
                    lng: parseFloat(h[0]),
                    alt: parseFloat(h[2])
                });
                d.push({coordinates: k})
            }
        }
        return d
    }

    google.maps.MVCObject.call(this);
    var h, i = new geoXML3.parserOptions(a), j = [], k = {}, l = {}, m = {};
    !i.infoWindow && i.singleInfoWindow && (i.infoWindow = new google.maps.InfoWindow);
    var n = function (a, b) {
        var c = {parser: this, docSet: b || [], remaining: 1, parseOnly: !(i.afterParse || i.processStyles)};
        thisDoc = new Object, thisDoc.internals = c, c.docSet.push(thisDoc), x(geoXML3.xmlParse(a), thisDoc)
    }, o = function (a, c) {
        h || (h = "geoXML3.instances[" + (geoXML3.instances.push(this) - 1) + "]"), "string" == typeof a && (a = [a]), a instanceof Blob && (a = [a]);
        for (var d, e = {
            parser: this,
            docSet: c || [],
            remaining: a.length,
            parseOnly: !(i.afterParse || i.processStyles)
        }, f = 0; f < a.length; f++) {
            var g = null, j = null;
            a[f]instanceof Blob ? (g = a[f].type, j = URL.createObjectURL(a[f])) : j = a[f];
            var l = cleanURL(defileURL(location.pathname), j);
            k[l] ? (d = k[l], d.reload = !0) : (d = new Object, d.baseUrl = l, e.docSet.push(d)), d.type = g, d.url = j, d.internals = e, b(d.url, d)
        }
    }, p = function (a) {
        a || (a = j[0]);
        var b;
        if (a.markers)for (b = 0; b < a.markers.length; b++)a.markers[b].infoWindow && a.markers[b].infoWindow.close(), a.markers[b].setVisible(!1);
        if (a.ggroundoverlays)for (b = 0; b < a.ggroundoverlays.length; b++)a.ggroundoverlays[b].setOpacity(0);
        if (a.gpolylines)for (b = 0; b < a.gpolylines.length; b++)a.gpolylines[b].infoWindow && a.gpolylines[b].infoWindow.close(), a.gpolylines[b].setMap(null);
        if (a.gpolygons)for (b = 0; b < a.gpolygons.length; b++)a.gpolygons[b].infoWindow && a.gpolygons[b].infoWindow.close(), a.gpolygons[b].setMap(null)
    }, q = function (a) {
        a || (a = j[0]);
        var b;
        if (a.markers)for (b = 0; b < a.markers.length; b++)a.markers[b].setVisible(!0);
        if (a.ggroundoverlays)for (b = 0; b < a.ggroundoverlays.length; b++)a.ggroundoverlays[b].setOpacity(a.ggroundoverlays[b].percentOpacity_);
        if (a.gpolylines)for (b = 0; b < a.gpolylines.length; b++)a.gpolylines[b].setMap(i.map);
        if (a.gpolygons)for (b = 0; b < a.gpolygons.length; b++)a.gpolygons[b].setMap(i.map)
    }, r = {
        balloon: {
            bgColor: "ffffffff",
            textColor: "ff000000",
            text: "<h3>$[name]</h3>\n<div>$[description]</div>\n<div>$[geDirections]</div>",
            displayMode: "default"
        },
        icon: {
            scale: 1,
            dim: {x: 0, y: 0, w: -1, h: -1},
            hotSpot: {x: .5, y: .5, xunits: "fraction", yunits: "fraction"}
        },
        line: {color: "ffffffff", colorMode: "normal", width: 1},
        poly: {color: "ffffffff", colorMode: "normal", fill: !0, outline: !0}
    }, s = "http://www.google.com/kml/ext/2.2", t = geoXML3.nodeValue, u = geoXML3.getBooleanValue, v = geoXML3.getElementsByTagNameNS, w = geoXML3.getElementsByTagName, x = function (a, n) {
        if (!a || "failed parse" == a)return geoXML3.log("Unable to retrieve " + n.url), i.failedParse && i.failedParse(n), void(n.failed = !0);
        if (a.parseError && 0 != a.parseError.errorCode) {
            var o = a.parseError, p = "Parse error in line " + o.line + ", col " + o.linePos + " (error code: " + o.errorCode + ")\n\nError Reason: " + o.reason + "Error Line: " + o.srcText;
            return geoXML3.log("Unable to retrieve " + n.url + ": " + p), i.failedParse && i.failedParse(n), void(n.failed = !0)
        }
        if (a.documentElement && "parsererror" == a.documentElement.nodeName)return geoXML3.log("Unable to retrieve " + n.url + ": " + a.documentElement.childNodes[0].nodeValue), i.failedParse && i.failedParse(n), void(n.failed = !0);
        if (!n)throw"geoXML3 internal error: render called with null document";
        var q;
        n.placemarks = [], n.groundoverlays = [], n.ggroundoverlays = [], n.networkLinks = [], n.gpolygons = [], n.gpolylines = [];
        for (var y = w(a, "styleUrl"), z = n.internals.docSet, q = 0; q < y.length; q++) {
            var G = t(y[q]).split("#")[0];
            if (G) {
                var H = cleanURL(n.baseDir, G);
                if (H !== n.baseUrl && !k[H]) {
                    var I, J = z.indexOfObjWithItem("baseUrl", H);
                    if (-1 != J) {
                        if (I = z[J], I.failed)continue
                    } else I = new Object, I.url = H, I.baseUrl = H, I.internals = n.internals, n.internals.docSet.push(I), n.internals.remaining++;
                    return void b(H, I, function (b) {
                        x(b, I), x(a, n)
                    })
                }
            }
        }
        n.styles = m[n.baseUrl] = m[n.baseUrl] || {};
        var K;
        for (y = w(a, "Style"), nodeCount = y.length, q = 0; q < nodeCount; q++) {
            thisNode = y[q];
            var K = thisNode.getAttribute("id");
            K && d(thisNode, n.baseUrl, K, n.baseDir)
        }
        for (y = w(a, "StyleMap"), q = 0; q < y.length; q++) {
            thisNode = y[q];
            var K = thisNode.getAttribute("id");
            K && f(thisNode, n.baseUrl, K, n.baseDir)
        }
        if ((i.processStyles || !i.createMarker) && B(n), n.reload && n.markers)for (q = 0; q < n.markers.length; q++)n.markers[q].active = !1;
        var L, M, N, O, P, N, Q, R, S = w(a, "Placemark");
        for (pm = 0; pm < S.length; pm++) {
            M = S[pm];
            var T = c(M);
            L = {
                name: t(w(M, "name")[0]),
                description: t(w(M, "description")[0]),
                styleUrl: T.join("#"),
                styleBaseUrl: T[0] ? cleanURL(n.baseDir, T[0]) : n.baseUrl,
                styleID: T[1],
                visibility: u(w(M, "visibility")[0], !0),
                balloonVisibility: u(v(M, s, "balloonVisibility")[0], !i.suppressInfoWindows),
                id: M.getAttribute("id"),
                index: pm
            }, L.style = m[L.styleBaseUrl] && m[L.styleBaseUrl][L.styleID] || e(r);
            var U = w(M, "Style");
            if (U && U.length > 0) {
                var V = d(M, "{inline}", "{inline}");
                A(V), V && (L.style = V)
            }
            /^https?:\/\//.test(L.description) && (L.description = ['<a href="', L.description, '">', L.description, "</a>"].join("")), L.vars = {
                display: {
                    name: "Name",
                    description: "Description",
                    address: "Street Address",
                    id: "ID",
                    Snippet: "Snippet",
                    geDirections: "Directions"
                },
                val: {
                    name: L.name || "",
                    description: L.description || "",
                    address: t(w(M, "address")[0], ""),
                    id: M.getAttribute("id") || "",
                    Snippet: t(w(M, "Snippet")[0], "")
                },
                directions: ["f=d", "source=GeoXML3"]
            };
            var W = w(M, "ExtendedData");
            if (W && W.length > 0)for (var X = w(W[0], "Data"), Y = 0; Y < X.length; Y++) {
                var Z = X[Y], $ = Z.getAttribute("name");
                if ($) {
                    var _ = t(w(Z, "displayName")[0], $), aa = t(w(Z, "value")[0]);
                    L.vars.val[$] = aa, L.vars.display[$] = _
                }
            }
            var ba = w(M, "coordinates"), ca = null;
            if (ba && ba.length > 0)for (var da = 0; da < ba.length; da++)if (ba[da].parentNode && ba[da].parentNode.nodeName) {
                var ea = ba[da].parentNode;
                switch (ca = ea.nodeName) {
                    case"Point":
                        L.Point = g(M, "Point")[0], L.latlng = new google.maps.LatLng(L.Point.coordinates[0].lat, L.Point.coordinates[0].lng), P = 1;
                        break;
                    case"LinearRing":
                        Q = w(M, "Polygon"), L.Polygon || (L.Polygon = [{
                            outerBoundaryIs: {coordinates: []},
                            innerBoundaryIs: [{coordinates: []}]
                        }]);
                        for (var fa = 0; fa < Q.length; fa++)L.Polygon[fa] = {
                            outerBoundaryIs: {coordinates: []},
                            innerBoundaryIs: [{coordinates: []}]
                        }, L.Polygon[fa].outerBoundaryIs = g(Q[fa], "outerBoundaryIs"), L.Polygon[fa].innerBoundaryIs = g(Q[fa], "innerBoundaryIs");
                        R = L.Polygon[0].outerBoundaryIs;
                        break;
                    case"LineString":
                        P = 0, L.LineString = g(M, "LineString")
                }
            }
            if (i.pmParseFn && i.pmParseFn(M, L), n.placemarks.push(L), L.Point) {
                google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, n.bounds.extend(L.latlng));
                var ga = i.createMarker || C, ha = !1;
                if (!i.createMarker && n && (n.markers = n.markers || [], n.reload))for (var J = 0; J < n.markers.length; J++)if (n.markers[J].id == L.id || !n.markers[J].id && n.markers[J].getPosition().equals(L.latlng)) {
                    ha = n.markers[J].active = !0;
                    break
                }
                if (!ha) {
                    var N = ga(L, n);
                    N && (N.active = L.visibility, N.id = L.id)
                }
            }
            var O, ia;
            n && (L.Polygon && (n.gpolygons = n.gpolygons || []), L.LineString && (n.gpolylines = n.gpolylines || []));
            var ja = i.createPolygon || F, ka = i.createLineString || E;
            L.Polygon && (O = ja(L, n), O && (O.active = L.visibility)), L.LineString && (ia = ka(L, n), ia && (ia.active = L.visibility)), google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, O && n.bounds.union(O.bounds), ia && n.bounds.union(ia.bounds))
        }
        if (n.reload && n.markers)for (q = n.markers.length - 1; q >= 0; q--)n.markers[q].active || (n.markers[q].infoWindow && n.markers[q].infoWindow.close(), n.markers[q].setMap(null), n.markers.splice(q, 1));
        if (n.reload && n.groundoverlays)for (q = 0; q < n.groundoverlays.length; q++)n.groundoverlays[q].active = !1;
        n && (n.groundoverlays = n.groundoverlays || []);
        var la, ma, na = w(a, "GroundOverlay");
        for (q = 0; q < na.length; q++) {
            M = na[q];
            var oa = cleanURL(n.baseDir, t(w(M, "href")[0]));
            l[oa] && (oa = l[oa].dataUrl), la = {
                name: t(w(M, "name")[0]),
                description: t(w(M, "description")[0]),
                icon: {href: oa},
                latLonBox: {
                    north: parseFloat(t(w(M, "north")[0])),
                    east: parseFloat(t(w(M, "east")[0])),
                    south: parseFloat(t(w(M, "south")[0])),
                    west: parseFloat(t(w(M, "west")[0]))
                },
                index: q
            }, google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, n.bounds.union(new google.maps.LatLngBounds(new google.maps.LatLng(la.latLonBox.south, la.latLonBox.west), new google.maps.LatLng(la.latLonBox.north, la.latLonBox.east))));
            var pa = w(M, "color");
            if (pa && pa.length > 0 ? la.opacity = geoXML3.getOpacity(t(pa[0])) : la.opacity = 1, n.groundoverlays.push(la), i.createOverlay)i.createOverlay(la, n); else {
                var ha = !1;
                if (n && (n.groundoverlays = n.groundoverlays || [], n.reload)) {
                    overlayBounds = new google.maps.LatLngBounds(new google.maps.LatLng(la.latLonBox.south, la.latLonBox.west), new google.maps.LatLng(la.latLonBox.north, la.latLonBox.east));
                    var qa = n.groundoverlays;
                    for (q = qa.length; q--;)if (qa[q].bounds().equals(overlayBounds) && qa.url_ === la.icon.href) {
                        ha = qa[q].active = !0;
                        break
                    }
                }
                ha || (ma = D(la, n), ma.active = !0)
            }
            if (n.reload && n.groundoverlays && n.groundoverlays.length) {
                var qa = n.groundoverlays;
                for (q = qa.length; q--;)qa[q].active || (qa[q].remove(), qa.splice(q, 1));
                n.groundoverlays = qa
            }
        }
        var ra, sa = document.location.pathname.split("/");
        sa = sa.splice(0, sa.length - 1).join("/");
        var ta = w(a, "NetworkLink");
        for (q = 0; q < ta.length; q++)M = ta[q], ra = {
            name: t(w(M, "name")[0]),
            link: {href: t(w(M, "href")[0]), refreshMode: t(w(M, "refreshMode")[0])}
        }, ra.link.refreshMode || (ra.link.refreshMode = "onChange"), "onInterval" === ra.link.refreshMode ? (ra.link.refreshInterval = parseFloat(t(w(M, "refreshInterval")[0])), isNaN(ra.link.refreshInterval) && (ra.link.refreshInterval = 0)) : "onChange" === ra.link.refreshMode && (ra.link.viewRefreshMode = t(w(M, "viewRefreshMode")[0]), ra.link.viewRefreshMode || (ra.link.viewRefreshMode = "never"), "onStop" === ra.link.viewRefreshMode && (ra.link.viewRefreshTime = t(w(M, "refreshMode")[0]), ra.link.viewFormat = t(w(M, "refreshMode")[0]), ra.link.viewFormat || (ra.link.viewFormat = "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]"))), /^[\/|http]/.test(ra.link.href) || (ra.link.href = sa + "/" + ra.link.href), "onInterval" === ra.link.refreshMode && ra.link.refreshInterval > 0 ? setInterval(h + '.parse("' + ra.link.href + '")', 1e3 * ra.link.refreshInterval) : "onChange" === ra.link.refreshMode && ("never" === ra.link.viewRefreshMode ? n.internals.parser.parse(ra.link.href, n.internals.docSet) : "onStop" === ra.link.viewRefreshMode);
        if (n.bounds && (n.internals.bounds = n.internals.bounds || new google.maps.LatLngBounds, n.internals.bounds.union(n.bounds)), (n.markers || n.groundoverlays || n.gpolylines || n.gpolygons) && (n.internals.parseOnly = !1), !n.internals.parseOnly && n.baseUrl)if (k[n.baseUrl])for (var q in k[n.baseUrl])k[n.baseUrl][q] = n[q]; else j.push(n), k[n.baseUrl] = n;
        n.internals.remaining--, 0 === n.internals.remaining && (i.zoom && n.internals.bounds && !n.internals.bounds.isEmpty() && i.map && i.map.fitBounds(n.internals.bounds), i.afterParse && i.afterParse(n.internals.docSet), google.maps.event.trigger(n.internals.parser, "parsed"))
    }, y = function (a, b) {
        var c = {};
        a = a || "ffffffff";
        var d = a.substr(0, 2), e = a.substr(2, 2), f = a.substr(4, 2), g = a.substr(6, 2);
        return c.opacity = parseInt(d, 16) / 256, c.color = "random" === b ? z(g, f, e) : "#" + g + f + e, c
    }, z = function (a, b, c) {
        var d = {rr: a, gg: b, bb: c};
        for (var e in d) {
            var f = d[e];
            null == f && (f = "ff"), f = Math.round(Math.random() * parseInt(a, 16)).toString(16), 1 === f.length && (f = "0" + f), d[e] = f
        }
        return "#" + d.rr + d.gg + d.bb
    }, A = function (a) {
        var b = a.icon;
        if (b && b.href) {
            if (b.img && !b.img.complete && b.dim.w < 0 && b.dim.h < 0)return b.markerBacklog = [], void(b.img.onload = function () {
                b.dim.w < 0 || b.dim.h < 0 ? (b.dim.w = this.width, b.dim.h = this.height) : b.dim.th = this.height, A(a);
                for (var c = 0; c < b.markerBacklog.length; c++) {
                    var d = b.markerBacklog[c][0], e = b.markerBacklog[c][1];
                    C(d, e), d.marker && (d.marker.active = !0)
                }
                delete b.markerBacklog
            });
            b.img && b.img.complete ? b.dim.w < 0 || b.dim.h < 0 ? (b.dim.w = b.img.width, b.dim.h = b.img.height) : b.dim.th = b.img.height : (b.dim.whGuess = !0, b.dim.w = 32, b.dim.h = 32, b.dim.th = 32);
            var c = Math.round, d = b.dim.y;
            "undefined" != typeof b.dim.th && b.dim.th != b.dim.h && (d = Math.abs(d - (b.dim.th - b.dim.h)));
            var e, f, g = {
                x: b.dim.x * b.scale,
                y: d * b.scale,
                w: b.dim.w * b.scale,
                h: b.dim.h * b.scale,
                aX: b.hotSpot.x * b.scale,
                aY: b.hotSpot.y * b.scale,
                iW: (b.img ? b.img.width : b.dim.w) * b.scale,
                iH: (b.img ? b.img.height : b.dim.h) * b.scale
            };
            switch (b.hotSpot.xunits) {
                case"fraction":
                    e = c(g.aX * b.dim.w);
                    break;
                case"insetPixels":
                    e = c(b.dim.w * b.scale - g.aX);
                    break;
                default:
                    e = c(g.aX)
            }
            f = g.h - c(("fraction" === b.hotSpot.yunits ? b.dim.h : 1) * g.aY);
            var h = new google.maps.Point(e, f), i = b.dim.whGuess ? null : new google.maps.Size(c(g.w), c(g.h)), j = 1 == b.scale ? null : b.dim.whGuess ? new google.maps.Size(c(g.w), c(g.h)) : new google.maps.Size(c(g.iW), c(g.iH)), k = new google.maps.Point(c(g.x), c(g.y));
            l[b.url] && (b.url = l[b.url].dataUrl), b.marker = {
                url: b.url,
                size: i,
                origin: k,
                anchor: h,
                scaledSize: j
            };
            var m = /\/(red|blue|green|yellow|lightblue|purple|pink|orange)(-dot)?\.png/, n = new google.maps.Size(59, 32), o = new google.maps.Point(16, 32);
            m.test(b.href) ? b.shadow = {
                url: "http://maps.google.com/mapfiles/ms/micons/msmarker.shadow.png",
                size: n,
                origin: null,
                anchor: o,
                scaledSize: n
            } : b.href.indexOf("-pushpin.png") > -1 && (b.shadow = {
                url: "http://maps.google.com/mapfiles/ms/micons/pushpin_shadow.png",
                size: n,
                origin: null,
                anchor: o,
                scaledSize: n
            })
        }
    }, B = function (a) {
        for (var b in a.styles)A(a.styles[b])
    }, C = function (a, b) {
        var c = a.style.icon;
        if (!c.marker && c.img)return c.markerBacklog = c.markerBacklog || [], void c.markerBacklog.push([a, b]);
        var d = geoXML3.combineOptions(i.markerOptions, {
            map: i.map,
            position: new google.maps.LatLng(a.Point.coordinates[0].lat, a.Point.coordinates[0].lng),
            title: a.name,
            zIndex: Math.round(-1e5 * a.Point.coordinates[0].lat) << 5,
            icon: c.marker,
            shadow: c.shadow,
            flat: !c.shadow,
            visible: a.visibility
        }), e = new google.maps.Marker(d);
        return b && b.markers.push(e), G(a, b, e), a.marker = e, e
    }, D = function (a, b) {
        if (!window.ProjectedOverlay)throw"geoXML3 error: ProjectedOverlay not found while rendering GroundOverlay from KML";
        var c = new google.maps.LatLngBounds(new google.maps.LatLng(a.latLonBox.south, a.latLonBox.west), new google.maps.LatLng(a.latLonBox.north, a.latLonBox.east)), d = geoXML3.combineOptions(i.overlayOptions, {
            percentOpacity: 100 * a.opacity,
            index: a.index
        }), e = new ProjectedOverlay(i.map, a.icon.href, c, d);
        return b && (b.ggroundoverlays = b.ggroundoverlays || [], b.ggroundoverlays.push(e)), "function" == typeof i.onAfterCreateGroundOverlay && i.onAfterCreateGroundOverlay(e), e
    }, E = function (a, b) {
        for (var c = [], d = new google.maps.LatLngBounds, e = 0; e < a.LineString.length; e++) {
            for (var f = [], g = a.LineString[e].coordinates, h = 0; h < g.length; h++) {
                var j = new google.maps.LatLng(g[h].lat, g[h].lng);
                f.push(j), d.extend(j)
            }
            c.push(f)
        }
        var k = (c[0][Math.floor(f.length / 2)], y(a.style.line.color, a.style.line.colorMode)), l = geoXML3.combineOptions(i.polylineOptions, {
            map: i.map,
            path: f,
            strokeColor: k.color,
            strokeWeight: a.style.line.width,
            strokeOpacity: k.opacity,
            title: a.name,
            visible: a.visibility,
            index: a.index
        });
        if (c.length > 1) {
            l.paths = c;
            var m = new MultiGeometry(l)
        } else {
            l.path = c[0];
            var m = new google.maps.Polyline(l)
        }
        return m.bounds = d, G(a, b, m), b && b.gpolylines.push(m), a.polyline = m, "function" == typeof i.onAfterCreatePolyLine && i.onAfterCreatePolyLine(m, a), m
    }, F = function (a, b) {
        for (var c = new google.maps.LatLngBounds, d = 0, e = [], f = 0; f < a.Polygon.length; f++) {
            for (var g = 0; g < a.Polygon[f].outerBoundaryIs.length; g++) {
                for (var h = a.Polygon[f].outerBoundaryIs[g].coordinates, j = [], k = 0; k < h.length; k++) {
                    var l = new google.maps.LatLng(h[k].lat, h[k].lng);
                    j.push(l), c.extend(l)
                }
                e.push(j), d += j.length
            }
            for (var g = 0; g < a.Polygon[f].innerBoundaryIs.length; g++) {
                for (var h = a.Polygon[f].innerBoundaryIs[g].coordinates, j = [], k = 0; k < h.length; k++) {
                    var l = new google.maps.LatLng(h[k].lat, h[k].lng);
                    j.push(l), c.extend(l)
                }
                e.push(j), d += j.length
            }
        }
        var m = y(a.style.line.color, a.style.line.colorMode), n = y(a.style.poly.color, a.style.poly.colorMode);
        a.style.poly.fill || (n.opacity = 0);
        var o = a.style.line.width;
        a.style.poly.outline || (o = 0, m.opacity = 0);
        var p = geoXML3.combineOptions(i.polygonOptions, {
            map: i.map,
            paths: e,
            title: a.name,
            strokeColor: m.color,
            strokeWeight: o,
            strokeOpacity: m.opacity,
            fillColor: n.color,
            fillOpacity: n.opacity,
            visible: a.visibility,
            index: a.index
        }), q = new google.maps.Polygon(p);
        return q.bounds = c, G(a, b, q), b && b.gpolygons.push(q), a.polygon = q, "function" == typeof i.onAfterCreatePolygon && i.onAfterCreatePolygon(q, a), q
    }, G = function (a, b, c) {
        var d = a.style.balloon, e = a.vars;
        if (a.balloonVisibility && "hide" !== d.displayMode) {
            if (!a.latlng || i.suppressDirections && i.suppressDirections)e.val.geDirections = ""; else {
                e.directions.push("sll=" + a.latlng.toUrlValue());
                var f = "http://maps.google.com/maps?" + e.directions.join("&"), g = encodeURIComponent(e.val.address || a.latlng.toUrlValue()).replace(/\%20/g, "+");
                e.val.geDirections = '<a href="' + f + "&daddr=" + g + '" target=_blank>To Here</a> - <a href="' + f + "&saddr=" + g + '" target=_blank>From Here</a>'
            }
            var h = d.text.replace(/\$\[(\w+(\/displayName)?)\]/g, function (a, b, c) {
                return c ? e.display[b] : e.val[b]
            }), j = "geoxml3_infowindow geoxml3_style_" + a.styleID, k = [];
            "ffffffff" != d.bgColor && k.push("background: " + y(d.bgColor).color + ";"), "ff000000" != d.textColor && k.push("color: " + y(d.textColor).color + ";");
            var l = k.length ? ' style="' + k.join(" ") + '"' : "", m = geoXML3.combineOptions(i.infoWindowOptions, {
                content: '<div class="' + j + '"' + l + ">" + h + "</div>",
                pixelOffset: new google.maps.Size(0, 2)
            });
            c.infoWindow = i.infoWindow || new google.maps.InfoWindow(m), delete m.content, c.infoWindowOptions = m, google.maps.event.addListener(c, "click", function (a) {
                "function" == typeof this.infoWindow.$onOpen && this.infoWindow.$onOpen(c);
                var b = this.infoWindow;
                b.close(), b.setOptions(this.infoWindowOptions), a && a.latLng ? b.setPosition(a.latLng) : this.bounds && b.setPosition(this.bounds.getCenter()), google.maps.event.addListenerOnce(b, "domready", function () {
                }), b.open(this.map, this.bounds ? null : this)
            })
        }
    };
    return {
        options: i,
        docs: j,
        docsByUrl: k,
        kmzMetaData: l,
        parse: o,
        render: x,
        parseKmlString: n,
        hideDocument: p,
        showDocument: q,
        processStyles: B,
        createMarker: C,
        createOverlay: D,
        createPolyline: E,
        createPolygon: F
    }
}, geoXML3.getOpacity = function (a) {
    if (a && "" !== a && 8 == a.length) {
        var b = parseInt(a.substr(0, 2), 16);
        return b / 255
    }
    return 1
}, geoXML3.log = function (a) {
    window.console ? console.log(a) : alert("log:" + a)
}, geoXML3.parserOptions = function (a) {
    if (this.map = null, this.zoom = !0, this.singleInfoWindow = !1, this.suppressInfoWindows = !1, this.processStyles = !1, this.markerOptions = {}, this.infoWindowOptions = {}, this.overlayOptions = {}, this.afterParse = null, this.failedParse = null, this.createMarker = null, this.createOverlay = null, a)for (var b in a)a.hasOwnProperty(b) && (this[b] = a[b]);
    return this
}, geoXML3.combineOptions = function (a, b) {
    var c = {};
    if (a)for (var d in a)a.hasOwnProperty(d) && (c[d] = a[d]);
    if (b)for (d in b)b.hasOwnProperty(d) && void 0 === c[d] && (c[d] = b[d]);
    return c
}, geoXML3.parserOptions.prototype.combineOptions = geoXML3.combineOptions, geoXML3.fetchers = [], geoXML3.xmlParse = function (a) {
    if ("undefined" != typeof ActiveXObject || "ActiveXObject"in window) {
        var b = new ActiveXObject("Microsoft.XMLDOM");
        return b.loadXML(a), b
    }
    return "undefined" != typeof DOMParser ? (new DOMParser).parseFromString(a, "text/xml") : document.createElement("div", null)
}, geoXML3.isParseError = function (a) {
    if ("undefined" != typeof ActiveXObject || "ActiveXObject"in window)return !1;
    var b = new DOMParser, c = b.parseFromString("<", "text/xml"), d = c.getElementsByTagName("parsererror")[0].namespaceURI;
    return "http://www.w3.org/1999/xhtml" === d ? a.getElementsByTagName("parsererror").length > 0 : a.getElementsByTagNameNS(d, "parsererror").length > 0
}, geoXML3.fetchXML = function (a, b) {
    function c() {
        b()
    }

    var d = new Object;
    if (geoXML3.fetchers.length)d = geoXML3.fetchers.pop(); else if (window.XMLHttpRequest)d.fetcher = new window.XMLHttpRequest; else if (window.ActiveXObject) {
        for (var e = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP"], f = 0; f < e.length; f++)try {
            d.fetcher = new ActiveXObject(e[f]);
            break
        } catch (g) {
            continue
        }
        if (!d.fetcher)return geoXML3.log("Unable to create XHR object"), b(null), null
    }
    return d.fetcher.open("GET", a, !0), d.fetcher.overrideMimeType && d.fetcher.overrideMimeType("text/xml"), d.fetcher.onreadystatechange = function () {
        if (4 === d.fetcher.readyState) {
            if (d.xhrtimeout && clearTimeout(d.xhrtimeout), d.fetcher.status >= 400)geoXML3.log("HTTP error " + d.fetcher.status + " retrieving " + a), b(); else {
                if (d.fetcher.responseXML) {
                    var c = d.fetcher.responseXML;
                    !c || c.documentElement || c.ownerElement || c.loadXML(d.fetcher.responseText)
                } else c = geoXML3.xmlParse(d.fetcher.responseText);
                c.parseError && 0 != c.parseError.errorCode ? (geoXML3.log("XML parse error " + c.parseError.errorCode + ", " + c.parseError.reason + "\nLine:" + c.parseError.line + ", Position:" + c.parseError.linepos + ", srcText:" + c.parseError.srcText), c = "failed parse") : geoXML3.isParseError(c) && (geoXML3.log("XML parse error"), c = "failed parse"), b(c)
            }
            geoXML3.fetchers.push(d)
        }
    }, d.xhrtimeout = setTimeout(c, 6e4), d.fetcher.send(null), null
};
var IEversion = function () {
    var a = -1;
    if ("Microsoft Internet Explorer" == navigator.appName) {
        var b = navigator.userAgent, c = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
        null != c.exec(b) && (a = parseFloat(RegExp.$1))
    }
    return a
};
geoXML3.fetchZIP = function (a, b, c) {
    new ZipFile(a, function (d) {
        for (var e = 0; e < d.status.length; e++) {
            var f = d.status[e];
            if (0 == f.indexOf("ERROR"))return geoXML3.log("HTTP/ZIP error retrieving " + a + ": " + f), void b();
            0 == f.indexOf("WARNING") && geoXML3.log("HTTP/ZIP warning retrieving " + a + ": " + f)
        }
        for (var g, h = 0, e = 0; e < d.entries.length; e++) {
            var i = d.entries[e].name;
            /\.kml$/.test(i) && (h++, 1 == h ? g = e : geoXML3.log("KMZ warning retrieving " + a + ': found extra KML "' + i + '" in KMZ; discarding...'))
        }
        for (var j = cleanURL(defileURL(a), a) + "/", k = {
            timer: null,
            extractLeft: 0,
            timerCalls: 0
        }, l = function (a, d) {
            var e = cleanURL(j, a.name), f = a.name.substring(a.name.lastIndexOf(".") + 1).toLowerCase();
            if (k.extractLeft--, "string" == typeof d.description && "Error" == d.name)return geoXML3.log("KMZ error extracting " + e + ": " + d.description), void b();
            var g;
            "jpg" === f && (f = "jpeg"), g = /^(gif|jpeg|png)$/.test(f) ? "image/" + f : "mp3" === f ? "audio/mpeg" : "m4a" === f ? "audio/mp4" : "m4a" === f ? "audio/MP4-LATM" : "application/octet-stream", c.kmzMetaData[e] = {}, c.kmzMetaData[e].entry = a, c.kmzMetaData[e].dataUrl = "data:" + g + ";base64," + base64Encode(d), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && (IEversion() < 8 && c.kmzMetaData[e].dataUrl.length > 2071 || 9 > IEversion && c.kmzMetaData[e].dataUrl.length > 32767) && (c.kmzMetaData[e].dataUrl = "data:image/gif;base64,R0lGODlhDwAQAOMPADBPvSpQ1Dpoyz1p6FhwvU2A6ECP63CM04CWxYCk+V6x+UK++Jao3rvC3fj7+v///yH5BAEKAA8ALAAAAAAPABAAAASC8Mk5mwCAUMlWwcLRHEelLAoGDMgzSsiyGCAhCETDPMh5XQCBwYBrNBIKWmg0MCQHj8MJU5IoroYCY6AAAgrDIbbQDGIK6DR5UPhlNo0JAlSUNAiDgH7eNAxEDWAKCQM2AAFheVxYAA0AIkFOJ1gBcQQaUQKKA5w7LpcEBwkJaKMUEQA7"), c.kmzMetaData[internalSrc(a.name)] = c.kmzMetaData[e]
        }, m = function (c, d) {
            return "string" == typeof d.description && "Error" == d.name ? (geoXML3.log("KMZ error extracting " + mdUrl + ": " + d.description), void b()) : (clearTimeout(k.timer), k.extractLeft <= 1 ? (k.extractLeft--, void b(geoXML3.xmlParse(d))) : (k.timerCalls++, void(k.timerCalls < 100 ? k.timer = setTimeout(function () {
                m(c, d)
            }, 100) : (geoXML3.log("KMZ warning extracting " + a + ": entire ZIP has not been extracted after 10 seconds; running through KML, anyway..."), k.extractLeft--, b(geoXML3.xmlParse(d))))))
        }, e = 0; e < d.entries.length; e++) {
            var n = d.entries[e], o = n.name.substring(n.name.lastIndexOf(".") + 1).toLowerCase();
            /^(gif|jpe?g|png|kml)$/.test(o) && ("kml" !== o || e == g) && (c || "kml" == o) && (k.extractLeft++, "kml" === o ? n.extract(m) : n.extract(l))
        }
    })
}, geoXML3.nodeValue = function (a, b) {
    var c = "";
    if (!a)return "undefined" == typeof b || null === b ? null : b;
    if (3 == a.nodeType || 4 == a.nodeType || 2 == a.nodeType)c += a.nodeValue; else if (1 == a.nodeType || 9 == a.nodeType || 11 == a.nodeType)for (var d = 0; d < a.childNodes.length; ++d)c += arguments.callee(a.childNodes[d]);
    return c
}, geoXML3.getBooleanValue = function (a, b) {
    var c = geoXML3.nodeValue(a);
    return null === c ? b || !1 : (c = parseInt(c), isNaN(c) ? !0 : 0 == c ? !1 : !0)
}, geoXML3.getElementsByTagNameNS = function (a, b, c) {
    if (a && "undefined" != typeof a.getElementsByTagNameNS)return a.getElementsByTagNameNS(b, c);
    if (!a)return [];
    var d = a.documentElement || a.ownerDocument && a.ownerDocument.documentElement;
    if (!d || !d.attributes)return [];
    for (var e = 0; e < d.attributes.length; e++) {
        var f = d.attributes[e];
        if ("xmlns" === f.prefix && f.nodeValue === b)return a.getElementsByTagName(f.baseName + ":" + c);
        if ("xmlns" === f.nodeName && f.nodeValue === b)return "undefined" != typeof a.selectNodes ? (d.ownerDocument.getProperty("SelectionNamespaces") || d.ownerDocument.setProperty("SelectionNamespaces", "xmlns:defaultNS='" + b + "'"), a.selectNodes(".//defaultNS:" + c)) : (d.setAttribute("xmlns:defaultNS", b), a.getElementsByTagName("defaultNS:" + c))
    }
    return geoXML3.getElementsByTagName(a, c)
}, geoXML3.getElementsByTagName = function (a, b) {
    return a && "undefined" != typeof a.getElementsByTagNameNS ? a.getElementsByTagName(b) : a.getElementsByTagName(b)
};
var toAbsURL = function (a, b) {
    var c, d, e, f = location.protocol + "://" + location.host;
    if (!b.length)return "";
    if (/^\w+:/.test(b))return b;
    if (0 == b.indexOf("/"))return f + b;
    if (c = a.replace(/\/[^\/]*$/, ""), d = b.match(/\.\.\//g))for (b = b.substring(3 * d.length), e = d.length; e--;)c = c.substring(0, c.lastIndexOf("/"));
    return f + c + "/" + b
}, internalSrc = function (a) {
    var b = document.location.href;
    b = b.substring(0, b.lastIndexOf("/") + 1);
    var c = b + a;
    return c
}, dehostURL = function (a) {
    var b = location.protocol + "://" + location.host;
    return b = b.replace(/([\.\\\+\*\?\[\^\]\$\(\)])/g, "\\$1"), a.replace(new RegExp("^" + b, "i"), "")
}, cleanURL = function (a, b) {
    return dehostURL(toAbsURL(a ? a.split("#")[0].split("?")[0] : defileURL(location.pathname), b ? b.split("#")[0].split("?")[0] : ""))
}, defileURL = function (a) {
    return a ? a.substr(0, a.lastIndexOf("/") + 1) : "/"
};
Array.prototype.hasObject = Array.indexOf ? function (a) {
    return -1 !== this.indexOf(a)
} : function (a) {
    for (var b = this.length + 1; b--;)if (this[b - 1] === a)return !0;
    return !1
}, Array.prototype.hasItemInObj = function (a, b) {
    for (var c = this.length + 1; c--;)if (this[c - 1][a] === b)return !0;
    return !1
}, Array.prototype.indexOf || (Array.prototype.indexOf = function (a, b) {
    null == b ? b = 0 : 0 > b && (b = Math.max(0, this.length + b));
    for (var c = b, d = this.length; d > c; c++)if (this[c] === a)return c;
    return -1
}), Array.prototype.indexOfObjWithItem = function (a, b, c) {
    null == c ? c = 0 : 0 > c && (c = Math.max(0, this.length + c));
    for (var d = c, e = this.length; e > d; d++)if (this[d][a] === b)return d;
    return -1
};
var base64Encode = function (a) {
    for (var b, c, d, e, f, g, h, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", j = "", k = 0; k < a.length;)b = a[k++], c = a[k++], d = a[k++], e = b >> 2, f = (3 & b) << 4 | c >> 4, g = (15 & c) << 2 | d >> 6, h = 63 & d, void 0 == c ? g = h = 64 : void 0 == d && (h = 64), j = j + i.charAt(e) + i.charAt(f) + i.charAt(g) + i.charAt(h);
    return j
};
!function (a) {
    "use strict";
    a.module("LogicifyGMap", [])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").service("SmartCollection", [function () {
        function b(b) {
            var d = this, e = null;
            d.next = function () {
                return null == e ? e = 0 : e++, void 0 !== d[e] ? d[e] : void(e = null)
            }, d.setIterator = function (b) {
                if (a.isNumber(b) && NaN !== b) {
                    if (void 0 === d[b])throw new Error("Can not reach this element, because it doesn't exist. Index: " + b);
                    e = b
                }
            }, Array.isArray(b) && b.forEach(function (a, b) {
                d.push(a)
            }), d._uid = c++;
            var f = [], g = [], h = d.push;
            d.push = function () {
                var a = Array.prototype.slice.call(arguments), b = h.apply(d, a);
                return a.forEach(function (a) {
                    f.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            };
            var i = d.pop;
            d.pop = function () {
                var a = Array.prototype.slice.call(arguments), b = i.apply(d, a);
                return g.forEach(function (a) {
                    a.apply(d, [b])
                }), b
            };
            var j = d.unshift;
            d.unshift = function () {
                var a = Array.prototype.slice.call(arguments), b = j.apply(d, a);
                return a.forEach(function (a) {
                    f.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            }, d.shift, d.shift = function () {
                var a = Array.prototype.slice.call(arguments), b = j.apply(d, a);
                return g.forEach(function (a) {
                    a.apply(d, [b])
                }), b
            };
            var k = d.splice;
            d.splice = function () {
                var a = Array.prototype.slice.call(arguments), b = k.apply(d, a);
                return b.forEach(function (a) {
                    g.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            }, d.removeQuietly = k, d.onRemoveItem = function (a) {
                "function" == typeof a && g.push(a)
            }, d.onAddItem = function (a) {
                "function" == typeof a && f.push(a)
            }
        }

        var c = 0;
        return Array.isArray = function (a) {
            return "[object Array]" === Object.prototype.toString.call(a) || null != a && a.constructor && "SmartCollection" === a.constructor.name && "[object Array]" === Object.prototype.toString.call(a.__proto__.__proto__)
        }, b.prototype = Object.create(Array.prototype), b.prototype.constructor = b, b
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                    "function" != typeof f.$onOpen && (f.$onOpen = function (a) {
                        "function" == typeof f.onAfterOpen && f.onAfterOpen(a)
                    })
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a, b) {
    "use strict";
    a.module("LogicifyGMap").directive("xmlOverlays", ["$timeout", "$log", "$q", "$compile", "$http", "SmartCollection", function (c, d, e, f, g, h) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (e, f, i, j) {
                function k(b, c) {
                    var d = {};
                    return a.extend(d, e.parserOptions), d.map = b, d.afterParse = o, d.onAfterCreateGroundOverlay = e.events.onAfterCreateGroundOverlay, d.onAfterCreatePolygon = e.events.onAfterCreatePolygon, d.onAfterCreatePolyLine = e.events.onAfterCreatePolyLine, d.failedParse = p, d.infoWindow = c, d
                }

                function l() {
                    return e.$watch("kmlCollection._uid", function (a, b) {
                        if (null == a)if (e.kmlCollection = new h(e.$eval(i.kmlCollection)), (e.downLoadingStarted === !0 || e.parserStarted === !0) && (e.cancel = !0), e.cancel === !0)var c = e.$watch("cancel", function (a, b) {
                            a === !0 && (u(), c())
                        }); else u()
                    })
                }

                function m(a) {
                    null != a && (a.downloadNext = !1, e.currentDocument = a, w(a))
                }

                function n(a) {
                    t(a)
                }

                function o(a) {
                    return e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (a[0].$uid = (new Date).getTime() + "-index-" + Math.floor(-9 * Math.random()), e.currentDocument.doc = a, "function" == typeof e.events.onAfterParse && e.events.onAfterParse(a), void q(null, e.currentDocument))
                }

                function p() {
                    if (e.cancel === !0)return c(function () {
                        e.cancel = !1
                    }), !1;
                    var a = {message: "Failed to parse file url: " + e.currentDocument.url};
                    d.error(a.message), "function" == typeof e.events.onAfterParseFailed && e.events.onAfterParseFailed(a), q(a)
                }

                function q(a, b) {
                    r("parserStarted", !1, v), e.currentDocument.downloadNext === !1 ? (delete e.currentDocument.downloadNext, s()) : (e.currentDocument = e.kmlCollection.next(), w(e.currentDocument))
                }

                function r(a, b, c) {
                    e[a] = b, "function" == typeof c && c()
                }

                function s() {
                    e.globalBounds = new google.maps.LatLngBounds, 1 != e.kmlCollection.length && e.fitBoundsAfterAll !== !1 ? (e.kmlCollection.forEach(function (a) {
                        e.globalBounds.extend(a.doc[0].bounds.getCenter())
                    }), c(function () {
                        e.gMap.fitBounds(e.globalBounds)
                    }, 10)) : e.kmlCollection.length > 0 && e.fitBoundsAfterAll !== !1 && c(function () {
                        e.gMap.fitBounds(e.kmlCollection[0].doc[0].bounds)
                    }, 10)
                }

                function t(b) {
                    if (b) {
                        y.hideDocument(b.doc[0]);
                        var c = y.docs.indexOf(b.doc[0]);
                        c > -1 && (delete y.docsByUrl[b.doc[0].baseUrl], y.docs.splice(c, 1), s())
                    } else a.forEach(y.docs, function (a) {
                        y.hideDocument(a)
                    }), y.docs.splice(0, y.docs.length), y.docsByUrl = {}, e.globalBounds = null, e.currentDocument = null
                }

                function u() {
                    Array.isArray(e.kmlCollection) && 0 !== e.kmlCollection.length ? (e.finished = !1, void 0 !== e.currentDocument && t(), e.currentDocument = e.kmlCollection.next(), e.kmlCollection.onAddItem(m), e.kmlCollection.onRemoveItem(n), w(e.currentDocument)) : e.currentDocument = null
                }

                function v() {
                    "function" == typeof e.onProgress && e.onProgress({
                        isDownloading: e.downLoadingStarted,
                        isParsing: e.parserStarted,
                        finished: e.finished
                    })
                }

                function w(a) {
                    return a ? e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (r("downLoadingStarted", !0, v), void(null != a.url ? g.get(a.url, {responseType: "arraybuffer"}).then(function (a) {
                        var b = new Blob([a.data], {type: a.headers()["content-type"]});
                        b.lastModifiedDate = new Date, b.name = "example" + b.lastModifiedDate, x(b)
                    }) : "String" == typeof a.content ? x(null, a.content) : a instanceof Blob ? x(a) : d.error("Incorrect file type. Should be an instance of a Blob or String (url)."))) : (r("finished", !0, v), s(), !1)
                }

                function x(a, b) {
                    return e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (r("parserStarted", !0), r("downLoadingStarted", !1, v), void(null == b ? y.parse(a) : y.parseKmlString(b)))
                }

                var y = null;
                e.kmlCollection = new h(e.$eval(i.kmlCollection)), e.events = e.$eval(i.gmapEvents) || {}, e.parserOptions = e.$eval(i.parserOptions) || {}, e.onProgress = e.$eval(i.onProgress), e.fitBoundsAfterAll = e.$eval(i.fitAllLayers), j.$mapReady(function (a) {
                    e.infowindow = e.$eval(i.infoWindow), e.collectionsWatcher = l(), e.gMap = a, e.infowindow && "function" == typeof e.infowindow.$ready ? e.infowindow.$ready(function (c) {
                        y = new b.parser(k(a, c)), u()
                    }) : (y = new b.parser(k(a)), u())
                }), e.cancel = !1, e.$on("$destroy", function () {
                    "function" == typeof e.collectionsWatcher && e.collectionsWatcher()
                })
            }
        }
    }])
}(angular, geoXML3), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(a) {
                var b = d.open;
                d.open = function (c, e) {
                    h = c, "function" == typeof c.openInfoWnd && c.openInfoWnd(a, c, e, d, b)
                };
                var c = d.close;
                if (d.close = function (a) {
                        h && ("function" == typeof h.closeInfoWnd && a === !0 ? h.closeInfoWnd(d, c) : c.apply(d, []))
                    }, g = !0, f.length > 0) {
                    for (var e = 0; e < f.length; e++)f[e](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1, h = null;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            }, arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular), window.google && google.maps && (MultiGeometry.prototype = new google.maps.MVCObject, MultiGeometry.prototype.changed = function (a) {
    if (this.polylines)for (var b = 0; b < this.polylines.length; b++)this.polylines[b].set(a, this.get(a))
}, MultiGeometry.prototype.setMap = function (a) {
    this.set("map", a)
}, MultiGeometry.prototype.getMap = function () {
    return this.get("map")
}), String.prototype.trim || (String.prototype.trim = function () {
    return this.replace(/^\s+|\s+$/g, "")
}), geoXML3 = window.geoXML3 || {instances: []}, geoXML3.parser = function (a) {
    function b(a, b, c) {
        return c = c || function (a) {
            x(a, b)
        }, "application/vnd.google-earth.kml+xml" !== b.type && "function" == typeof ZipFile && "object" == typeof JSIO && "function" == typeof JSIO.guessFileType && (contentType = JSIO.guessFileType(b.baseUrl), 3 === contentType ? contentType = JSIO.FileType.Binary : null, contentType == JSIO.FileType.Binary || contentType == JSIO.FileType.Unknown) ? (b.isCompressed = !0, b.baseDir = b.baseUrl + "/", void geoXML3.fetchZIP(a, c, b.internals.parser)) : (b.isCompressed = !1, b.baseDir = defileURL(b.baseUrl), void geoXML3.fetchXML(a, c))
    }

    function c(a) {
        var b = t(w(a, "styleUrl")[0]);
        if (b && -1 != b.indexOf("#"))var c = b.split("#"); else var c = ["", ""];
        return c
    }

    function d(a, b, c, d) {
        var f = "{inline}" === b ? e(r) : m[b][c] = m[b][c] || e(r), g = w(a, "BalloonStyle");
        g && g.length > 0 && (f.balloon.bgColor = t(w(g[0], "bgColor")[0], f.balloon.bgColor), f.balloon.textColor = t(w(g[0], "textColor")[0], f.balloon.textColor), f.balloon.text = t(w(g[0], "text")[0], f.balloon.text), f.balloon.displayMode = t(w(g[0], "displayMode")[0], f.balloon.displayMode));
        var g = w(a, "IconStyle");
        if (g && g.length > 0) {
            var h = f.icon;
            h.scale = parseFloat(t(w(g[0], "scale")[0], h.scale)), g = w(g[0], "hotSpot"), g && g.length > 0 && (h.hotSpot = {
                x: g[0].getAttribute("x"),
                y: g[0].getAttribute("y"),
                xunits: g[0].getAttribute("xunits"),
                yunits: g[0].getAttribute("yunits")
            }), g = w(a, "Icon"), g && g.length > 0 && (h.href = t(w(g[0], "href")[0]), h.url = cleanURL(d, h.href), l[h.url] && (h.url = l[h.url].dataUrl), h.dim = {
                x: parseInt(t(v(g[0], s, "x")[0], h.dim.x)),
                y: parseInt(t(v(g[0], s, "y")[0], h.dim.y)),
                w: parseInt(t(v(g[0], s, "w")[0], h.dim.w)),
                h: parseInt(t(v(g[0], s, "h")[0], h.dim.h))
            }, h.img = new Image, h.img.onload = function () {
                h.dim.w < 0 || h.dim.h < 0 ? (h.dim.w = this.width, h.dim.h = this.height) : h.dim.th = this.height
            }, h.img.src = h.url, h.img.width > 0 && (h.dim.w < 0 || h.dim.h < 0 ? (h.dim.w = h.img.width, h.dim.h = h.img.height) : h.dim.th = h.img.height))
        }
        return g = w(a, "LineStyle"), g && g.length > 0 && (f.line.color = t(w(g[0], "color")[0], f.line.color), f.line.colorMode = t(w(g[0], "colorMode")[0], f.line.colorMode), f.line.width = t(w(g[0], "width")[0], f.line.width)), g = w(a, "PolyStyle"), g && g.length > 0 && (f.poly.color = t(w(g[0], "color")[0], f.poly.color), f.poly.colorMode = t(w(g[0], "colorMode")[0], f.poly.colorMode), f.poly.outline = u(w(g[0], "outline")[0], f.poly.outline), f.poly.fill = u(w(g[0], "fill")[0], f.poly.fill)), f
    }

    function e(a) {
        if (null == a || "object" != typeof a)return a;
        if (a.cloneNode)return a.cloneNode(!0);
        var b = new a.constructor;
        for (var c in a)b[c] = e(a[c]);
        return b
    }

    function f(a, b, f, g) {
        for (var h = w(a, "Pair"), j = new Object, k = 0; k < h.length; k++) {
            var l = t(w(h[k], "key")[0]), n = t(w(h[k], "Style")[0]), o = c(h[k]), p = o[0] ? cleanURL(g, o[0]) : b, q = o[1];
            n ? j[l] = d(n, p, q) : q && m[p][q] && (j[l] = e(m[p][q]))
        }
        j.normal ? m[b][f] = e(j.normal) : m[b][f] = e(r), j.highlight && i.processStyles && A(j.highlight), m[b][f].map = e(j)
    }

    function g(a, b) {
        for (var c = w(a, b), d = [], e = 0; e < c.length; e++) {
            var f = w(c[e], "coordinates");
            if (!f) {
                if (d.length > 0)break;
                return [{coordinates: []}]
            }
            for (var g = 0; g < f.length; g++) {
                var h = t(f[g]).trim();
                h = h.replace(/,\s+/g, ",");
                for (var i = h.split(/\s+/g), j = i.length, k = [], l = 0; j > l; l++)h = i[l].split(","), isNaN(h[0]) || isNaN(h[1]) || k.push({
                    lat: parseFloat(h[1]),
                    lng: parseFloat(h[0]),
                    alt: parseFloat(h[2])
                });
                d.push({coordinates: k})
            }
        }
        return d
    }

    google.maps.MVCObject.call(this);
    var h, i = new geoXML3.parserOptions(a), j = [], k = {}, l = {}, m = {};
    !i.infoWindow && i.singleInfoWindow && (i.infoWindow = new google.maps.InfoWindow);
    var n = function (a, b) {
        var c = {parser: this, docSet: b || [], remaining: 1, parseOnly: !(i.afterParse || i.processStyles)};
        thisDoc = new Object, thisDoc.internals = c, c.docSet.push(thisDoc), x(geoXML3.xmlParse(a), thisDoc)
    }, o = function (a, c) {
        h || (h = "geoXML3.instances[" + (geoXML3.instances.push(this) - 1) + "]"), "string" == typeof a && (a = [a]), a instanceof Blob && (a = [a]);
        for (var d, e = {
            parser: this,
            docSet: c || [],
            remaining: a.length,
            parseOnly: !(i.afterParse || i.processStyles)
        }, f = 0; f < a.length; f++) {
            var g = null, j = null;
            a[f]instanceof Blob ? (g = a[f].type, j = URL.createObjectURL(a[f])) : j = a[f];
            var l = cleanURL(defileURL(location.pathname), j);
            k[l] ? (d = k[l], d.reload = !0) : (d = new Object, d.baseUrl = l, e.docSet.push(d)), d.type = g, d.url = j, d.internals = e, b(d.url, d)
        }
    }, p = function (a) {
        a || (a = j[0]);
        var b;
        if (a.markers)for (b = 0; b < a.markers.length; b++)a.markers[b].infoWindow && a.markers[b].infoWindow.close(), a.markers[b].setVisible(!1);
        if (a.ggroundoverlays)for (b = 0; b < a.ggroundoverlays.length; b++)a.ggroundoverlays[b].setOpacity(0);
        if (a.gpolylines)for (b = 0; b < a.gpolylines.length; b++)a.gpolylines[b].infoWindow && a.gpolylines[b].infoWindow.close(), a.gpolylines[b].setMap(null);
        if (a.gpolygons)for (b = 0; b < a.gpolygons.length; b++)a.gpolygons[b].infoWindow && a.gpolygons[b].infoWindow.close(), a.gpolygons[b].setMap(null)
    }, q = function (a) {
        a || (a = j[0]);
        var b;
        if (a.markers)for (b = 0; b < a.markers.length; b++)a.markers[b].setVisible(!0);
        if (a.ggroundoverlays)for (b = 0; b < a.ggroundoverlays.length; b++)a.ggroundoverlays[b].setOpacity(a.ggroundoverlays[b].percentOpacity_);
        if (a.gpolylines)for (b = 0; b < a.gpolylines.length; b++)a.gpolylines[b].setMap(i.map);
        if (a.gpolygons)for (b = 0; b < a.gpolygons.length; b++)a.gpolygons[b].setMap(i.map)
    }, r = {
        balloon: {
            bgColor: "ffffffff",
            textColor: "ff000000",
            text: "<h3>$[name]</h3>\n<div>$[description]</div>\n<div>$[geDirections]</div>",
            displayMode: "default"
        },
        icon: {
            scale: 1,
            dim: {x: 0, y: 0, w: -1, h: -1},
            hotSpot: {x: .5, y: .5, xunits: "fraction", yunits: "fraction"}
        },
        line: {color: "ffffffff", colorMode: "normal", width: 1},
        poly: {color: "ffffffff", colorMode: "normal", fill: !0, outline: !0}
    }, s = "http://www.google.com/kml/ext/2.2", t = geoXML3.nodeValue, u = geoXML3.getBooleanValue, v = geoXML3.getElementsByTagNameNS, w = geoXML3.getElementsByTagName, x = function (a, n) {
        if (!a || "failed parse" == a)return geoXML3.log("Unable to retrieve " + n.url), i.failedParse && i.failedParse(n), void(n.failed = !0);
        if (a.parseError && 0 != a.parseError.errorCode) {
            var o = a.parseError, p = "Parse error in line " + o.line + ", col " + o.linePos + " (error code: " + o.errorCode + ")\n\nError Reason: " + o.reason + "Error Line: " + o.srcText;
            return geoXML3.log("Unable to retrieve " + n.url + ": " + p), i.failedParse && i.failedParse(n), void(n.failed = !0)
        }
        if (a.documentElement && "parsererror" == a.documentElement.nodeName)return geoXML3.log("Unable to retrieve " + n.url + ": " + a.documentElement.childNodes[0].nodeValue), i.failedParse && i.failedParse(n), void(n.failed = !0);
        if (!n)throw"geoXML3 internal error: render called with null document";
        var q;
        n.placemarks = [], n.groundoverlays = [], n.ggroundoverlays = [], n.networkLinks = [], n.gpolygons = [], n.gpolylines = [];
        for (var y = w(a, "styleUrl"), z = n.internals.docSet, q = 0; q < y.length; q++) {
            var G = t(y[q]).split("#")[0];
            if (G) {
                var H = cleanURL(n.baseDir, G);
                if (H !== n.baseUrl && !k[H]) {
                    var I, J = z.indexOfObjWithItem("baseUrl", H);
                    if (-1 != J) {
                        if (I = z[J], I.failed)continue
                    } else I = new Object, I.url = H, I.baseUrl = H, I.internals = n.internals, n.internals.docSet.push(I), n.internals.remaining++;
                    return void b(H, I, function (b) {
                        x(b, I), x(a, n)
                    })
                }
            }
        }
        n.styles = m[n.baseUrl] = m[n.baseUrl] || {};
        var K;
        for (y = w(a, "Style"), nodeCount = y.length, q = 0; q < nodeCount; q++) {
            thisNode = y[q];
            var K = thisNode.getAttribute("id");
            K && d(thisNode, n.baseUrl, K, n.baseDir)
        }
        for (y = w(a, "StyleMap"), q = 0; q < y.length; q++) {
            thisNode = y[q];
            var K = thisNode.getAttribute("id");
            K && f(thisNode, n.baseUrl, K, n.baseDir)
        }
        if ((i.processStyles || !i.createMarker) && B(n), n.reload && n.markers)for (q = 0; q < n.markers.length; q++)n.markers[q].active = !1;
        var L, M, N, O, P, N, Q, R, S = w(a, "Placemark");
        for (pm = 0; pm < S.length; pm++) {
            M = S[pm];
            var T = c(M);
            L = {
                name: t(w(M, "name")[0]),
                description: t(w(M, "description")[0]),
                styleUrl: T.join("#"),
                styleBaseUrl: T[0] ? cleanURL(n.baseDir, T[0]) : n.baseUrl,
                styleID: T[1],
                visibility: u(w(M, "visibility")[0], !0),
                balloonVisibility: u(v(M, s, "balloonVisibility")[0], !i.suppressInfoWindows),
                id: M.getAttribute("id"),
                index: pm
            }, L.style = m[L.styleBaseUrl] && m[L.styleBaseUrl][L.styleID] || e(r);
            var U = w(M, "Style");
            if (U && U.length > 0) {
                var V = d(M, "{inline}", "{inline}");
                A(V), V && (L.style = V)
            }
            /^https?:\/\//.test(L.description) && (L.description = ['<a href="', L.description, '">', L.description, "</a>"].join("")), L.vars = {
                display: {
                    name: "Name",
                    description: "Description",
                    address: "Street Address",
                    id: "ID",
                    Snippet: "Snippet",
                    geDirections: "Directions"
                },
                val: {
                    name: L.name || "",
                    description: L.description || "",
                    address: t(w(M, "address")[0], ""),
                    id: M.getAttribute("id") || "",
                    Snippet: t(w(M, "Snippet")[0], "")
                },
                directions: ["f=d", "source=GeoXML3"]
            };
            var W = w(M, "ExtendedData");
            if (W && W.length > 0)for (var X = w(W[0], "Data"), Y = 0; Y < X.length; Y++) {
                var Z = X[Y], $ = Z.getAttribute("name");
                if ($) {
                    var _ = t(w(Z, "displayName")[0], $), aa = t(w(Z, "value")[0]);
                    L.vars.val[$] = aa, L.vars.display[$] = _
                }
            }
            var ba = w(M, "coordinates"), ca = null;
            if (ba && ba.length > 0)for (var da = 0; da < ba.length; da++)if (ba[da].parentNode && ba[da].parentNode.nodeName) {
                var ea = ba[da].parentNode;
                switch (ca = ea.nodeName) {
                    case"Point":
                        L.Point = g(M, "Point")[0], L.latlng = new google.maps.LatLng(L.Point.coordinates[0].lat, L.Point.coordinates[0].lng), P = 1;
                        break;
                    case"LinearRing":
                        Q = w(M, "Polygon"), L.Polygon || (L.Polygon = [{
                            outerBoundaryIs: {coordinates: []},
                            innerBoundaryIs: [{coordinates: []}]
                        }]);
                        for (var fa = 0; fa < Q.length; fa++)L.Polygon[fa] = {
                            outerBoundaryIs: {coordinates: []},
                            innerBoundaryIs: [{coordinates: []}]
                        }, L.Polygon[fa].outerBoundaryIs = g(Q[fa], "outerBoundaryIs"), L.Polygon[fa].innerBoundaryIs = g(Q[fa], "innerBoundaryIs");
                        R = L.Polygon[0].outerBoundaryIs;
                        break;
                    case"LineString":
                        P = 0, L.LineString = g(M, "LineString")
                }
            }
            if (i.pmParseFn && i.pmParseFn(M, L), n.placemarks.push(L), L.Point) {
                google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, n.bounds.extend(L.latlng));
                var ga = i.createMarker || C, ha = !1;
                if (!i.createMarker && n && (n.markers = n.markers || [], n.reload))for (var J = 0; J < n.markers.length; J++)if (n.markers[J].id == L.id || !n.markers[J].id && n.markers[J].getPosition().equals(L.latlng)) {
                    ha = n.markers[J].active = !0;
                    break
                }
                if (!ha) {
                    var N = ga(L, n);
                    N && (N.active = L.visibility, N.id = L.id)
                }
            }
            var O, ia;
            n && (L.Polygon && (n.gpolygons = n.gpolygons || []), L.LineString && (n.gpolylines = n.gpolylines || []));
            var ja = i.createPolygon || F, ka = i.createLineString || E;
            L.Polygon && (O = ja(L, n), O && (O.active = L.visibility)), L.LineString && (ia = ka(L, n), ia && (ia.active = L.visibility)), google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, O && n.bounds.union(O.bounds), ia && n.bounds.union(ia.bounds))
        }
        if (n.reload && n.markers)for (q = n.markers.length - 1; q >= 0; q--)n.markers[q].active || (n.markers[q].infoWindow && n.markers[q].infoWindow.close(), n.markers[q].setMap(null), n.markers.splice(q, 1));
        if (n.reload && n.groundoverlays)for (q = 0; q < n.groundoverlays.length; q++)n.groundoverlays[q].active = !1;
        n && (n.groundoverlays = n.groundoverlays || []);
        var la, ma, na = w(a, "GroundOverlay");
        for (q = 0; q < na.length; q++) {
            M = na[q];
            var oa = cleanURL(n.baseDir, t(w(M, "href")[0]));
            l[oa] && (oa = l[oa].dataUrl), la = {
                name: t(w(M, "name")[0]),
                description: t(w(M, "description")[0]),
                icon: {href: oa},
                latLonBox: {
                    north: parseFloat(t(w(M, "north")[0])),
                    east: parseFloat(t(w(M, "east")[0])),
                    south: parseFloat(t(w(M, "south")[0])),
                    west: parseFloat(t(w(M, "west")[0]))
                },
                index: q
            }, google.maps && (n.bounds = n.bounds || new google.maps.LatLngBounds, n.bounds.union(new google.maps.LatLngBounds(new google.maps.LatLng(la.latLonBox.south, la.latLonBox.west), new google.maps.LatLng(la.latLonBox.north, la.latLonBox.east))));
            var pa = w(M, "color");
            if (pa && pa.length > 0 ? la.opacity = geoXML3.getOpacity(t(pa[0])) : la.opacity = 1, n.groundoverlays.push(la), i.createOverlay)i.createOverlay(la, n); else {
                var ha = !1;
                if (n && (n.groundoverlays = n.groundoverlays || [], n.reload)) {
                    overlayBounds = new google.maps.LatLngBounds(new google.maps.LatLng(la.latLonBox.south, la.latLonBox.west), new google.maps.LatLng(la.latLonBox.north, la.latLonBox.east));
                    var qa = n.groundoverlays;
                    for (q = qa.length; q--;)if (qa[q].bounds().equals(overlayBounds) && qa.url_ === la.icon.href) {
                        ha = qa[q].active = !0;
                        break
                    }
                }
                ha || (ma = D(la, n), ma.active = !0)
            }
            if (n.reload && n.groundoverlays && n.groundoverlays.length) {
                var qa = n.groundoverlays;
                for (q = qa.length; q--;)qa[q].active || (qa[q].remove(), qa.splice(q, 1));
                n.groundoverlays = qa
            }
        }
        var ra, sa = document.location.pathname.split("/");
        sa = sa.splice(0, sa.length - 1).join("/");
        var ta = w(a, "NetworkLink");
        for (q = 0; q < ta.length; q++)M = ta[q], ra = {
            name: t(w(M, "name")[0]),
            link: {href: t(w(M, "href")[0]), refreshMode: t(w(M, "refreshMode")[0])}
        }, ra.link.refreshMode || (ra.link.refreshMode = "onChange"), "onInterval" === ra.link.refreshMode ? (ra.link.refreshInterval = parseFloat(t(w(M, "refreshInterval")[0])), isNaN(ra.link.refreshInterval) && (ra.link.refreshInterval = 0)) : "onChange" === ra.link.refreshMode && (ra.link.viewRefreshMode = t(w(M, "viewRefreshMode")[0]), ra.link.viewRefreshMode || (ra.link.viewRefreshMode = "never"), "onStop" === ra.link.viewRefreshMode && (ra.link.viewRefreshTime = t(w(M, "refreshMode")[0]), ra.link.viewFormat = t(w(M, "refreshMode")[0]), ra.link.viewFormat || (ra.link.viewFormat = "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]"))), /^[\/|http]/.test(ra.link.href) || (ra.link.href = sa + "/" + ra.link.href), "onInterval" === ra.link.refreshMode && ra.link.refreshInterval > 0 ? setInterval(h + '.parse("' + ra.link.href + '")', 1e3 * ra.link.refreshInterval) : "onChange" === ra.link.refreshMode && ("never" === ra.link.viewRefreshMode ? n.internals.parser.parse(ra.link.href, n.internals.docSet) : "onStop" === ra.link.viewRefreshMode);
        if (n.bounds && (n.internals.bounds = n.internals.bounds || new google.maps.LatLngBounds, n.internals.bounds.union(n.bounds)), (n.markers || n.groundoverlays || n.gpolylines || n.gpolygons) && (n.internals.parseOnly = !1), !n.internals.parseOnly && n.baseUrl)if (k[n.baseUrl])for (var q in k[n.baseUrl])k[n.baseUrl][q] = n[q]; else j.push(n), k[n.baseUrl] = n;
        n.internals.remaining--, 0 === n.internals.remaining && (i.zoom && n.internals.bounds && !n.internals.bounds.isEmpty() && i.map && i.map.fitBounds(n.internals.bounds), i.afterParse && i.afterParse(n.internals.docSet), google.maps.event.trigger(n.internals.parser, "parsed"))
    }, y = function (a, b) {
        var c = {};
        a = a || "ffffffff";
        var d = a.substr(0, 2), e = a.substr(2, 2), f = a.substr(4, 2), g = a.substr(6, 2);
        return c.opacity = parseInt(d, 16) / 256, c.color = "random" === b ? z(g, f, e) : "#" + g + f + e, c
    }, z = function (a, b, c) {
        var d = {rr: a, gg: b, bb: c};
        for (var e in d) {
            var f = d[e];
            null == f && (f = "ff"), f = Math.round(Math.random() * parseInt(a, 16)).toString(16), 1 === f.length && (f = "0" + f), d[e] = f
        }
        return "#" + d.rr + d.gg + d.bb
    }, A = function (a) {
        var b = a.icon;
        if (b && b.href) {
            if (b.img && !b.img.complete && b.dim.w < 0 && b.dim.h < 0)return b.markerBacklog = [], void(b.img.onload = function () {
                b.dim.w < 0 || b.dim.h < 0 ? (b.dim.w = this.width, b.dim.h = this.height) : b.dim.th = this.height, A(a);
                for (var c = 0; c < b.markerBacklog.length; c++) {
                    var d = b.markerBacklog[c][0], e = b.markerBacklog[c][1];
                    C(d, e), d.marker && (d.marker.active = !0)
                }
                delete b.markerBacklog
            });
            b.img && b.img.complete ? b.dim.w < 0 || b.dim.h < 0 ? (b.dim.w = b.img.width, b.dim.h = b.img.height) : b.dim.th = b.img.height : (b.dim.whGuess = !0, b.dim.w = 32, b.dim.h = 32, b.dim.th = 32);
            var c = Math.round, d = b.dim.y;
            "undefined" != typeof b.dim.th && b.dim.th != b.dim.h && (d = Math.abs(d - (b.dim.th - b.dim.h)));
            var e, f, g = {
                x: b.dim.x * b.scale,
                y: d * b.scale,
                w: b.dim.w * b.scale,
                h: b.dim.h * b.scale,
                aX: b.hotSpot.x * b.scale,
                aY: b.hotSpot.y * b.scale,
                iW: (b.img ? b.img.width : b.dim.w) * b.scale,
                iH: (b.img ? b.img.height : b.dim.h) * b.scale
            };
            switch (b.hotSpot.xunits) {
                case"fraction":
                    e = c(g.aX * b.dim.w);
                    break;
                case"insetPixels":
                    e = c(b.dim.w * b.scale - g.aX);
                    break;
                default:
                    e = c(g.aX)
            }
            f = g.h - c(("fraction" === b.hotSpot.yunits ? b.dim.h : 1) * g.aY);
            var h = new google.maps.Point(e, f), i = b.dim.whGuess ? null : new google.maps.Size(c(g.w), c(g.h)), j = 1 == b.scale ? null : b.dim.whGuess ? new google.maps.Size(c(g.w), c(g.h)) : new google.maps.Size(c(g.iW), c(g.iH)), k = new google.maps.Point(c(g.x), c(g.y));
            l[b.url] && (b.url = l[b.url].dataUrl), b.marker = {
                url: b.url,
                size: i,
                origin: k,
                anchor: h,
                scaledSize: j
            };
            var m = /\/(red|blue|green|yellow|lightblue|purple|pink|orange)(-dot)?\.png/, n = new google.maps.Size(59, 32), o = new google.maps.Point(16, 32);
            m.test(b.href) ? b.shadow = {
                url: "http://maps.google.com/mapfiles/ms/micons/msmarker.shadow.png",
                size: n,
                origin: null,
                anchor: o,
                scaledSize: n
            } : b.href.indexOf("-pushpin.png") > -1 && (b.shadow = {
                url: "http://maps.google.com/mapfiles/ms/micons/pushpin_shadow.png",
                size: n,
                origin: null,
                anchor: o,
                scaledSize: n
            })
        }
    }, B = function (a) {
        for (var b in a.styles)A(a.styles[b])
    }, C = function (a, b) {
        var c = a.style.icon;
        if (!c.marker && c.img)return c.markerBacklog = c.markerBacklog || [], void c.markerBacklog.push([a, b]);
        var d = geoXML3.combineOptions(i.markerOptions, {
            map: i.map,
            position: new google.maps.LatLng(a.Point.coordinates[0].lat, a.Point.coordinates[0].lng),
            title: a.name,
            zIndex: Math.round(-1e5 * a.Point.coordinates[0].lat) << 5,
            icon: c.marker,
            shadow: c.shadow,
            flat: !c.shadow,
            visible: a.visibility
        }), e = new google.maps.Marker(d);
        return b && b.markers.push(e), G(a, b, e), a.marker = e, e
    }, D = function (a, b) {
        if (!window.ProjectedOverlay)throw"geoXML3 error: ProjectedOverlay not found while rendering GroundOverlay from KML";
        var c = new google.maps.LatLngBounds(new google.maps.LatLng(a.latLonBox.south, a.latLonBox.west), new google.maps.LatLng(a.latLonBox.north, a.latLonBox.east)), d = geoXML3.combineOptions(i.overlayOptions, {
            percentOpacity: 100 * a.opacity,
            index: a.index
        }), e = new ProjectedOverlay(i.map, a.icon.href, c, d);
        return b && (b.ggroundoverlays = b.ggroundoverlays || [], b.ggroundoverlays.push(e)), "function" == typeof i.onAfterCreateGroundOverlay && i.onAfterCreateGroundOverlay(e), e
    }, E = function (a, b) {
        for (var c = [], d = new google.maps.LatLngBounds, e = 0; e < a.LineString.length; e++) {
            for (var f = [], g = a.LineString[e].coordinates, h = 0; h < g.length; h++) {
                var j = new google.maps.LatLng(g[h].lat, g[h].lng);
                f.push(j), d.extend(j)
            }
            c.push(f)
        }
        var k = (c[0][Math.floor(f.length / 2)], y(a.style.line.color, a.style.line.colorMode)), l = geoXML3.combineOptions(i.polylineOptions, {
            map: i.map,
            path: f,
            strokeColor: k.color,
            strokeWeight: a.style.line.width,
            strokeOpacity: k.opacity,
            title: a.name,
            visible: a.visibility,
            index: a.index
        });
        if (c.length > 1) {
            l.paths = c;
            var m = new MultiGeometry(l)
        } else {
            l.path = c[0];
            var m = new google.maps.Polyline(l)
        }
        return m.bounds = d, G(a, b, m), b && b.gpolylines.push(m), a.polyline = m, "function" == typeof i.onAfterCreatePolyLine && i.onAfterCreatePolyLine(m, a), m
    }, F = function (a, b) {
        for (var c = new google.maps.LatLngBounds, d = 0, e = [], f = 0; f < a.Polygon.length; f++) {
            for (var g = 0; g < a.Polygon[f].outerBoundaryIs.length; g++) {
                for (var h = a.Polygon[f].outerBoundaryIs[g].coordinates, j = [], k = 0; k < h.length; k++) {
                    var l = new google.maps.LatLng(h[k].lat, h[k].lng);
                    j.push(l), c.extend(l)
                }
                e.push(j), d += j.length
            }
            for (var g = 0; g < a.Polygon[f].innerBoundaryIs.length; g++) {
                for (var h = a.Polygon[f].innerBoundaryIs[g].coordinates, j = [], k = 0; k < h.length; k++) {
                    var l = new google.maps.LatLng(h[k].lat, h[k].lng);
                    j.push(l), c.extend(l)
                }
                e.push(j), d += j.length
            }
        }
        var m = y(a.style.line.color, a.style.line.colorMode), n = y(a.style.poly.color, a.style.poly.colorMode);
        a.style.poly.fill || (n.opacity = 0);
        var o = a.style.line.width;
        a.style.poly.outline || (o = 0, m.opacity = 0);
        var p = geoXML3.combineOptions(i.polygonOptions, {
            map: i.map,
            paths: e,
            title: a.name,
            strokeColor: m.color,
            strokeWeight: o,
            strokeOpacity: m.opacity,
            fillColor: n.color,
            fillOpacity: n.opacity,
            visible: a.visibility,
            index: a.index
        }), q = new google.maps.Polygon(p);
        return q.bounds = c, G(a, b, q), b && b.gpolygons.push(q), a.polygon = q, "function" == typeof i.onAfterCreatePolygon && i.onAfterCreatePolygon(q, a), q
    }, G = function (a, b, c) {
        var d = a.style.balloon, e = a.vars;
        if (a.balloonVisibility && "hide" !== d.displayMode) {
            if (!a.latlng || i.suppressDirections && i.suppressDirections)e.val.geDirections = ""; else {
                e.directions.push("sll=" + a.latlng.toUrlValue());
                var f = "http://maps.google.com/maps?" + e.directions.join("&"), g = encodeURIComponent(e.val.address || a.latlng.toUrlValue()).replace(/\%20/g, "+");
                e.val.geDirections = '<a href="' + f + "&daddr=" + g + '" target=_blank>To Here</a> - <a href="' + f + "&saddr=" + g + '" target=_blank>From Here</a>'
            }
            var h = d.text.replace(/\$\[(\w+(\/displayName)?)\]/g, function (a, b, c) {
                return c ? e.display[b] : e.val[b]
            }), j = "geoxml3_infowindow geoxml3_style_" + a.styleID, k = [];
            "ffffffff" != d.bgColor && k.push("background: " + y(d.bgColor).color + ";"), "ff000000" != d.textColor && k.push("color: " + y(d.textColor).color + ";");
            var l = k.length ? ' style="' + k.join(" ") + '"' : "", m = geoXML3.combineOptions(i.infoWindowOptions, {
                content: '<div class="' + j + '"' + l + ">" + h + "</div>",
                pixelOffset: new google.maps.Size(0, 2)
            });
            c.infoWindow = i.infoWindow || new google.maps.InfoWindow(m), delete m.content, c.infoWindowOptions = m, google.maps.event.addListener(c, "click", function (a) {
                "function" == typeof this.infoWindow.$onOpen && this.infoWindow.$onOpen(c);
                var b = this.infoWindow;
                b.close(), b.setOptions(this.infoWindowOptions), a && a.latLng ? b.setPosition(a.latLng) : this.bounds && b.setPosition(this.bounds.getCenter()), google.maps.event.addListenerOnce(b, "domready", function () {
                }), b.open(this.map, this.bounds ? null : this)
            })
        }
    };
    return {
        options: i,
        docs: j,
        docsByUrl: k,
        kmzMetaData: l,
        parse: o,
        render: x,
        parseKmlString: n,
        hideDocument: p,
        showDocument: q,
        processStyles: B,
        createMarker: C,
        createOverlay: D,
        createPolyline: E,
        createPolygon: F
    }
}, geoXML3.getOpacity = function (a) {
    if (a && "" !== a && 8 == a.length) {
        var b = parseInt(a.substr(0, 2), 16);
        return b / 255
    }
    return 1
}, geoXML3.log = function (a) {
    window.console ? console.log(a) : alert("log:" + a)
}, geoXML3.parserOptions = function (a) {
    if (this.map = null, this.zoom = !0, this.singleInfoWindow = !1, this.suppressInfoWindows = !1, this.processStyles = !1, this.markerOptions = {}, this.infoWindowOptions = {}, this.overlayOptions = {}, this.afterParse = null, this.failedParse = null, this.createMarker = null, this.createOverlay = null, a)for (var b in a)a.hasOwnProperty(b) && (this[b] = a[b]);
    return this
}, geoXML3.combineOptions = function (a, b) {
    var c = {};
    if (a)for (var d in a)a.hasOwnProperty(d) && (c[d] = a[d]);
    if (b)for (d in b)b.hasOwnProperty(d) && void 0 === c[d] && (c[d] = b[d]);
    return c
}, geoXML3.parserOptions.prototype.combineOptions = geoXML3.combineOptions, geoXML3.fetchers = [], geoXML3.xmlParse = function (a) {
    if ("undefined" != typeof ActiveXObject || "ActiveXObject"in window) {
        var b = new ActiveXObject("Microsoft.XMLDOM");
        return b.loadXML(a), b
    }
    return "undefined" != typeof DOMParser ? (new DOMParser).parseFromString(a, "text/xml") : document.createElement("div", null)
}, geoXML3.isParseError = function (a) {
    if ("undefined" != typeof ActiveXObject || "ActiveXObject"in window)return !1;
    var b = new DOMParser, c = b.parseFromString("<", "text/xml"), d = c.getElementsByTagName("parsererror")[0].namespaceURI;
    return "http://www.w3.org/1999/xhtml" === d ? a.getElementsByTagName("parsererror").length > 0 : a.getElementsByTagNameNS(d, "parsererror").length > 0
}, geoXML3.fetchXML = function (a, b) {
    function c() {
        b()
    }

    var d = new Object;
    if (geoXML3.fetchers.length)d = geoXML3.fetchers.pop(); else if (window.XMLHttpRequest)d.fetcher = new window.XMLHttpRequest; else if (window.ActiveXObject) {
        for (var e = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP"], f = 0; f < e.length; f++)try {
            d.fetcher = new ActiveXObject(e[f]);
            break
        } catch (g) {
            continue
        }
        if (!d.fetcher)return geoXML3.log("Unable to create XHR object"), b(null), null
    }
    return d.fetcher.open("GET", a, !0), d.fetcher.overrideMimeType && d.fetcher.overrideMimeType("text/xml"), d.fetcher.onreadystatechange = function () {
        if (4 === d.fetcher.readyState) {
            if (d.xhrtimeout && clearTimeout(d.xhrtimeout), d.fetcher.status >= 400)geoXML3.log("HTTP error " + d.fetcher.status + " retrieving " + a), b(); else {
                if (d.fetcher.responseXML) {
                    var c = d.fetcher.responseXML;
                    !c || c.documentElement || c.ownerElement || c.loadXML(d.fetcher.responseText)
                } else c = geoXML3.xmlParse(d.fetcher.responseText);
                c.parseError && 0 != c.parseError.errorCode ? (geoXML3.log("XML parse error " + c.parseError.errorCode + ", " + c.parseError.reason + "\nLine:" + c.parseError.line + ", Position:" + c.parseError.linepos + ", srcText:" + c.parseError.srcText), c = "failed parse") : geoXML3.isParseError(c) && (geoXML3.log("XML parse error"), c = "failed parse"), b(c)
            }
            geoXML3.fetchers.push(d)
        }
    }, d.xhrtimeout = setTimeout(c, 6e4), d.fetcher.send(null), null
};
var IEversion = function () {
    var a = -1;
    if ("Microsoft Internet Explorer" == navigator.appName) {
        var b = navigator.userAgent, c = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
        null != c.exec(b) && (a = parseFloat(RegExp.$1))
    }
    return a
};
geoXML3.fetchZIP = function (a, b, c) {
    new ZipFile(a, function (d) {
        for (var e = 0; e < d.status.length; e++) {
            var f = d.status[e];
            if (0 == f.indexOf("ERROR"))return geoXML3.log("HTTP/ZIP error retrieving " + a + ": " + f), void b();
            0 == f.indexOf("WARNING") && geoXML3.log("HTTP/ZIP warning retrieving " + a + ": " + f)
        }
        for (var g, h = 0, e = 0; e < d.entries.length; e++) {
            var i = d.entries[e].name;
            /\.kml$/.test(i) && (h++, 1 == h ? g = e : geoXML3.log("KMZ warning retrieving " + a + ': found extra KML "' + i + '" in KMZ; discarding...'))
        }
        for (var j = cleanURL(defileURL(a), a) + "/", k = {
            timer: null,
            extractLeft: 0,
            timerCalls: 0
        }, l = function (a, d) {
            var e = cleanURL(j, a.name), f = a.name.substring(a.name.lastIndexOf(".") + 1).toLowerCase();
            if (k.extractLeft--, "string" == typeof d.description && "Error" == d.name)return geoXML3.log("KMZ error extracting " + e + ": " + d.description), void b();
            var g;
            "jpg" === f && (f = "jpeg"), g = /^(gif|jpeg|png)$/.test(f) ? "image/" + f : "mp3" === f ? "audio/mpeg" : "m4a" === f ? "audio/mp4" : "m4a" === f ? "audio/MP4-LATM" : "application/octet-stream", c.kmzMetaData[e] = {}, c.kmzMetaData[e].entry = a, c.kmzMetaData[e].dataUrl = "data:" + g + ";base64," + base64Encode(d), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && (IEversion() < 8 && c.kmzMetaData[e].dataUrl.length > 2071 || 9 > IEversion && c.kmzMetaData[e].dataUrl.length > 32767) && (c.kmzMetaData[e].dataUrl = "data:image/gif;base64,R0lGODlhDwAQAOMPADBPvSpQ1Dpoyz1p6FhwvU2A6ECP63CM04CWxYCk+V6x+UK++Jao3rvC3fj7+v///yH5BAEKAA8ALAAAAAAPABAAAASC8Mk5mwCAUMlWwcLRHEelLAoGDMgzSsiyGCAhCETDPMh5XQCBwYBrNBIKWmg0MCQHj8MJU5IoroYCY6AAAgrDIbbQDGIK6DR5UPhlNo0JAlSUNAiDgH7eNAxEDWAKCQM2AAFheVxYAA0AIkFOJ1gBcQQaUQKKA5w7LpcEBwkJaKMUEQA7"), c.kmzMetaData[internalSrc(a.name)] = c.kmzMetaData[e]
        }, m = function (c, d) {
            return "string" == typeof d.description && "Error" == d.name ? (geoXML3.log("KMZ error extracting " + mdUrl + ": " + d.description), void b()) : (clearTimeout(k.timer), k.extractLeft <= 1 ? (k.extractLeft--, void b(geoXML3.xmlParse(d))) : (k.timerCalls++, void(k.timerCalls < 100 ? k.timer = setTimeout(function () {
                m(c, d)
            }, 100) : (geoXML3.log("KMZ warning extracting " + a + ": entire ZIP has not been extracted after 10 seconds; running through KML, anyway..."), k.extractLeft--, b(geoXML3.xmlParse(d))))))
        }, e = 0; e < d.entries.length; e++) {
            var n = d.entries[e], o = n.name.substring(n.name.lastIndexOf(".") + 1).toLowerCase();
            /^(gif|jpe?g|png|kml)$/.test(o) && ("kml" !== o || e == g) && (c || "kml" == o) && (k.extractLeft++, "kml" === o ? n.extract(m) : n.extract(l))
        }
    })
}, geoXML3.nodeValue = function (a, b) {
    var c = "";
    if (!a)return "undefined" == typeof b || null === b ? null : b;
    if (3 == a.nodeType || 4 == a.nodeType || 2 == a.nodeType)c += a.nodeValue; else if (1 == a.nodeType || 9 == a.nodeType || 11 == a.nodeType)for (var d = 0; d < a.childNodes.length; ++d)c += arguments.callee(a.childNodes[d]);
    return c
}, geoXML3.getBooleanValue = function (a, b) {
    var c = geoXML3.nodeValue(a);
    return null === c ? b || !1 : (c = parseInt(c), isNaN(c) ? !0 : 0 == c ? !1 : !0)
}, geoXML3.getElementsByTagNameNS = function (a, b, c) {
    if (a && "undefined" != typeof a.getElementsByTagNameNS)return a.getElementsByTagNameNS(b, c);
    if (!a)return [];
    var d = a.documentElement || a.ownerDocument && a.ownerDocument.documentElement;
    if (!d || !d.attributes)return [];
    for (var e = 0; e < d.attributes.length; e++) {
        var f = d.attributes[e];
        if ("xmlns" === f.prefix && f.nodeValue === b)return a.getElementsByTagName(f.baseName + ":" + c);
        if ("xmlns" === f.nodeName && f.nodeValue === b)return "undefined" != typeof a.selectNodes ? (d.ownerDocument.getProperty("SelectionNamespaces") || d.ownerDocument.setProperty("SelectionNamespaces", "xmlns:defaultNS='" + b + "'"), a.selectNodes(".//defaultNS:" + c)) : (d.setAttribute("xmlns:defaultNS", b), a.getElementsByTagName("defaultNS:" + c))
    }
    return geoXML3.getElementsByTagName(a, c)
}, geoXML3.getElementsByTagName = function (a, b) {
    return a && "undefined" != typeof a.getElementsByTagNameNS ? a.getElementsByTagName(b) : a.getElementsByTagName(b)
};
var toAbsURL = function (a, b) {
    var c, d, e, f = location.protocol + "://" + location.host;
    if (!b.length)return "";
    if (/^\w+:/.test(b))return b;
    if (0 == b.indexOf("/"))return f + b;
    if (c = a.replace(/\/[^\/]*$/, ""), d = b.match(/\.\.\//g))for (b = b.substring(3 * d.length), e = d.length; e--;)c = c.substring(0, c.lastIndexOf("/"));
    return f + c + "/" + b
}, internalSrc = function (a) {
    var b = document.location.href;
    b = b.substring(0, b.lastIndexOf("/") + 1);
    var c = b + a;
    return c
}, dehostURL = function (a) {
    var b = location.protocol + "://" + location.host;
    return b = b.replace(/([\.\\\+\*\?\[\^\]\$\(\)])/g, "\\$1"), a.replace(new RegExp("^" + b, "i"), "")
}, cleanURL = function (a, b) {
    return dehostURL(toAbsURL(a ? a.split("#")[0].split("?")[0] : defileURL(location.pathname), b ? b.split("#")[0].split("?")[0] : ""))
}, defileURL = function (a) {
    return a ? a.substr(0, a.lastIndexOf("/") + 1) : "/"
};
Array.prototype.hasObject = Array.indexOf ? function (a) {
    return -1 !== this.indexOf(a)
} : function (a) {
    for (var b = this.length + 1; b--;)if (this[b - 1] === a)return !0;
    return !1
}, Array.prototype.hasItemInObj = function (a, b) {
    for (var c = this.length + 1; c--;)if (this[c - 1][a] === b)return !0;
    return !1
}, Array.prototype.indexOf || (Array.prototype.indexOf = function (a, b) {
    null == b ? b = 0 : 0 > b && (b = Math.max(0, this.length + b));
    for (var c = b, d = this.length; d > c; c++)if (this[c] === a)return c;
    return -1
}), Array.prototype.indexOfObjWithItem = function (a, b, c) {
    null == c ? c = 0 : 0 > c && (c = Math.max(0, this.length + c));
    for (var d = c, e = this.length; e > d; d++)if (this[d][a] === b)return d;
    return -1
};
var base64Encode = function (a) {
    for (var b, c, d, e, f, g, h, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", j = "", k = 0; k < a.length;)b = a[k++], c = a[k++], d = a[k++], e = b >> 2, f = (3 & b) << 4 | c >> 4, g = (15 & c) << 2 | d >> 6, h = 63 & d, void 0 == c ? g = h = 64 : void 0 == d && (h = 64), j = j + i.charAt(e) + i.charAt(f) + i.charAt(g) + i.charAt(h);
    return j
};
!function (a) {
    "use strict";
    a.module("LogicifyGMap", [])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").service("SmartCollection", [function () {
        function b(b) {
            var d = this, e = null;
            d.next = function () {
                return null == e ? e = 0 : e++, void 0 !== d[e] ? d[e] : void(e = null)
            }, d.setIterator = function (b) {
                if (a.isNumber(b) && NaN !== b) {
                    if (void 0 === d[b])throw new Error("Can not reach this element, because it doesn't exist. Index: " + b);
                    e = b
                }
            }, Array.isArray(b) && b.forEach(function (a, b) {
                d.push(a)
            }), d._uid = c++;
            var f = [], g = [], h = d.push;
            d.push = function () {
                var a = Array.prototype.slice.call(arguments), b = h.apply(d, a);
                return a.forEach(function (a) {
                    f.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            };
            var i = d.pop;
            d.pop = function () {
                var a = Array.prototype.slice.call(arguments), b = i.apply(d, a);
                return g.forEach(function (a) {
                    a.apply(d, [b])
                }), b
            };
            var j = d.unshift;
            d.unshift = function () {
                var a = Array.prototype.slice.call(arguments), b = j.apply(d, a);
                return a.forEach(function (a) {
                    f.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            };
            d.shift;
            d.shift = function () {
                var a = Array.prototype.slice.call(arguments), b = j.apply(d, a);
                return g.forEach(function (a) {
                    a.apply(d, [b])
                }), b
            };
            var k = d.splice;
            d.splice = function () {
                var a = Array.prototype.slice.call(arguments), b = k.apply(d, a);
                return b.forEach(function (a) {
                    g.forEach(function (b) {
                        b.apply(d, [a])
                    })
                }), b
            }, d.removeQuietly = k, d.onRemoveItem = function (a) {
                "function" == typeof a && g.push(a)
            }, d.onAddItem = function (a) {
                "function" == typeof a && f.push(a)
            }
        }

        var c = 0;
        return Array.isArray = function (a) {
            return "[object Array]" === Object.prototype.toString.call(a) || null != a && a.constructor && "SmartCollection" === a.constructor.name && "[object Array]" === Object.prototype.toString.call(a.__proto__.__proto__)
        }, b.prototype = Object.create(Array.prototype), b.prototype.constructor = b, b
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmapControl", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (c, e, f, g) {
                function h(a, b) {
                    google.maps.event.addDomListener(l[0], a, function () {
                        var a = arguments, c = this;
                        d(function () {
                            b.apply(c, a)
                        })
                    })
                }

                var i = c.$eval(f.controlPosition), j = c.$eval(f.controlIndex), k = c.$eval(f.events), l = a.element(e.html().trim());
                b(l)(c), d(function () {
                    c.$apply()
                }), l[0].index = j || 0, e.html(""), g.$mapReady(function (b) {
                    if (!b.controls[i])throw new Error("Position of control on the map is invalid. Please see google maps spec.");
                    b.controls[i].push(l[0]), null != k && a.forEach(k, function (a, b) {
                        "function" == typeof a && h(b, a)
                    })
                })
            }
        }
    }])
}(angular), function (a) {
    "use strict";
    a.module("LogicifyGMap").directive("logicifyGmap", ["$compile", "$log", "$timeout", function (b, c, d) {
        return {
            restrict: "E", controller: function () {
                var a = this, b = [];
                return a.$mapReady = function (c) {
                    return c && a.map ? void c(a.map) : void("function" == typeof c && b.push(c))
                }, a.$setTheMap = function (c) {
                    for (var d = 0; d < b.length; d++)b[d](c);
                    b = [], a.map = c
                }, a
            }, link: function (e, f, g, h) {
                if ("undefined" == typeof google)return void c.error("There is no google maps lib. Please check that you load it before angular.js");
                var i = e.$new(), j = i.$eval(g.gmOptions), k = i.$eval(g.gmReady), l = {
                    zoom: 8,
                    center: new google.maps.LatLng(-34.397, 150.644)
                }, m = i.$eval(g.cssOptions);
                j = j || {};
                var n = {height: "100%", width: "100%", position: "absolute"};
                a.extend(n, m), a.extend(l, j), f.css(n);
                var o = a.element("<div>");
                o.css({height: "100%", width: "100%", margin: 0, padding: 0}), f.append(o);
                var p = new google.maps.Map(o[0], l);
                "function" == typeof k && k(p), p.openInfoWnd = function (a, c, e, f, g) {
                    if (g.apply(f, [c, e]), f.$scope && f.$compiled)d(function () {
                        f.$scope.$apply()
                    }); else {
                        var h = i.$new();
                        h.$infoWND = f, f.$scope = h, d(function () {
                            h.$apply()
                        })
                    }
                    if (f.$compiled !== !0) {
                        var j = b(a.trim())(f.$scope);
                        f.$compiled = !0, f.setContent(j[0])
                    }
                    "function" != typeof f.$onOpen && (f.$onOpen = function (a) {
                        "function" == typeof f.onAfterOpen && f.onAfterOpen(a)
                    })
                }, p.closeInfoWnd = function (a, b) {
                    a.$scope && (a.$compiled = !1, a.$scope.$destroy(), delete a.$scope, delete a.$compiled), b.apply(a, [])
                }, h.$setTheMap(p)
            }
        }
    }])
}(angular), function (a, b) {
    "use strict";
    a.module("LogicifyGMap").directive("xmlOverlays", ["$timeout", "$log", "$q", "$compile", "$http", "SmartCollection", function (c, d, e, f, g, h) {
        return {
            restrict: "E", require: "^logicifyGmap", link: function (e, f, i, j) {
                function k(b, c) {
                    var d = {};
                    return a.extend(d, e.parserOptions), d.map = b, d.afterParse = o, d.onAfterCreateGroundOverlay = e.events.onAfterCreateGroundOverlay, d.onAfterCreatePolygon = e.events.onAfterCreatePolygon, d.onAfterCreatePolyLine = e.events.onAfterCreatePolyLine, d.failedParse = p, d.infoWindow = c, d
                }

                function l() {
                    return e.$watch("kmlCollection._uid", function (a, b) {
                        if (null == a)if (e.kmlCollection = new h(e.$eval(i.kmlCollection)), (e.downLoadingStarted === !0 || e.parserStarted === !0) && (e.cancel = !0), e.cancel === !0)var c = e.$watch("cancel", function (a, b) {
                            a === !0 && (u(), c())
                        }); else u()
                    })
                }

                function m(a) {
                    null != a && (a.downloadNext = !1, e.currentDocument = a, w(a))
                }

                function n(a) {
                    t(a)
                }

                function o(a) {
                    return e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (a[0].$uid = (new Date).getTime() + "-index-" + Math.floor(-9 * Math.random()), e.currentDocument.doc = a, "function" == typeof e.events.onAfterParse && e.events.onAfterParse(a), void q(null, e.currentDocument))
                }

                function p() {
                    if (e.cancel === !0)return c(function () {
                        e.cancel = !1
                    }), !1;
                    var a = {message: "Failed to parse file url: " + e.currentDocument.url};
                    d.error(a.message), "function" == typeof e.events.onAfterParseFailed && e.events.onAfterParseFailed(a), q(a)
                }

                function q(a, b) {
                    r("parserStarted", !1, v), e.currentDocument.downloadNext === !1 ? (delete e.currentDocument.downloadNext, s()) : (e.currentDocument = e.kmlCollection.next(), w(e.currentDocument))
                }

                function r(a, b, c) {
                    e[a] = b, "function" == typeof c && c()
                }

                function s() {
                    e.globalBounds = new google.maps.LatLngBounds, 1 != e.kmlCollection.length && e.fitBoundsAfterAll !== !1 ? (e.kmlCollection.forEach(function (a) {
                        e.globalBounds.extend(a.doc[0].bounds.getCenter())
                    }), c(function () {
                        e.gMap.fitBounds(e.globalBounds)
                    }, 10)) : e.kmlCollection.length > 0 && e.fitBoundsAfterAll !== !1 && c(function () {
                        e.gMap.fitBounds(e.kmlCollection[0].doc[0].bounds)
                    }, 10)
                }

                function t(b) {
                    if (b) {
                        y.hideDocument(b.doc[0]);
                        var c = y.docs.indexOf(b.doc[0]);
                        c > -1 && (delete y.docsByUrl[b.doc[0].baseUrl], y.docs.splice(c, 1), s())
                    } else a.forEach(y.docs, function (a) {
                        y.hideDocument(a)
                    }), y.docs.splice(0, y.docs.length), y.docsByUrl = {}, e.globalBounds = null, e.currentDocument = null
                }

                function u() {
                    Array.isArray(e.kmlCollection) && 0 !== e.kmlCollection.length ? (e.finished = !1, void 0 !== e.currentDocument && t(), e.currentDocument = e.kmlCollection.next(), e.kmlCollection.onAddItem(m), e.kmlCollection.onRemoveItem(n), w(e.currentDocument)) : e.currentDocument = null
                }

                function v() {
                    "function" == typeof e.onProgress && e.onProgress({
                        isDownloading: e.downLoadingStarted,
                        isParsing: e.parserStarted,
                        finished: e.finished
                    })
                }

                function w(a) {
                    return a ? e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (r("downLoadingStarted", !0, v), void(null != a.url ? g.get(a.url, {responseType: "arraybuffer"}).then(function (a) {
                        var b = new Blob([a.data], {type: a.headers()["content-type"]});
                        b.lastModifiedDate = new Date, b.name = "example" + b.lastModifiedDate, x(b)
                    }) : "String" == typeof a.content ? x(null, a.content) : a instanceof Blob ? x(a) : d.error("Incorrect file type. Should be an instance of a Blob or String (url)."))) : (r("finished", !0, v), s(), !1)
                }

                function x(a, b) {
                    return e.cancel === !0 ? (c(function () {
                        e.cancel = !1
                    }), !1) : (r("parserStarted", !0), r("downLoadingStarted", !1, v), void(null == b ? y.parse(a) : y.parseKmlString(b)))
                }

                var y = null;
                e.kmlCollection = new h(e.$eval(i.kmlCollection)), e.events = e.$eval(i.gmapEvents) || {}, e.parserOptions = e.$eval(i.parserOptions) || {}, e.onProgress = e.$eval(i.onProgress), e.fitBoundsAfterAll = e.$eval(i.fitAllLayers), j.$mapReady(function (a) {
                    e.infowindow = e.$eval(i.infoWindow), e.collectionsWatcher = l(), e.gMap = a, e.infowindow && "function" == typeof e.infowindow.$ready ? e.infowindow.$ready(function (c) {
                        y = new b.parser(k(a, c)), u()
                    }) : (y = new b.parser(k(a)), u())
                }), e.cancel = !1, e.$on("$destroy", function () {
                    "function" == typeof e.collectionsWatcher && e.collectionsWatcher()
                })
            }
        }
    }])
}(angular, geoXML3), function (a) {
    a.module("LogicifyGMap").service("InfoWindow", ["$log", "$rootScope", "$templateCache", "$timeout", "$http", "$compile", function (a, b, c, d, e, f) {
        function g() {
            function b(a) {
                var b = d.open;
                d.open = function (c, e) {
                    h = c, "function" == typeof c.openInfoWnd && c.openInfoWnd(a, c, e, d, b)
                };
                var c = d.close;
                if (d.close = function (a) {
                        h && ("function" == typeof h.closeInfoWnd && a === !0 ? h.closeInfoWnd(d, c) : c.apply(d, []))
                    }, g = !0, f.length > 0) {
                    for (var e = 0; e < f.length; e++)f[e](d);
                    f = []
                }
            }

            if (!google)return void a.error("Google maps lib is not found. Please check that you load it before angular.");
            var d = this, f = [], g = !1, h = null;
            d.$ready = function (a) {
                return g === !0 && a ? void a(d) : void(a && f.push(a))
            }, arguments[0] ? arguments[0].templateUrl ? e.get(arguments[0].templateUrl, {cache: c}).then(function (a) {
                arguments[0].content = a.data, google.maps.InfoWindow.apply(d, arguments), b(a.data)
            }) : arguments[0].content && (google.maps.InfoWindow.apply(d, arguments), b(arguments[0].content)) : google.maps.InfoWindow.apply(d, arguments)
        }

        return google && (g.prototype = Object.create(google.maps.InfoWindow.prototype), g.prototype.constructor = g), g
    }])
}(angular);